book_id,book_title,rate_score,rate_nums,book_pub_info,book_desc,book_url,pic_url,price,isbn,content_summary,author_summary,catalog
36365320,Python编程（第3版）,9.3,(146人评价),[美] 埃里克 • 马瑟斯（Eric Matthes） / 袁国忠 / 人民邮电出版社 / 2023-5 / 109.80元,"享誉全球的Python入门书，影响了超过250万读者。
◎ 编辑推荐
编程入门就选蟒蛇书！
【经典】Python入门圣经，长居 Amazon、京东等编程类图...",https://book.douban.com/subject/36365320/,https://img3.doubanio.com/view/subject/s/public/s34505252.jpg,109.80元,9787115613639,"享誉全球的Python入门书，影响了超过250万读者。 ◎ 编辑推荐 编程入门就选蟒蛇书！ 【经典】Python入门圣经，长居 Amazon、京东等编程类图书榜首 【畅销】热销全球，以 13 个语种发行，影响超过 250 万读者 【口碑】好评如潮，第 2 版豆瓣评分 9.2，Amazon 4.7 星评 【升级】代码基于 Python 3.11 升级，涵盖语言最新特性 【资源丰富】配套视频 + PPT课件 + 随书代码 + 速查地图 【自学神器】真正零基础，自学超轻松，附赠学习路线图 【品质提升】精雕细琢，邀请20位一线开发人员审读全书 ◎ 内容简介 本书是针对所有层次的 Python 读者而作的 Python 入门书。全书分为两部分：第一部分介绍使用Python 编程所必须了解的基本概念，包括强大的 Python 库和工具，以及列表、字典、if 语句...(展开全部)





享誉全球的Python入门书，影响了超过250万读者。 ◎ 编辑推荐 编程入门就选蟒蛇书！ 【经典】Python入门圣经，长居 Amazon、京东等编程类图书榜首 【畅销】热销全球，以 13 个语种发行，影响超过 250 万读者 【口碑】好评如潮，第 2 版豆瓣评分 9.2，Amazon 4.7 星评 【升级】代码基于 Python 3.11 升级，涵盖语言最新特性 【资源丰富】配套视频 + PPT课件 + 随书代码 + 速查地图 【自学神器】真正零基础，自学超轻松，附赠学习路线图 【品质提升】精雕细琢，邀请20位一线开发人员审读全书 ◎ 内容简介 本书是针对所有层次的 Python 读者而作的 Python 入门书。全书分为两部分：第一部分介绍使用Python 编程所必须了解的基本概念，包括强大的 Python 库和工具，以及列表、字典、if 语句、类、文件和异常、测试代码等内容；第二部分将理论付诸实践，讲解如何开发三个项目，包括简单的 2D 游 戏、利用数据生成交互式的信息图以及创建和定制简单的 Web 应用程序，并帮助读者解决常见编程问题和困惑。第 3 版进行了全面修订：使用了文本编辑器 VS Code，新增了介绍 removeprefix() 方法和removesuffix() 方法的内容，并且在项目中利用了Matplotlib 和 Plotly 的最新特性，等等。 本书适合对 Python 感兴趣的所有读者阅读。 ◎ 名人推荐 编程教学之道，一是重在实践，二是循序渐进——通过巧妙的实战项目，激发和保持学习的热情，让学习渐入佳境。在这两方面，这本书无疑都是非常出色的。无论是初次尝试编程，还是打算拥抱人工智能，相信这本书都会成为你的最佳起点。 ——爱可可-爱生活，北京邮电大学副教授陈光老师 很高兴看到这本书的第3版更新，这是一本实操性很强的Python语言零基础入门和起步教材。它最大的特色在于，在为初学者构建完整的Python语言知识体系的同时，面向实际应用情境编写代码样例，而且许多样例还是后续实践项目部分的伏笔。实践项目部分的选题经过精心设计，生动详尽又面面俱到。相信这本书能够得到更多Python初学者的喜爱。 ——陈斌，北京大学地球与空间科学学院教授、北京市高等学校教学名师 这本书的前两版已经广销全球，而且稳居Python图书的各大销量榜首，这足以证明它的内容有多么出色！这本书简明又全面地阐述了入门Python需要掌握的各方面知识，可以说是学习Python的不二选择。 ——崔庆才，《Python 3网络爬虫开发实战》作者、微软（中国）软件工程师 Python Crash Course从2016年出版，到现在刚刚7年就已经增补到了第3版，可见作者是认真的、市场是认可的、内容是靠谱的。关键是，这本书在图灵的Python技术图书中的核心地位难以撼动。为什么呢？因为其他入门书没这本全面，而其他专业领域图书又没这本好读，它基本上可以作为将其他所有Python技术图书串联起来的总线。这本书唯一的缺点可能就是太厚，读者怕读不完。其实不必，第一部分看过后，其余内容就可以当成工程辞典，有需要时查阅即可。注意原书副标题“A Hands-On, Project-Based Introduction to Programming”点出了关键：这是以一个个小项目为线索来阐述如何用Python进行具体编程的书。它的每一个版本都紧跟Python的进步而增补，值得收藏。 ——大妈，CPyUG联合创始人、蟒营®创始人 本书注重用户体验，列举了大量易于理解的例子和各种练习来帮助读者掌握Python，非常适合初学者以及有一定编程经验的人学习Python。 ——廖雪峰，知名技术专家 从这本书第1版起，我就开始把它推荐给身边正在学Python的朋友，因为作为Python入门的第一本书，它对初学者非常友好。如今这本书已经更新到了第3版，内容与时俱进且更加精练，现在依然是最好的Python入门读物之一。 ——刘志军，公众号“Python之禅”主理人 说实话，这本书可能不太需要那么多推荐。近十年来，这本书引导着包括我在内的无数Python开发者进入了Python世界。在我心中，放眼全球，它在Python入门书中应该是“天花板”般的存在。而更令人惊喜的是，中文版的翻译水平也是引进图书的“天花板”。因此，请放心，这本书一定能将你带入令人陶醉的Python开发世界！ ——Manjusaka，PyCon China负责人、Python播客“捕蛇者说”联合创始人、微软MVP 这是一本让你轻松掌握Python的绝佳教材。这本书用简练的文字阐述Python知识，已成为百万读者信赖的“编程圣经”。它包含三个实战项目：《外星人入侵》游戏、数据可视化、Web开发，方便读者迅速学以致用。渴望学习Python的朋友，这本书无疑是你不容错过的入门必读之作！ ——彭涛，“涛哥聊Python”博主、字码网络科技创始人 编程语言很快就要成为大家母语之外应该掌握的第二语言，而Python是学习编程的优选语言。这本书内容循序渐进、基础与实战相结合，非常适合Python初学者，是新手入门的最佳选择。 ——豌豆花下猫，自媒体“Python猫”主理人 如果你想学习Python编程，那么这是一本非常适合初学者和有经验的程序员的入门书。本书将Python编程的基本概念和相关工具讲解得深入浅出，通过三个实际项目的开发帮助读者更好地理解如何应用所学的概念和技巧，同时解决实际编程中遇到的问题和困惑。第3版进行了全面修订，采用了流行的编程软件，并且新增了一些内容。这是一本值得放在你桌上的书。 ——翁恺，浙江大学计算机学院教授 最理想的新人入门书应该满足两个特点：第一就是内容通俗易懂；第二就是要有实战，能够让读者在学完之后知道具体怎么用。这本书刚好满足了这两点，而且销量也是一个很好的证明。不管你是要入门还是精进Python，都建议你读一读这本经典著作。 ——张俊红，《对比Excel，轻松学习Python数据分析》作者 “蟒蛇书”是我最常向朋友们推荐的Python入门书之一。全书内容安排合理，既有通俗易懂的技术概念讲解，又包含大量有趣的项目实战，可谓面面俱到，尤其适合初学者。 ——朱雷（@piglei），腾讯公司高级工程师、《Python工匠：案例、技巧与工程实践》作者 这本书是我的Python启蒙老师，它不仅有详细的语法讲解，还配有大量项目案例，第3版的实践项目更加丰富。所谓“输出是最好的输入”，通过Python来实现数据分析、数据可视化、Web开发等，帮助自己提升工作效率，是非常有成就感的事。 ——朱卫军，公众号“Python大数据分析”主理人",埃里克·马瑟斯（Eric Matthes） 缔造技术图书销售奇迹的作家，作品影响了全球数百万读者。 致力于推动Python编程在全球的普及。执教计算机科学和数学25年，教学风格轻松有趣，深受学生喜爱。他对编程的热爱和丰厚的教学经验淋漓尽致地体现在了蟒蛇书《Python编程：从入门到实践》中。 蟒蛇书备受读者推崇。无论是熟练掌握其他编程语言的程序员，还是年仅10岁的萌新，都是本书拥趸。该书在全球范围内被翻译为12种语言，累计热销近300万册，其中仅中文版前两版的销量就超过了120万册。,"第一部分　基础知识
        第1章　起步 2
        1.1　编程环境简介 2
        1.1.1　Python版本 2
        1.1.2　运行Python代码片段 2
        1.1.3　编辑器VS Code简介 3
        1.2　在各种操作系统中搭建Python编程
        环境 3
        1.2.1 在Windows系统中搭建Python编程环境 4
        1.2.2　在macOS系统中搭建Python编程环境 5
        1.2.3　在Linux系统中搭建Python
        编程环境 6
        1.3　运行Hello World程序 7
        1.3.1　给VS Code安装Python扩展 7
        1.3.2　运行程序hello_world.py 8
        1.4　排除安装问题 8
        1.5　从终端运行Python程序 9
        1.5.1　在Windows系统中从终端
        运行Python程序 9
        1.5.2　在Linux和macOS系统中从
        终端运行Python程序 10
        1.6　小结 11
        第2章　变量和简单的数据类型 12
        2.1　运行hello_world.py时发生的情况 12
        2.2　变量 12
        2.2.1　变量的命名和使用 13
        2.2.2　如何在使用变量时避免命名
        错误 14
        2.2.3　变量是标签 15
        2.3　字符串 16
        2.3.1　使用方法修改字符串的大小写 16
        2.3.2　在字符串中使用变量 17
        2.3.3　使用制表符或换行符来添加
        空白 18
        2.3.4　删除空白 18
        2.3.5　删除前缀 20
        2.3.6　如何在使用字符串时避免语法错误 20
        2.4　数 22
        2.4.1　整数 22
        2.4.2　浮点数 23
        2.4.3　整数和浮点数 23
        2.4.4　数中的下划线 24
        2.4.5　同时给多个变量赋值 24
        2.4.6　常量 24
        2.5　注释 25
        2.5.1　如何编写注释 25
        2.5.2　该编写什么样的注释 25
        2.6　Python之禅 26
        2.7　小结 27
        第3章　列表简介 28
        3.1　列表是什么 28
        3.1.1　访问列表元素 28
        3.1.2　索引从0而不是1开始 29
        3.1.3　使用列表中的各个值 30
        3.2　修改、添加和删除元素 30
        3.2.1　修改列表元素 31
        3.2.2　在列表中添加元素 31
        3.2.3　从列表中删除元素 32
        3.3　管理列表 37
        3.3.1　使用sort()方法对列表进行永久排序 37
        3.3.2　使用sorted()函数对列表进行临时排序 37
        3.3.3　反向打印列表 38
        3.3.4　确定列表的长度 39
        3.4　使用列表时避免索引错误 40
        3.5　小结 41
        第4章　操作列表 42
        4.1　遍历整个列表 42
        4.1.1　深入研究循环 43
        4.1.2　在for循环中执行更多的操作 44
        4.1.3　在for循环结束后执行一些
        操作 45
        4.2　避免缩进错误 45
        4.2.1　忘记缩进 46
        4.2.2　忘记缩进额外的代码行 46
        4.2.3　不必要的缩进 47
        4.2.4　循环后不必要的缩进 47
        4.2.5　遗漏冒号 48
        4.3　创建数值列表 49
        4.3.1　使用range()函数 49
        4.3.2　使用range()创建数值列表 50
        4.3.3　对数值列表执行简单的统计
        计算 51
        4.3.4　列表推导式 52
        4.4　使用列表的一部分 53
        4.4.1　切片 53
        4.4.2　遍历切片 54
        4.4.3　复制列表 55
        4.5　元组 57
        4.5.1　定义元组 58
        4.5.2　遍历元组中的所有值 58
        4.5.3　修改元组变量 59
        4.6　设置代码格式 60
        4.6.1　格式设置指南 60
        4.6.2　缩进 60
        4.6.3　行长 61
        4.6.4　空行 61
        4.6.5　其他格式设置指南 61
        4.7　小结 62
        第5章　if语句 63
        5.1　一个简单的示例 63
        5.2　条件测试 64
        5.2.1　检查是否相等 64
        5.2.2　如何在检查是否相等时忽略
        大小写 64
        5.2.3　检查是否不等 65
        5.2.4　数值比较 66
        5.2.5　检查多个条件 66
        5.2.6　检查特定的值是否在列表中 67
        5.2.7　检查特定的值是否不在列表中 68
        5.2.8　布尔表达式 68
        5.3　if语句 69
        5.3.1　简单的if语句 69
        5.3.2　if-else语句 70
        5.3.3　if-elif-else语句 71
        5.3.4　使用多个elif代码块 72
        5.3.5　省略else代码块 73
        5.3.6　测试多个条件 73
        5.4　使用if语句处理列表 76
        5.4.1　检查特殊元素 76
        5.4.2　确定列表非空 77
        5.4.3　使用多个列表 77
        5.5　设置if语句的格式 79
        5.6　小结 80
        第6章　字典 81
        6.1　一个简单的字典 81
        6.2　使用字典 82
        6.2.1　访问字典中的值 82
        6.2.2　添加键值对 83
        6.2.3　从创建一个空字典开始 83
        6.2.4　修改字典中的值 84
        6.2.5　删除键值对 85
        6.2.6　由类似的对象组成的字典 86
        6.2.7　使用get()来访问值 87
        6.3　遍历字典 88
        6.3.1　遍历所有的键值对 88
        6.3.2　遍历字典中的所有键 90
        6.3.3　按特定的顺序遍历字典中的
        所有键 92
        6.3.4　遍历字典中的所有值 92
        6.4　嵌套 94
        6.4.1　字典列表 94
        6.4.2　在字典中存储列表 97
        6.4.3　在字典中存储字典 98
        6.5　小结 100
        第7章　用户输入和while循环 101
        7.1　input()函数的工作原理 101
        7.1.1　编写清晰的提示 102
        7.1.2　使用int()来获取数值输入 103
        7.1.3　求模运算符 104
        7.2　while循环简介 105
        7.2.1　使用while循环 105
        7.2.2　让用户选择何时退出 106
        7.2.3　使用标志 107
        7.2.4　使用break退出循环 108
        7.2.5　在循环中使用continue 109
        7.2.6　避免无限循环 110
        7.3　使用while循环处理列表和字典 111
        7.3.1　在列表之间移动元素 111
        7.3.2　删除为特定值的所有列表
        元素 112
        7.3.3　使用用户输入填充字典 113
        7.4　小结 114
        第8章　函数 115
        8.1　定义函数 115
        8.1.1　向函数传递信息 116
        8.1.2　实参和形参 116
        8.2　传递实参 117
        8.2.1　位置实参 117
        8.2.2　关键字实参 119
        8.2.3　默认值 119
        8.2.4　等效的函数调用 120
        8.2.5　避免实参错误 121
        8.3　返回值 122
        8.3.1　返回简单的值 122
        8.3.2　让实参变成可选的 123
        8.3.3　返回字典 124
        8.3.4　结合使用函数和while循环 125
        8.4　传递列表 127
        8.4.1　在函数中修改列表 128
        8.4.2　禁止函数修改列表 130
        8.5　传递任意数量的实参 131
        8.5.1　结合使用位置实参和任意数量的实参 132
        8.5.2　使用任意数量的关键字实参 133
        8.6　将函数存储在模块中 134
        8.6.1　导入整个模块 134
        8.6.2　导入特定的函数 135
        8.6.3　使用as给函数指定别名 136
        8.6.4　使用as给模块指定别名 136
        8.6.5　导入模块中的所有函数 137
        8.7　函数编写指南 137
        8.8　小结 139
        第9章　类 140
        9.1　创建和使用类 140
        9.1.1　创建Dog类 141
        9.1.2　根据类创建实例 142
        9.2　使用类和实例 144
        9.2.1　Car类 144
        9.2.2　给属性指定默认值 145
        9.2.3　修改属性的值 146
        9.3　继承 149
        9.3.1　子类的__init__()方法 149
        9.3.2　给子类定义属性和方法 151
        9.3.3　重写父类中的方法 152
        9.3.4　将实例用作属性 152
        9.3.5　模拟实物 154
        9.4　导入类 155
        9.4.1　导入单个类 155
        9.4.2　在一个模块中存储多个类 157
        9.4.3　从一个模块中导入多个类 158
        9.4.4　导入整个模块 158
        9.4.5　导入模块中的所有类 159
        9.4.6　在一个模块中导入另一个
        模块 159
        9.4.7　使用别名 160
        9.4.8　找到合适的工作流程 161
        9.5　Python标准库 161
        9.6　类的编程风格 162
        9.7　小结 163
        第10章　文件和异常 164
        10.1　读取文件 164
        10.1.1　读取文件的全部内容 164
        10.1.2　相对文件路径和绝对文件
        路径 166
        10.1.3　访问文件中的各行 167
        10.1.4　使用文件的内容 168
        10.1.5　包含100万位的大型文件 169
        10.1.6　圆周率值中包含你的
        生日吗 169
        10.2　写入文件 170
        10.2.1　写入一行 171
        10.2.2　写入多行 171
        10.3　异常 172
        10.3.1　处理ZeroDivisionError
        异常 172
        10.3.2　使用try-except代码块 173
        10.3.3　使用异常避免崩溃 173
        10.3.4　else代码块 174
        10.3.5　处理FileNotFoundError
        异常 175
        10.3.6　分析文本 177
        10.3.7　使用多个文件 177
        10.3.8　静默失败 179
        10.3.9　决定报告哪些错误 179
        10.4　存储数据 181
        10.4.1　使用json.dumps()和json.loads() 181
        10.4.2　保存和读取用户生成的
        数据 182
        10.4.3　重构 184
        10.5　小结 186
        第11章　测试代码 187
        11.1　使用pip安装pytest 187
        11.1.1　更新pip 188
        11.1.2　安装pytest 188
        11.2　测试函数 189
        11.2.1　单元测试和测试用例 190
        11.2.2　可通过的测试 190
        11.2.3　运行测试 191
        11.2.4　未通过的测试 191
        11.2.5　在测试未通过时怎么办 192
        11.2.6　添加新测试 193
        11.3　测试类 195
        11.3.1　各种断言 195
        11.3.2　一个要测试的类 195
        11.3.3　测试AnonymousSurvey类 197
        11.3.4　使用夹具 198
        11.4　小结 200
        第二部分　项　　目
        项目1　外星人入侵 202
        第12章　武装飞船 203
        12.1　规划项目 203
        12.2　安装Pygame 204
        12.3　开始游戏项目 204
        12.3.1　创建Pygame窗口及响应用户输入 204
        12.3.2　控制帧率 206
        12.3.3　设置背景色 207
        12.3.4　创建Settings类 207
        12.4　添加飞船图像 208
        12.4.1　创建Ship类 209
        12.4.2　在屏幕上绘制飞船 211
        12.5　重构：_check_events()方法和_update_screen()方法 212
        12.5.1　_check_events()方法 212
        12.5.2　_update_screen()方法 213
        12.6　驾驶飞船 214
        12.6.1　响应按键 214
        12.6.2　允许持续移动 214
        12.6.3　左右移动 216
        12.6.4　调整飞船的速度 217
        12.6.5　限制飞船的活动范围 218
        12.6.6　重构_check_events() 219
        12.6.7　按Q键退出 220
        12.6.8　在全屏模式下运行游戏 220
        12.7　简单回顾 221
        12.7.1　alien_invasion.py 221
        12.7.2　settings.py 221
        12.7.3　ship.py 221
        12.8　射击 222
        12.8.1　添加子弹设置 222
        12.8.2　创建Bullet类 222
        12.8.3　将子弹存储到编组中 223
        12.8.4　开火 224
        12.8.5　删除已消失的子弹 226
        12.8.6　限制子弹数量 226
        12.8.7　创建_update_bullets()
        方法 227
        12.9　小结 228
        第13章　外星人 229
        13.1　项目回顾 229
        13.2　创建第一个外星人 230
        13.2.1　创建Alien类 230
        13.2.2　创建Alien实例 231
        13.3　创建外星舰队 232
        13.3.1　创建一行外星人 232
        13.3.2　重构_create_fleet() 234
        13.3.3　添加多行外星人 235
        13.4　让外星舰队移动 237
        13.4.1　向右移动外星舰队 237
        13.4.2　创建表示外星舰队移动方向的设置 238
        13.4.3　检查外星人是否到达了屏幕边缘 239
        13.4.4　向下移动外星舰队并改变移动方向 239
        13.5　击落外星人 240
        13.5.1　检测子弹和外星人的碰撞 240
        13.5.2　为测试创建大子弹 242
        13.5.3　生成新的外星舰队 242
        13.5.4　加快子弹的速度 243
        13.5.5　重构_update_bullets() 243
        13.6　结束游戏 244
        13.6.1　检测外星人和飞船的碰撞 244
        13.6.2　响应外星人和飞船的碰撞 245
        13.6.3　有外星人到达屏幕下边缘 247
        13.6.4　游戏结束 248
        13.7　确定应运行游戏的哪些部分 249
        13.8　小结 249
        第14章　记分 250
        14.1　添加Play按钮 250
        14.1.1　创建Button类 250
        14.1.2　在屏幕上绘制按钮 252
        14.1.3　开始游戏 253
        14.1.4　重置游戏 254
        14.1.5　将Play按钮切换到非活动
        状态 254
        14.1.6　隐藏光标 255
        14.2　提高难度 256
        14.2.1　修改速度设置 256
        14.2.2　重置速度 258
        14.3　记分 258
        14.3.1　显示得分 259
        14.3.2　创建记分牌 260
        14.3.3　在外星人被击落时更新
        得分 261
        14.3.4　重置得分 262
        14.3.5　将每个被击落的外星人都
        计入得分 262
        14.3.6　提高分数 263
        14.3.7　对得分进行舍入 264
        14.3.8　最高分 265
        14.3.9　显示等级 267
        14.3.10　显示余下的飞船数 269
        14.4　小结 272
        项目2　数据可视化 273
        第15章　生成数据 274
        15.1　安装Matplotlib 274
        15.2　绘制简单的折线图 275
        15.2.1　修改标签文字和线条粗细 276
        15.2.2　校正绘图 277
        15.2.3　使用内置样式 278
        15.2.4　使用scatter()绘制散点图
        并设置样式 279
        15.2.5　使用scatter()绘制一系
        列点 280
        15.2.6　自动计算数据 281
        15.2.7　定制刻度标记 282
        15.2.8　定制颜色 282
        15.2.9　使用颜色映射 283
        15.2.10　自动保存绘图 284
        15.3　随机游走 284
        15.3.1　创建RandomWalk类 284
        15.3.2　选择方向 285
        15.3.3　绘制随机游走图 286
        15.3.4　模拟多次随机游走 287
        15.3.5　设置随机游走图的样式 287
        15.4　使用Plotly模拟掷骰子 292
        15.4.1　安装Plotly 292
        15.4.2　创建Die类 292
        15.4.3　掷骰子 293
        15.4.4　分析结果 293
        15.4.5　绘制直方图 294
        15.4.6　定制绘图 295
        15.4.7　同时掷两个骰子 296
        15.4.8　进一步定制 298
        15.4.9　同时掷两个面数不同的
        骰子 298
        15.4.10　保存绘图 299
        15.5　小结 300
        第16章　下载数据 301
        16.1　CSV文件格式 301
        16.1.1　解析CSV文件头 302
        16.1.2　打印文件头及其位置 302
        16.1.3　提取并读取数据 303
        16.1.4　绘制温度图 304
        16.1.5　datetime模块 305
        16.1.6　在图中添加日期 306
        16.1.7　涵盖更长的时间 307
        16.1.8　再绘制一个数据系列 308
        16.1.9　给图中区域着色 309
        16.1.10　错误检查 310
        16.2　制作全球地震散点图：GeoJSON
        格式 313
        16.2.1　地震数据 313
        16.2.2　查看GeoJSON数据 313
        16.2.3　创建地震列表 316
        16.2.4　提取震级 316
        16.2.5　提取位置数据 317
        16.2.6　绘制地震散点图 318
        16.2.7　指定数据的另一种方式 319
        16.2.8　定制标记的尺寸 320
        16.2.9　定制标记的颜色 321
        16.2.10　其他渐变 323
        16.2.11　添加悬停文本 323
        16.3　小结 325
        第17章　使用API 326
        17.1　使用API 326
        17.1.1　Git和GitHub 326
        17.1.2　使用API调用请求数据 327
        17.1.3　安装Requests 327
        17.1.4　处理API响应 328
        17.1.5　处理响应字典 329
        17.1.6　概述最受欢迎的仓库 331
        17.1.7　监控API的速率限制 332
        17.2　使用Plotly可视化仓库 332
        17.2.1　设置图形的样式 334
        17.2.2　添加定制工具提示 335
        17.2.3　添加可单击的链接 336
        17.2.4　定制标记颜色 337
        17.2.5　深入了解Plotly和GitHub
        API 338
        17.3　Hacker News API 338
        17.4　小结 341
        项目3　Web应用程序 342
        第18章　Django入门 343
        18.1　建立项目 343
        18.1.1　制定规范 343
        18.1.2　建立虚拟环境 344
        18.1.3　激活虚拟环境 344
        18.1.4　安装Django 345
        18.1.5　在Django中创建项目 345
        18.1.6　创建数据库 346
        18.1.7　查看项目 346
        18.2　创建应用程序 348
        18.2.1　定义模型 349
        18.2.2　激活模型 350
        18.2.3　Django管理网站 351
        18.2.4　定义模型Entry 353
        18.2.5　迁移模型Entry 354
        18.2.6　向管理网站注册Entry 354
        18.2.7　Django shell 355
        18.3　创建网页：学习笔记主页 357
        18.3.1　映射URL 357
        18.3.2　编写视图 359
        18.3.3　编写模板 360
        18.4　创建其他网页 361
        18.4.1　模板继承 361
        18.4.2　显示所有主题的页面 363
        18.4.3　显示特定主题的页面 366
        18.5　小结 369
        第19章　用户账户 370
        19.1　让用户能够输入数据 370
        19.1.1　添加新主题 370
        19.1.2　添加新条目 374
        19.1.3　编辑条目 378
        19.2　创建用户账户 381
        19.2.1　应用程序accounts 381
        19.2.2　将应用程序accounts添加
        到settings.py中 381
        19.2.3　包含应用程序accounts的URL 382
        19.2.4　登录页面 382
        19.2.5　注销 385
        19.2.6　注册页面 386
        19.3　让用户拥有自己的数据 389
        19.3.1　使用@login_required限制
        访问 389
        19.3.2　将数据关联到用户 391
        19.3.3　只允许用户访问自己的
        主题 393
        19.3.4　保护用户的主题 394
        19.3.5　保护页面edit_entry 394
        19.3.6　将新主题关联到当前用户 395
        19.4　小结 396
        第20章　设置应用程序的样式并部署 397
        20.1　设置项目“学习笔记”的样式 397
        20.1.1　应用程序django-bootstrap5 397
        20.1.2　使用Bootstrap设置项目
        “学习笔记”的样式 398
        20.1.3　修改base.html 399
        20.1.4　使用jumbotron设置主页的样式 404
        20.1.5　设置登录页面的样式 405
        20.1.6　设置页面topics的样式 406
        20.1.7　设置页面topic中条目的
        样式 407
        20.2　部署“学习笔记” 409
        20.2.1　注册Platform.sh账户 409
        20.2.2　安装Platform.sh CLI 409
        20.2.3　安装platformshconfig 410
        20.2.4　创建文件requirements.txt 410
        20.2.5　其他部署需求 411
        20.2.6　添加配置文件 411
        20.2.7　为部署到Platform.sh而
        修改settings.py 414
        20.2.8　使用Git跟踪项目文件 415
        20.2.9　在Platform.sh上创建项目 417
        20.2.10　推送到Platform.sh 418
        20.2.11　查看线上项目 419
        20.2.12　改进Platform.sh部署 420
        20.2.13　创建定制错误页面 422
        20.2.14　继续开发 423
        20.2.15　将项目从Platform.sh上
        删除 424
        20.3　小结 425
        附录A　安装及故障排除 426
        附录B　文本编辑器和IDE 430
        附录C　寻求帮助 436
        附录D　使用Git进行版本控制 440
        附录E　部署故障排除 449
     · · · · · ·     (收起)"
35006892,程序员修炼之道（第2版）,9.1,(725人评价),[美] David Thomas、[美] Andrew Hunt / 云风 / 电子工业出版社 / 2020-4-1 / 89.00元,本书之所以在全球范围内广泛传播，被一代代开发者奉为圭臬，盖因它可以创造出真正的价值：或编写出更好的软件，或探究出编程的本质，而所有收获均不依赖于特定语言、框...,https://book.douban.com/subject/35006892/,https://img9.doubanio.com/view/subject/s/public/s33836286.jpg,89.00元,9787121384356,本书之所以在全球范围内广泛传播，被一代代开发者奉为圭臬，盖因它可以创造出真正的价值：或编写出更好的软件，或探究出编程的本质，而所有收获均不依赖于特定语言、框架和方法。时隔20年的新版，经过全面的重新选材、组织和编写，覆盖哲学、方法、工具、设计、解耦、并发、重构、需求、团队等务实话题的最佳实践及重大陷阱，以及易于改造、复用的架构技术。本书极具洞察力与趣味性，适合从初学者到架构师的各阶层读者潜心研读或增广见闻。,"云风
译者","序
        新版前言
        第一版前言
        提示1 关注你的技艺
        提示2 思考！思考你的工作
        第1章 务实的哲学
        1 人生是你的
        提示3 你有权选择
        2 我的源码被猫吃了
        提示4 提供选择，别找借口
        3 软件的熵
        提示5 不要放任破窗
        4 石头做的汤和煮熟的青蛙
        提示6 做推动变革的催化剂
        提示7 牢记全景
        5 够好即可的软件
        提示8 将质量要求视为需求问题
        6 知识组合
        提示9 对知识组合做定期投资
        提示10 批判性地分析你读到和听到的东西
        7 交流！
        提示11 英语就是另一门编程语言
        提示12 说什么和怎么说同样重要
        提示13 把文档嵌进去，而不要栓在表面
        第2章 务实的方法
        8 优秀设计的精髓
        提示14 优秀的设计比糟糕的设计更容易变更
        9 DRY ——邪恶的重复
        提示15 DRY——不要重复自己
        提示16 让复用变得更容易
        10 正交性
        提示17 消除不相关事物之间的影响
        11 可逆性
        提示18 不设最终决定
        提示19 放弃追逐时尚
        12 曳光弹
        提示20 使用曳光弹找到目标
        13 原型与便签
        提示21 用原型学习
        14 领域语言
        提示22 靠近问题域编程
        15 估算
        提示23 通过估算来避免意外
        提示24 根据代码不断迭代进度表
        第3章 基础工具
        16 纯文本的威力
        提示25 将知识用纯文本保存
        17 Shell游戏
        提示26 发挥 Shell 命令的威力
        18 加强编辑能力
        提示27 游刃有余地使用编辑器
        19 版本控制
        提示28 永远使用版本控制
        20 调试
        提示29 去解决问题，而不是责备
        提示30 不要恐慌
        提示31 修代码前先让代码在测试中失败
        提示32 读一下那些该死的出错信息
        提示33 “select”没出问题
        提示34 不要假设，要证明
        21 文本处理
        提示35 学习一门文本处理语言
        22 工程日记
        第4章 务实的偏执
        提示36 你无法写出完美的软件
        23 契约式设计
        提示37 通过契约进行设计
        24 死掉的程序不会说谎
        提示38 尽早崩溃
        25 断言式编程
        提示39 使用断言去预防不可能的事情
        26 如何保持资源的平衡
        提示40 有始有终
        提示41 在局部行动
        27 不要冲出前灯范围
        提示42 小步前进——由始至终
        提示43 避免占卜
        第5章 宁弯不折
        28 解耦
        提示44 解耦代码让改变更容易
        提示45 只管命令不要询问
        提示46 不要链式调用方法
        提示47 避免全局数据
        提示48 如果全局唯一非常重要，那么将它包装到API 中
        29 在现实世界中抛球杂耍
        30 变换式编程
        提示49 编程讲的是代码，而程序谈的是数据
        提示50 不要囤积状态，传递下去
        31 继承税
        提示51 不要付继承税
        提示52 尽量用接口来表达多态
        提示53 用委托提供服务：“有一个”胜过“是一个”
        提示54 利用 mixin 共享功能
        32 配置
        提示55 使用外部配置参数化应用程序
        第6章 并发
        33 打破时域耦合
        提示56 通过分析工作流来提高并发性
        34 共享状态是不正确的状态
        提示57 共享状态是不正确的状态
        提示58 随机故障通常是并发问题
        35 角色与进程
        提示59 用角色实现并发性时不必共享状态
        36 黑板
        提示60 使用黑板来协调工作流
        第7章 当你编码时
        37 听从蜥蜴脑
        提示61 倾听你内心的蜥蜴
        38 巧合式编程
        提示62 不要依赖巧合编程
        39 算法速度
        提示63 评估算法的级别
        提示64 对估算做测试
        40 重构
        提示65 尽早重构，经常重构
        41 为编码测试
        提示66 测试与找 Bug 无关
        提示67 测试是代码的第一个用户
        提示68 既非自上而下，也不自下而上，基于端对端构建
        提示69 为测试做设计
        提示70 要对软件做测试，否则只能留给用户去做
        42 基于特性测试
        提示71 使用基于特性的测试来校验假设
        43 出门在外注意安全
        提示72 保持代码简洁，让攻击面最小
        提示73 尽早打上安全补丁
        44 事物命名
        提示74 好好取名；需要时更名
        第8章 项目启动之前
        45 需求之坑
        提示75 无人确切知道自己想要什么
        提示76 程序员帮助人们理解他们想要什么
        提示77 需求是从反馈循环中学到的
        提示78 和用户一起工作以便从用户角度思考
        提示79 策略即元数据
        提示80 使用项目术语表
        46 处理无法解决的难题
        提示81 不要跳出框框思考——找到框框
        47 携手共建
        提示82 不要一个人埋头钻进代码中
        48 敏捷的本质
        提示83 敏捷不是一个名词；敏捷有关你如何做事
        第9章 务实的项目
        49 务实的团队
        提示84 维持小而稳定的团队
        提示85 排上日程以待其成
        提示86 组织全功能的团队
        50 椰子派不上用场
        提示87 做能起作用的事，别赶时髦
        提示88 在用户需要时交付
        51 务实的入门套件
        提示89 使用版本控制来驱动构建、测试和发布
        提示90 尽早测试，经常测试，自动测试
        提示91 直到所有的测试都已运行，编码才算完成
        提示92 使用破坏者检测你的测试
        提示93 测试状态覆盖率，而非代码覆盖率
        提示94 每个 Bug 只找一次
        提示95 不要使用手动程序
        52 取悦用户
        提示96 取悦用户，而不要只是交付代码
        53 傲慢与偏见
        提示97 在作品上签名
        跋
        提示98 先勿伤害
        提示99 不要助纣为虐
        参考文献
        练习的参考答案
        译者跋
     · · · · · ·     (收起)"
36547630,Rust程序设计（第2版）,9.3,(33人评价),[美]吉姆·布兰迪（Jim Blandy）、[美]贾森 • 奥伦多夫（Jason Orendorff）、[美]莉奥诺拉 • F. S. 廷德尔（Leonora F. S. Tindall） / 汪志成（@雪狼） / 人民邮电出版社 / 2023-9-5 / 179.8元,"本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。
书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的...",https://book.douban.com/subject/36547630/,https://img3.doubanio.com/view/subject/s/public/s34641512.jpg,179.8元,9787115621818,"本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。 书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的高性能，并大大简化了并发程序的编写。第2版对上一版内容进行了重组和完善，新增了对“异步编程”的介绍。借助书中的大量案例，你也能用Rust编写出兼顾安全性与高性能的程序。本书内容包括基本数据类型、所有权、引用、表达式、错误处理、crate与模块、结构、枚举与模式等基础知识，以及特型与泛型、闭包、迭代器、集合、字符串与文本、输入与输出、并发、异步编程、宏等进阶知识。 编辑推荐 1.【内容全面】Rust一本就通，涉及Rust所有关键特性 2.【代码开源】基于Rust 2021大版本，开源示例代码 3.【实战性强】讲解深入浅出，含大量案例，实践性强 4.【作译者资深】Mozilla创始团员编写，雪狼翻译 ...(展开全部)





本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。 书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的高性能，并大大简化了并发程序的编写。第2版对上一版内容进行了重组和完善，新增了对“异步编程”的介绍。借助书中的大量案例，你也能用Rust编写出兼顾安全性与高性能的程序。本书内容包括基本数据类型、所有权、引用、表达式、错误处理、crate与模块、结构、枚举与模式等基础知识，以及特型与泛型、闭包、迭代器、集合、字符串与文本、输入与输出、并发、异步编程、宏等进阶知识。 编辑推荐 1.【内容全面】Rust一本就通，涉及Rust所有关键特性 2.【代码开源】基于Rust 2021大版本，开源示例代码 3.【实战性强】讲解深入浅出，含大量案例，实践性强 4.【作译者资深】Mozilla创始团员编写，雪狼翻译 5.【专家推荐】陈天、唐刚、王旭、张汉东、张炎泼 6.【超强品控】30位一线Rust开发者与爱好者精心审读",吉姆·布兰迪（Jim Blandy），Mozilla Firefox工程师，Subversion版本控制系统最初设计者之一。拥有40多年编程经验，其中包括30多年自由软件开发经验，曾在GNU Emacs、GNU Debugger等项目上工作。 贾森·奥伦多夫（Jason Orendorff），GitHub工程师，专注开发尚未公开的Rust项目，曾在Mozilla参与JavaScript引擎SpiderMonkey的开发。兴趣广泛，包括：语法学、烘焙、时间旅行，以及帮助人们理解复杂主题。 莉奥诺拉·F. S. 廷德尔（Leonora F. S. Tindall），软件工程师、类型系统爱好者。她喜欢使用Rust等先进语言在一些关键领域构建健壮且适应性强的系统软件，特别是在医疗保健和数据所有权管理等领域。,"目录
        专家推荐
        译者序
        前言
        中文版审读致谢
        第 1章　系统程序员也能享受美好 1
        1.1　Rust为你负重前行 2
        1.2　高效并行编程 3
        1.3　性能毫不妥协 3
        1.4　协作无边无界 4
        第 2章　Rust导览 5
        2.1　rustup与Cargo 6
        2.2　Rust函数 8
        2.3　编写与运行单元测试 9
        2.4　处理命令行参数 10
        2.5　搭建Web服务器 13
        2.6　并发 18
        2.6.1　什么是曼德博集 19
        2.6.2　解析并配对命令行参数 22
        2.6.3　从像素到复数的映射 24
        2.6.4　绘制曼德博集 25
        2.6.5　写入图像文件 26
        2.6.6　并发版曼德博程序 27
        2.6.7　运行曼德博绘图器 32
        2.6.8　大“安”无形 33
        2.7　文件系统与命令行工具 33
        2.7.1　命令行界面 34
        2.7.2　读写文件 36
        2.7.3　查找并替换 37
        第3章　基本数据类型 39
        3.1　固定宽度的数值类型 41
        3.1.1　整型 42
        3.1.2　检查算法、回绕算法、饱和算法和溢出算法 45
        3.1.3　浮点类型 46
        3.2　布尔类型 48
        3.3　字符 49
        3.4　元组 50
        3.5　指针类型 51
        3.5.1　引用 52
        3.5.2　Box 52
        3.5.3　裸指针 53
        3.6　数组、向量和切片 53
        3.6.1　数组 53
        3.6.2　向量 54
        3.6.3　切片 57
        3.7　字符串类型 58
        3.7.1　字符串字面量 58
        3.7.2　字节串 59
        3.7.3　内存中的字符串 60
        3.7.4　String 61
        3.7.5　使用字符串 62
        3.7.6　其他类似字符串的类型 62
        3.8　类型别名 63
        3.9　前路展望 63
        第4章　所有权与移动 64
        4.1　所有权 65
        4.2　移动 70
        4.2.1　更多移动类操作 74
        4.2.2　移动与控制流 75
        4.2.3　移动与索引内容 75
        4.3　Copy类型：关于移动的例外情况 77
        4.4　Rc与Arc：共享所有权 80
        第5章　引用 83
        5.1　对值的引用 84
        5.2　使用引用 86
        5.2.1　Rust引用与C++引用 87
        5.2.2　对引用变量赋值 88
        5.2.3　对引用进行引用 88
        5.2.4　比较引用 89
        5.2.5　引用永不为空 89
        5.2.6　借用任意表达式结果值的引用 89
        5.2.7　对切片和特型对象的引用 90
        5.3　引用安全 90
        5.3.1　借用局部变量 91
        5.3.2　将引用作为函数参数 93
        5.3.3　把引用传给函数 95
        5.3.4　返回引用 95
        5.3.5　包含引用的结构体 96
        5.3.6　不同的生命周期参数 98
        5.3.7　省略生命周期参数 100
        5.4　共享与可变 101
        5.5　应对复杂对象关系 107
        第6章　表达式 109
        6.1　表达式语言 109
        6.2　优先级与结合性 110
        6.3　块与分号 112
        6.4　声明 113
        6.5　if与match 115
        6.5.1　if let 117
        6.5.2　循环 117
        6.6　循环中的控制流 119
        6.7　return表达式 120
        6.8　为什么Rust中会有loop 121
        6.9　函数与方法调用 122
        6.10　字段与元素 123
        6.11　引用运算符 124
        6.12　算术运算符、按位运算符、比较运算符和逻辑运算符 125
        6.13　赋值 125
        6.14　类型转换 126
        6.15　闭包 127
        6.16　前路展望 127
        第7章　错误处理 128
        7.1　panic 128
        7.1.1　展开调用栈 129
        7.1.2　中止 130
        7.2　Result 130
        7.2.1　捕获错误 131
        7.2.2　Result类型别名 132
        7.2.3　打印错误 132
        7.2.4　传播错误 134
        7.2.5　处理多种Error类型 135
        7.2.6　处理“不可能发生”的错误 136
        7.2.7　忽略错误 138
        7.2.8　处理main()中的错误 138
        7.2.9　声明自定义错误类型 139
        7.2.10　为什么是Result 140
        第8章　crate与模块 141
        8.1　crate 141
        8.1.1　版本 144
        8.1.2　创建配置文件 145
        8.2　模块 145
        8.2.1　嵌套模块 146
        8.2.2　单独文件中的模块 147
        8.2.3　路径与导入 149
        8.2.4　标准库预导入 152
        8.2.5　公开use声明 152
        8.2.6　公开结构体字段 152
        8.2.7　静态变量与常量 153
        8.3　将程序变成库 153
        8.4　src/bin目录 155
        8.5　属性 156
        8.6　测试与文档 158
        8.6.1　集成测试 161
        8.6.2　文档 161
        8.6.3　文档测试 163
        8.7　指定依赖项 166
        8.7.1　版本 166
        8.7.2　Cargo.lock 167
        8.8　将crate发布到crates.io 168
        8.9　工作空间 170
        8.10　更多好资源 170
        第9章　结构体 172
        9.1　具名字段型结构体 172
        9.2　元组型结构体 175
        9.3　单元型结构体 175
        9.4　结构体布局 176
        9.5　用impl定义方法 177
        9.5.1　以Box、Rc或Arc形式传入self 179
        9.5.2　类型关联函数 179
        9.6　关联常量 180
        9.7　泛型结构体 181
        9.8　带生命周期参数的泛型结构体 183
        9.9　带常量参数的泛型结构体 183
        9.10　让结构体类型派生自某些公共特型 185
        9.11　内部可变性 186
        第 10章　枚举与模式 190
        10.1　枚举 191
        10.1.1　带数据的枚举 193
        10.1.2　内存中的枚举 194
        10.1.3　用枚举表示富数据结构 194
        10.1.4　泛型枚举 196
        10.2　模式 198
        10.2.1　模式中的字面量、变量和通配符 201
        10.2.2　元组型模式与结构体型模式 202
        10.2.3　数组型模式与切片型模式 203
        10.2.4　引用型模式 204
        10.2.5　匹配守卫 206
        10.2.6　匹配多种可能性 206
        10.2.7　使用@模式绑定 207
        10.2.8　模式能用在哪里 207
        10.2.9　填充二叉树 209
        10.3　大局观 210
        第 11章　特型与泛型 211
        11.1　使用特型 213
        11.1.1　特型对象 214
        11.1.2　泛型函数与类型参数 215
        11.1.3　使用哪一个 219
        11.2　定义与实现特型 220
        11.2.1　默认方法 221
        11.2.2　特型与其他人的类型 222
        11.2.3　特型中的Self 224
        11.2.4　子特型 225
        11.2.5　类型关联函数 226
        11.3　完全限定的方法调用 227
        11.4　定义类型之间关系的特型 228
        11.4.1　关联类型（或迭代器的工作原理） 229
        11.4.2　泛型特型（或运算符重载的工作原理） 231
        11.4.3　impl Trait 232
        11.4.4　关联常量 234
        11.5　逆向工程求限界 235
        11.6　以特型为基础 238
        第 12章　运算符重载 239
        12.1　算术运算符与按位运算符 240
        12.1.1　一元运算符 242
        12.1.2　二元运算符 243
        12.1.3　复合赋值运算符 244
        12.2　相等性比较 245
        12.3　有序比较 247
        12.4　Index与IndexMut 250
        12.5　其他运算符 252
        第 13章　实用工具特型 253
        13.1　Drop 254
        13.2　Sized 256
        13.3　Clone 259
        13.4　Copy 260
        13.5　Deref与DerefMut 260
        13.6　Default 263
        13.7　AsRef与AsMut 264
        13.8　Borrow与BorrowMut 266
        13.9　From与Into 267
        13.10　TryFrom与TryInto 270
        13.11　ToOwned 271
        13.12　Borrow与ToOwned的实际运用：谦卑的Cow 271
        第 14章　闭包 273
        14.1　捕获变量 274
        14.1.1　借用值的闭包 275
        14.1.2　“窃取”值的闭包 275
        14.2　函数与闭包的类型 277
        14.3　闭包性能 279
        14.4　闭包与安全 280
        14.4.1　“杀死”闭包 280
        14.4.2　FnOnce 281
        14.4.3　FnMut 282
        14.4.4　对闭包的Copy与Clone 284
        14.5　回调 285
        14.6　高效地使用闭包 288
        第 15章　迭代器 290
        15.1　Iterator特型与IntoIterator特型 291
        15.2　创建迭代器 292
        15.2.1　iter方法与iter_mut方法 293
        15.2.2　IntoIterator的实现 293
        15.2.3　from_fn与successors 295
        15.2.4　drain方法 296
        15.2.5　其他迭代器源 297
        15.3　迭代器适配器 298
        15.3.1　map与filter 298
        15.3.2　filter_map与flat_map 300
        15.3.3　flatten 302
        15.3.4　take与take_while 304
        15.3.5　skip与skip_while 305
        15.3.6　peekable 305
        15.3.7　fuse 306
        15.3.8　可逆迭代器与rev 307
        15.3.9　inspect 308
        15.3.10　chain 309
        15.3.11　enumerate 309
        15.3.12　zip 310
        15.3.13　by_ref 310
        15.3.14　cloned与copied 311
        15.3.15　cycle 312
        15.4　消耗迭代器 313
        15.4.1　简单累加：count、sum和product 313
        15.4.2　min与max 313
        15.4.3　max_by与min_by 314
        15.4.4　max_by_key与min_by_key 314
        15.4.5　对条目序列进行比较 315
        15.4.6　any与all 315
        15.4.7　position、rposition和ExactSizeIterator 316
        15.4.8　fold与rfold 316
        15.4.9　try_fold与try_rfold 317
        15.4.10　nth与nth_back 318
        15.4.11　last 319
        15.4.12　find、rfind和find_map 319
        15.4.13　构建集合：collect与FromIterator 320
        15.4.14　Extend特型 322
        15.4.15　partition 322
        15.4.16　for_each与try_for_each 323
        15.5　实现自己的迭代器 324
        第 16章　集合 328
        16.1　概述 329
        16.2　Vec&lt;T> 330
        16.2.1　访问元素 331
        16.2.2　迭代 332
        16.2.3　扩大向量与收缩向量 332
        16.2.4　联结 336
        16.2.5　拆分 336
        16.2.6　交换 339
        16.2.7　填充 339
        16.2.8　排序与搜索 339
        16.2.9　比较切片 341
        16.2.10　随机元素 341
        16.2.11　Rust中不存在失效型错误 342
        16.3　VecDeque&lt;T> 343
        16.4　BinaryHeap&lt;T> 344
        16.5　HashMap&lt;K, V>与BTreeMap&lt;K, V> 346
        16.5.1　条目 349
        16.5.2　对Map进行迭代 351
        16.6　HashSet&lt;T>与BTreeSet&lt;T> 351
        16.6.1　对Set进行迭代 352
        16.6.2　当相等的值不完全相同时 353
        16.6.3　针对整个Set的运算 353
        16.7　哈希 354
        16.8　使用自定义哈希算法 355
        16.9　在标准集合之外 357
        第 17章　字符串与文本 358
        17.1　一些Unicode背景知识 358
        17.1.1　ASCII、Latin-1和Unicode 359
        17.1.2　UTF-8编码 359
        17.1.3　文本方向性 361
        17.2　字符（char） 361
        17.2.1　字符分类 361
        17.2.2　处理数字 362
        17.2.3　字符大小写转换 363
        17.2.4　与整数之间的转换 364
        17.3　String与str 364
        17.3.1　创建字符串值 365
        17.3.2　简单探查 366
        17.3.3　追加文本与插入文本 366
        17.3.4　移除文本与替换文本 368
        17.3.5　搜索与迭代的约定 368
        17.3.6　搜索文本的模式 369
        17.3.7　搜索与替换 370
        17.3.8　遍历文本 371
        17.3.9　修剪 373
        17.3.10　字符串的大小写转换 374
        17.3.11　从字符串中解析出其他类型 374
        17.3.12　将其他类型转换为字符串 374
        17.3.13　借用其他类似文本的类型 375
        17.3.14　以UTF-8格式访问文本 376
        17.3.15　从UTF-8数据生成文本 376
        17.3.16　推迟分配 377
        17.3.17　把字符串当作泛型集合 379
        17.4　格式化各种值 379
        17.4.1　格式化文本值 380
        17.4.2　格式化数值 381
        17.4.3　格式化其他类型 383
        17.4.4　格式化值以进行调试 383
        17.4.5　格式化指针以进行调试 384
        17.4.6　按索引或名称引用参数 385
        17.4.7　动态宽度与动态精度 386
        17.4.8　格式化自己的类型 386
        17.4.9　在自己的代码中使用格式化语言 388
        17.5　正则表达式 389
        17.5.1　Regex的基本用法 389
        17.5.2　惰性构建正则表达式值 390
        17.6　规范化 391
        17.6.1　规范化形式 392
        17.6.2　unicode-normalization crate 393
        第 18章　输入与输出 395
        18.1　读取器与写入器 396
        18.1.1　读取器 397
        18.1.2　缓冲读取器 398
        18.1.3　读取行 399
        18.1.4　收集行 401
        18.1.5　写入器 402
        18.1.6　文件 403
        18.1.7　寻址 404
        18.1.8　其他读取器与写入器类型 404
        18.1.9　二进制数据、压缩和序列化 406
        18.2　文件与目录 407
        18.2.1　OsStr与Path 408
        18.2.2　Path与PathBuf的方法 409
        18.2.3　访问文件系统的函数 411
        18.2.4　读取目录 412
        18.2.5　特定于平台的特性 413
        18.3　网络 414
        第 19章　并发 417
        19.1　分叉与合并并行 418
        19.1.1　启动与联结 420
        19.1.2　跨线程错误处理 422
        19.1.3　跨线程共享不可变数据 422
        19.1.4　rayon 424
        19.1.5　重温曼德博集 426
        19.2　通道 427
        19.2.1　发送值 429
        19.2.2　接收值 431
        19.2.3　运行管道 432
        19.2.4　通道的特性与性能 434
        19.2.5　线程安全：Send与Sync 435
        19.2.6　绝大多数迭代器能通过管道传给通道 437
        19.2.7　除管道之外的用法 438
        19.3　共享可变状态 439
        19.3.1　什么是互斥锁 439
        19.3.2　Mutex&lt;T> 440
        19.3.3　mut与互斥锁 442
        19.3.4　为什么互斥锁不是“银弹” 443
        19.3.5　死锁 443
        19.3.6　“中毒”的互斥锁 444
        19.3.7　使用互斥锁的多消费者通道 444
        19.3.8　读/写锁（RwLock&lt;T>） 445
        19.3.9　条件变量（Condvar） 446
        19.3.10　原子化类型 447
        19.3.11　全局变量 448
        19.4　在Rust中编写并发代码的一点儿经验 451
        第 20章　异步编程 452
        20.1　从同步到异步 453
        20.1.1　Future 455
        20.1.2　异步函数与await表达式 456
        20.1.3　从同步代码调用异步函数：block_on 458
        20.1.4　启动异步任务 460
        20.1.5　异步块 464
        20.1.6　从异步块构建异步函数 466
        20.1.7　在线程池中启动异步任务 467
        20.1.8　你的Future实现Send了吗 467
        20.1.9　长时间运行的计算：yield_now与spawn_blocking 470
        20.1.10　对几种异步设计进行比较 471
        20.1.11　一个真正的异步HTTP客户端 471
        20.2　异步客户端与服务器 472
        20.2.1　Error类型与Result类型 474
        20.2.2　协议 474
        20.2.3　获取用户输入：异步流 475
        20.2.4　发送数据包 477
        20.2.5　接收数据包：更多异步流 478
        20.2.6　客户端的main函数 480
        20.2.7　服务器的main函数 481
        20.2.8　处理聊天连接：异步互斥锁 482
        20.2.9　群组表：同步互斥锁 484
        20.2.10　聊天组：tokio的广播通道 485
        20.3　原始Future与执行器：Future什么时候值得再次轮询 488
        20.3.1　调用唤醒器：spawn_blocking 489
        20.3.2　实现block_on 491
        20.4　固定（Pin） 493
        20.4.1　Future生命周期的两个阶段 493
        20.4.2　固定指针 496
        20.4.3　Unpin特型 497
        20.5　什么时候要用异步代码 498
        第 21章　宏 500
        21.1　宏基础 501
        21.1.1　宏展开的基础 502
        21.1.2　意外后果 503
        21.1.3　重复 505
        21.2　内置宏 507
        21.3　调试宏 508
        21.4　构建json!宏 509
        21.4.1　片段类型 510
        21.4.2　宏中的递归 513
        21.4.3　将特型与宏一起使用 514
        21.4.4　作用域界定与卫生宏 516
        21.4.5　导入宏和导出宏 518
        21.5　在匹配过程中避免语法错误 519
        21.6　超越macro_rules! 520
        第 22章　不安全代码 522
        22.1　不安全因素来自哪里 523
        22.2　不安全块 524
        22.3　示例：高效的ASCII字符串类型 525
        22.4　不安全函数 527
        22.5　不安全块还是不安全函数 528
        22.6　未定义行为 529
        22.7　不安全特型 531
        22.8　裸指针 532
        22.8.1　安全地解引用裸指针 534
        22.8.2　示例：RefWithFlag 535
        22.8.3　可空指针 537
        22.8.4　类型大小与对齐方式 537
        22.8.5　指针运算 538
        22.8.6　移动入和移动出内存 539
        22.8.7　示例：GapBuffer 542
        22.8.8　不安全代码中的panic安全性 548
        22.9　用联合体重新解释内存 549
        22.10　匹配联合体 551
        22.11　借用联合体 551
        第 23章　外部函数 552
        23.1　寻找共同的数据表示 552
        23.2　声明外部函数与变量 556
        23.3　使用库中的函数 557
        23.4　libgit2的裸接口 560
        23.5　libgit2的安全接口 566
        23.6　结论 575
        作者介绍 576
        封面介绍 576
     · · · · · ·     (收起)"
36457109,程序员的README,8.6,(95人评价),[美] 克里斯·里科米尼（Chris Riccomini）、[美] 德米特里·里亚博伊（Dmitriy Ryaboy） / 付裕 / 人民邮电出版社 / 2023-7-10 / 79.8,对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填...,https://book.douban.com/subject/36457109/,https://img9.doubanio.com/view/subject/s/public/s34570616.jpg,79.8,9787115599438,"对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新...(展开全部)





对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新入行的工程师在开始工作之前都能阅读的书。","付裕
译者","第1 章 前面的旅程 1
        1.1 你的目的地 1
        1.2 你的旅程地图 2
        1.2.1 新手营 3
        1.2.2 试炼之河 5
        1.2.3 贡献者之角 5
        1.2.4 运维之海 6
        1.2.5 胜任之湾 6
        1.3 前进！ 7
        第2 章 步入自觉阶段 8
        2.1 学习如何学习 9
        2.1.1 前置学习 9
        2.1.2 在实践中学习 9
        2.1.3 运行实例代码 11
        2.1.4 阅读 11
        2.1.5 观看讲座 13
        2.1.6 适度地参加会议和聚会 14
        2.1.7 跟班学习并同有经验的工程师结对 15
        2.1.8 用副业项目实践 16
        2.2 提出问题 17
        2.2.1 动手调查一下 17
        2.2.2 设置一个时间限制 17
        2.2.3 写下全过程 18
        2.2.4 别打扰别人 19
        2.2.5 多用“非打扰式”交流 20
        2.2.6 批量处理你的同步请求 20
        2.3 克服成长的障碍 21
        2.3.1 冒充者综合征 21
        2.3.2 邓宁-克鲁格效应 22
        2.4 行为准则 23
        2.5 升级加油站 23
        第3 章 玩转代码 25
        3.1 软件的熵 26
        3.2 技术债 26
        3.3 变更代码 29
        3.3.1 善于利用现有代码 30
        3.3.2 过手的代码要比之前更干净 32
        3.3.3 做渐变式的修改 33
        3.3.4 对重构要务实 33
        3.3.5 善用IDE 34
        3.3.6 请使用VCS 的最佳实践 34
        3.4 避“坑”指南 35
        3.4.1 保守一些的技术选型 36
        3.4.2 不要特立独行 39
        3.4.3 不要只分叉而不向上游提交修改 40
        3.4.4 克制重构的冲动 40
        3.5 行为准则 42
        3.6 升级加油站 42
        第4 章 编写可维护的代码 44
        4.1 防御式编程 45
        4.1.1 避免空值 45
        4.1.2 保持变量不可变 46
        4.1.3 使用类型提示和静态类型检查器 46
        4.1.4 验证输入 47
        4.1.5 善用异常 49
        4.1.6 异常要有精确含义 50
        4.1.7 早抛晚捕 51
        4.1.8 智能重试 52
        4.1.9 构建幂等系统 53
        4.1.10 及时释放资源 53
        4.2 关于日志的使用 54
        4.2.1 给日志分级 55
        4.2.2 日志的原子性 56
        4.2.3 关注日志性能 57
        4.2.4 不要记录敏感数据 59
        4.3 系统监控 59
        4.3.1 使用标准的监控组件 60
        4.3.2 测量一切 63
        4.4 跟踪器 64
        4.5 配置相关注意事项 64
        4.5.1 配置无须新花样 65
        4.5.2 记录并校验所有的配置 66
        4.5.3 提供默认值 67
        4.5.4 给配置分组 67
        4.5.5 将配置视为代码 67
        4.5.6 保持配置文件清爽 68
        4.5.7 不要编辑已经部署的配置 68
        4.6 工具集 68
        4.7 行为准则 70
        4.8 升级加油站 71
        第5 章 依赖管理 72
        5.1 依赖管理基础知识 73
        5.1.1 语义化版本 74
        5.1.2 传递依赖 75
        5.2 相依性地狱 76
        5.3 避免相依性地狱 80
        5.3.1 隔离依赖项 80
        5.3.2 按需添加依赖项 81
        5.3.3 指定依赖项的版本 82
        5.3.4 依赖范围最小化 84
        5.3.5 保护自己免受循环依赖的影响 84
        5.4 行为准则 85
        5.5 升级加油站 85
        第6 章 测试 87
        6.1 测试的多种用途 87
        6.2 测试类型 88
        6.3 测试工具 91
        6.3.1 模拟库 91
        6.3.2 测试框架 92
        6.3.3 代码质量工具 93
        6.4 自己动手编写测试 95
        6.4.1 编写干净的测试 95
        6.4.2 避免过度测试 96
        6.5 测试中的确定性 98
        6.5.1 种子随机数生成器 99
        6.5.2 不要在单元测试中调用远程系统 99
        6.5.3 采用注入式时间戳 99
        6.5.4 避免使用休眠和超时 102
        6.5.5 记得关闭网络套接字和文件句柄 102
        6.5.6 绑定到0 端口 103
        6.5.7 生成唯一的文件路径和数据库位置 103
        6.5.8 隔离并清理剩余的测试状态 103
        6.5.9 不要依赖测试顺序 104
        6.6 行为准则 105
        6.7 升级加油站 105
        第7 章 代码评审 107
        7.1 为什么需要评审代码? 107
        7.2 当你的代码被评审时 109
        7.2.1 准备工作 109
        7.2.2 用评审草案降低风险 110
        7.2.3 提交评审请勿触发测试 111
        7.2.4 预排大体量的代码修改 111
        7.2.5 不要太在意 112
        7.2.6 保持同理心，但不要容忍粗鲁 113
        7.2.7 保持主动 113
        7.3 评审别人的代码时 114
        7.3.1 分流评审请求 114
        7.3.2 给评审预留时间 114
        7.3.3 理解修改的意图 115
        7.3.4 提供全面的反馈 115
        7.3.5 要承认优点 116
        7.3.6 区分问题、建议和挑剔 116
        7.3.7 不要只做橡皮图章 117
        7.3.8 不要只局限于使用网页版的评审工具 118
        7.3.9 不要忘记评审测试代码 118
        7.3.10 推动决断 118
        7.4 行为准则 119
        7.5 升级加油站 120
        第8 章 软件交付 121
        8.1 软件交付流程 121
        8.2 分支策略 122
        8.3 构建环节 125
        8.3.1 打包需要带版本号 126
        8.3.2 将不同的资源单独打包 127
        8.4 发布环节 129
        8.4.1 请勿只想着发布 129
        8.4.2 将包发布到仓库 130
        8.4.3 保持版本不变性 131
        8.4.4 频繁发布 131
        8.4.5 对发布计划保持透明 132
        8.4.6 撰写变更日志和发行说明 132
        8.5 部署环节 133
        8.5.1 自动部署 133
        8.5.2 部署的原子性 134
        8.5.3 独立地部署应用 134
        8.6 展开环节 136
        8.6.1 系统监控 137
        8.6.2 特性开关 137
        8.6.3 熔断器 138
        8.6.4 并行的服务版本梯队 139
        8.6.5 摸黑启动 141
        8.7 行为准则 143
        8.8 升级加油站 144
        第9 章 On-Call 146
        9.1 On-Call 的工作方式 147
        9.2 On-Call 技能包 148
        9.2.1 随时响应 148
        9.2.2 保持专注 148
        9.2.3 确定工作优先级 149
        9.2.4 清晰的沟通 150
        9.2.5 跟踪你的工作 151
        9.3 事故处理 152
        9.3.1 分流 153
        9.3.2 协同 154
        9.3.3 应急方案 155
        9.3.4 解决方案 157
        9.3.5 后续行动 159
        9.4 提供支持 162
        9.5 不要逞英雄 164
        9.6 行为准则 165
        9.7 升级加油站 165
        第10 章 技术设计流程 167
        10.1 技术设计的V 形结构 168
        10.2 关于设计的思考 169
        10.2.1 定义问题 170
        10.2.2 着手调查 171
        10.2.3 进行实验 172
        10.2.4 给些时间 173
        10.3 撰写设计文档 174
        10.3.1 文档持续变更 174
        10.3.2 了解撰写文档的目的 175
        10.3.3 学会写作 176
        10.3.4 保证文档是最新的 176
        10.4 使用设计文档模板 177
        10.4.1 概要 178
        10.4.2 现状与背景 178
        10.4.3 变更的目的 178
        10.4.4 需求 179
        10.4.5 潜在的解决方案 179
        10.4.6 建议的解决方案 180
        10.4.7 设计与架构 180
        10.4.8 测试计划 181
        10.4.9 发布计划 181
        10.4.10 遗留的问题 181
        10.4.11 附录 181
        10.5 协作设计 182
        10.5.1 理解你的团队的设计评审流程 182
        10.5.2 不要让人惊讶 183
        10.5.3 用设计讨论来进行头脑风暴 183
        10.5.4 为设计出力 184
        10.6 行为准则 185
        10.7 升级加油站 185
        第11 章 构建可演进的架构 187
        11.1 理解复杂性 188
        11.2 可演进的设计 189
        11.2.1 你不是真的需要 189
        11.2.2 最小惊讶原则 191
        11.2.3 封装专业领域知识 193
        11.3 可演进的API 193
        11.3.1 保持API 小巧 194
        11.3.2 公开定义良好的服务端API 194
        11.3.3 保持API 变更的兼容性 195
        11.3.4 API 版本化 198
        11.4 可持续的数据管理 199
        11.4.1 数据库隔离 199
        11.4.2 使用schema 201
        11.4.3 schema 自动化迁移 203
        11.4.4 保持schema 的兼容性 206
        11.5 行为准则 207
        11.6 升级加油站 208
        第12 章 敏捷计划 210
        12.1 敏捷宣言 210
        12.2 敏捷计划的框架 211
        12.3 Scrum 框架 212
        12.3.1 用户故事 213
        12.3.2 任务分解 214
        12.3.3 故事点 214
        12.3.4 消化积压 216
        12.3.5 冲刺计划 216
        12.4 站会 217
        12.5 评审机制 218
        12.6 回顾会 219
        12.7 路线图 220
        12.8 行为准则 221
        12.9 升级加油站 222
        第13 章 与管理者合作 223
        13.1 管理者是做什么的 223
        13.2 沟通、目标与成长 224
        13.2.1 一对一面谈 225
        13.2.2 PPP 227
        13.2.3 OKR 229
        13.2.4 绩效考核 230
        13.3 向上管理 232
        13.3.1 接收反馈 232
        13.3.2 给予反馈 233
        13.3.3 讨论你的目标 235
        13.3.4 事情不顺时要采取行动 236
        13.4 行为准则 238
        13.5 升级加油站 239
        第14 章 职业生涯规划 241
        14.1 迈向资深之路 241
        14.2 职业生涯建议 242
        14.2.1 T 型人才 242
        14.2.2 参加工程师训练营 243
        14.2.3 主导你自己的晋升 244
        14.2.4 换工作需谨慎 246
        14.2.5 自我调节 247
        14.3 结尾寄语 248
     · · · · · ·     (收起)"
35503091,C语言程序设计：现代方法（第2版•修订版）,9.2,(114人评价),[美] K.N.金 / 吕秀锋、黄倩 / 图灵丨人民邮电出版社 / 2021-7 / 129.80元,"◎ 本书特色
近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分
哈佛、麻省理工、斯坦福等诸多名校C语言教材
基于C1X标准全新升级
浙江大...",https://book.douban.com/subject/35503091/,https://img9.doubanio.com/view/subject/s/public/s33927414.jpg,129.80元,9787115565198,"◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超...(展开全部)





◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超过95%的大学用C语言作为入门编程语言，但也因此把C语言当作一种学习编程的教学媒介语言来教，使得学生只学到了其中的基础部分，而对C语言近30年的发展及其在工业中的应用所知甚少。本书是难得的真正讲述C语言的教材，覆盖了C99、C11、C18标准的内容。本书非常适合今后会用C语言来做嵌入式系统、设备驱动和操作系统等产品开发的人士学习。在浙江大学，我们在工程实践课程中使用了本书的上一个版本，收获了良好的教学效果。 ——翁恺，浙江大学计算机学院教授 书如其名，本书以一种崭新的视角和通俗易懂的方式，来向读者介绍C语言的“现代方法”，聚焦程序设计的核心问题和方法，给C语言这门经久不衰、老而弥坚的语言赋予了崭新的面貌。本书介绍了C99和C1X的许多新特性，而且编排方式方便读者查阅。本书用现代的视角来解读C语言，每章后面的“问与答”也很贴心，适时地解答了读者在阅读过程中可能会遇到的很多疑难问题。本书内容特别适合具备一定语言基础，想深入了解C语言精髓的读者，我相信这本书一定会受到读者的欢迎，成为C语言爱好者提升内功的一本武林秘笈。 ——苏小红，哈尔滨工业大学教授、博士生导师，省级教学名师 本书讨论了C语言的所有特性，从C89一直贯穿到C18。内容足够新，也足够全面，这就是它的突出特色。 ——吴咏炜，Boolan首席咨询师 本书是C语言程序设计的经典图书，本次修订版增加了C1X的内容，并就C1X与之前的C89、C99进行了比对，做到了与时俱进。本书更是新增了第28章，重点介绍了C1X的多线程特性，相信对读者会有巨大的帮助。读者通过阅读本书，可深入理解C89、C99和C1X的演进，并进一步思考C语言为什么这么演进，这对提高自身的思维能力以及对软件工程问题的认知都会有帮助。 ——宋宝华，资深Linux专家",作者简介 K. N. 金（K. N. King） 世界知名的计算机程序设计教育家。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院和佐治亚州立大学。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide和Java Programming: From the Beginning。 译者简介 吕秀锋 曾任教于北京理工大学软件学院，讲授过多门计算机课程，包括“计算机基础（双语）”“C语言程序设计（双语）”“数据结构”“程序设计开发与实践”。 黄倩 河海大学计算机科学与技术系主任，兼任中国人工智能学会深度学习专委会委员、中国计算机学会多媒体技术专委会委员。博士毕业于中国科学院计算技术研究所，译有《编程珠玑（第2版）》等。,"第1章 C语言概述
        第2章 C语言基本概念
        第3章 格式化输入/输出
        第4章 表达式
        第5章 选择语句
        第6章 循环
        第7章 基本类型
        第8章 数组
        第9章 函数
        第10章 程序结构
        第11章 指针
        第12章 指针和数组
        第13章 字符串
        第14章 预处理器
        第15章 编写大型程序
        第16章 结构、联合和枚举
        第17章 指针的高级应用
        第18章 声明
        第19章 程序设计
        第20章 底层程序设计
        第21章 标准库
        第22章 输入/输出
        第23章 库对数值和字符数据的支持
        第24章 错误处理
        第25章 国际化特性
        第26章 其他库函数
        第27章 C99对数学计算的新增支持
        第28章 C1X新增的多线程和原子操作支持
        附录A C语言运算符
        附录B C1X与C99的比较
        附录C C99与C89的比较
        附录D C89与经典C的比较
        附录E 标准库函数
        附录F ASCII字符集
        延伸阅读
        索引
     · · · · · ·     (收起)"
1998341,计算机系统要素,9.1,(269人评价),[美] Noam Nisan、[美] Shimon Schocken / 周维、宋磊、陈曦 / 电子工业出版社 / 2007-01-01 / 45.00元,本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，...,https://book.douban.com/subject/1998341/,https://img9.doubanio.com/view/subject/s/public/s2207295.jpg,45.00元,9787121033360,"本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统...(展开全部)





本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统所必需的工具和资料，以及用于12个项目的200个测试程序。 全书内容广泛、涉猎全面，适合计算机及相关专业本科生、研究生、技术开发人员、教师以及技术爱好者参考和学习。","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
    · · · · · ·
    (更多)","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
        1.1.3 实际硬件结构
        1.1.4 硬件描述语言（HDL）
        1.1.5 硬件仿真
        1.2 规范详述
        1.2.1 Nand门
        1.2.2 基本逻辑门
        1.2.3 多位基本门
        1.2.4 多通道逻辑门
        1.3 实现
        1.4 观点
        1.5 项目
        第2章 布尔运算
        2.1 背景知识
        2.2 规范详述
        2.2.1 加法器
        2.2.2 算术逻辑单元（ALU）
        2.3 实现
        2.4 观点
        2.5 项目
        第3章 时序逻辑
        3.1 背景知识
        3.2 规范详述
        3.2.1 D触发器
        3.2.2 寄存器
        3.2.3 存储
        3.2.4 计数器
        3.3 实现
        3.4 观点
        3.5 项目
        第4章 机器语言
        4.1 背景知识
        4.1.1 机器
        4.1.2 语言
        4.1.3 命令
        4.2 Hack机器语言规范详述
        4.2.1 概述
        4.2.2 A-指令
        4.2.3 C-指令
        4.2.4 符号
        4.2.5 输入/输出处理
        4.2.6 语法规约和文件格式
        4.3 观点
        4.4 项目
        第5章 计算机体系结构
        5.1 背景知识
        5.1.1 存储程序概念
        5.1.2 冯?诺依曼结构
        5.1.3 内存
        5.1.4 中央处理器
        5.1.5 寄存器
        5.1.6 输入和输出
        5.2 Hack硬件平台规范详述
        5.2.1 概述
        5.2.2 中央处理器（CPU）
        5.2.3 指令内存
        5.2.4 数据内存
        5.2.5 计算机
        5.3 实现
        5.3.1 中央处理器
        5.3.2 内存
        5.3.3 计算机
        5.4 观点
        5.5 项目
        第6章 汇编编译器
        第7章 虚拟机Ⅰ：堆栈运算
        第8章 虚拟机Ⅱ：程序控制
        第9章 高级语言
        第10章 编译器Ⅰ：语法分析
        第11章 编译器Ⅱ：代码生成
        第12章 操作系统
        第13章 后记：发掘更多乐趣
        附录A： 硬件描述语言（HDL）
        附录B： 测试脚本语言
        索引
     · · · · · ·     (收起)"
35972849,代码大全2（纪念版）,9.3,(62人评价),[美] 史蒂夫·麦康奈尔(Steve McConnell) / 陈玉毅、陈军、杨志昂、洪佳、徐东伟、王国良、徐毅、李虎 / 清华大学出版社 / 2022-7-7 / 256.00,"《软件开发》杂志Jolt大奖
大而全，洞悉软件构建精髓
优而先，兼顾行业实践研究
奠定硬核技术领导力的经典
庸常变身卓越的实用性指导
《代码大全2》是著名科...",https://book.douban.com/subject/35972849/,https://img3.doubanio.com/view/subject/s/public/s34276333.jpg,256.00,9787302583646,"《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序...(展开全部)





《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。无论是什么背景的读者，阅读本书都有助于在更短的时间内、更容易地写出更好、更简洁、更优雅的程序。","史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现...(展开全部)




史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现象级科技类图书缔造者 • 会做（编程）又会教的一线程序员 • 《软件开发》杂志震撼图书大奖（两次） • 《软件开发》杂志生产力大奖（两次） •   西雅图大学杰出校友奖 • 《普吉特海湾商业期刊》40 UNDER 40杰出青年奖 •  波音和微软等公司顾问 •  ACM（计算机学会）金牌核心奖章得主 •  IEEE Software杂志主编 •  惠特曼文理学院优秀毕业生，PBK会员","第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界　003
        第2章　通过隐喻更充分地理解软件开发　009
        第3章　谋定而后动：前期准备　023
        第4章　关键的构建决策　057
        第II部分高质量的代码
        第5章　软件构建的设计　069
        第6章　可以工作的类　121
        第7章　高质量的子程序　157
        第8章　防御式编程　187
        第9章　伪代码编程过程　215
        第Ⅲ部分变量
        第10章　变量使用中的常规问题　239
        第11章　变量名称的威力　263
        第12章　基本数据类型　295
        第13章　不常见的数据类型　323
        第Ⅳ部分语句
        第14章　直线型代码的组织　353
        第15章　使用条件语句　361
        第16章　控制循环　373
        第17章　不常见的控制结构　395
        第18章　表驱动法　417
        第19章　常规控制问题　437
        第Ⅴ部分代码改进
        第20章　软件质量概述　469
        第21章　协同构建　483
        第22章　开发人员测试　503
        第23章　调试　541
        第24章　重构　569
        第25章　代码调优策略　591
        第26章　代码调优技术　613
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响　651
        第28章　管理构建　663
        第29章　集成　693
        第30章　编程工具　715
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格　733
        第32章　自文档代码　781
        第33章　个人性格　821
        第34章　关于软件匠艺　837
        第35章　更多信息来源　853
        详细目录
        第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界	003
        1.1什么是软件构建	003
        1.2软件构建为何如此重要	006
        1.3如何阅读本书	008
        第2章　通过隐喻更充分地
        理解软件开发	009
        2.1隐喻的重要性	009
        2.2如何使用软件隐喻	012
        2.3常见的软件隐喻	013
        第3章　谋定而后动：前期准备	023
        3.1前期准备的重要性	024
        3.2确定要开发什么类型的软件	030
        3.3定义问题的先决条件	034
        3.4需求的先决条件	036
        3.5架构的先决条件	041
        3.6前期准备所花费的时间	052
        第4章　关键的构建决策	057
        4.1编程语言的选择	057
        4.2编程约定	062
        4.3判断个人处于技术浪潮中的哪个阶段	062
        4.4选择重要的构建实践	065
        第II部分高质量的代码
        第5章　软件构建的设计	069
        5.1设计挑战	070
        5.2关键设计概念	073
        5.3设计构建基块：启发式方法	083
        5.4设计实践	107
        5.5点评各种流行的方法论	115
        第6章　可以工作的类	121
        6.1类的基础：抽象数据类型(ADT)	122
        6.2良好的类接口	129
        6.3设计和实现问题	139
        6.4创建类的理由	149
        6.5语言特定问题	153
        6.6超越类：包	153
        第7章　高质量的子程序	157
        7.1创建子程序的正当理由	160
        7.2子程序级别的设计	165
        7.3好的子程序名称	169
        7.4一个子程序应该有多长	171
        7.5如何使用子程序参数	173
        7.6函数使用中的特别注意事项	180
        7.7宏子程序和内联子程序	182
        第8章　防御式编程	187
        8.1保护程序，
        使其免受无效输入的影响	188
        8.2断言	189
        8.3错误处理技术	194
        8.4异常	198
        8.5隔离程序，使之包容
        由错误造成的损害	203
        8.6调试辅助代码	205
        8.7确定在生产代码中
        保留多少防御式代码	209
        8.8对防御式编程采取防御的姿态	211
        第9章　伪代码编程过程	215
        9.1类和子程序构建步骤总结	215
        9.2面向专家的伪代码	218
        9.3使用PPP构建子程序	220
        9.4PPP的替代方案	233
        第Ⅲ部分变量
        第10章　变量使用中的常规问题	239
        10.1数据扫盲	240
        10.2简化变量声明	241
        10.3变量初始化指南	242
        10.4作用域	247
        10.5持久性	254
        10.6绑定时间	255
        10.7数据类型和控制结构之间的关系	257
        10.8每个变量只有一个用途	258
        第11章　变量名称的威力	263
        11.1选择好名称的注意事项	263
        11.2特定数据类型的命名	269
        11.3命名规范的威力	275
        11.4非正式的命名规范	276
        11.5前缀的标准化	283
        11.6创建可读的短名称	286
        11.7变量名称避坑指南	289
        第12章　基本数据类型	295
        12.1一般的数字	296
        12.2整型	297
        12.3浮点型	299
        12.4字符和字符串	302
        12.5布尔变量	305
        12.6枚举类型	307
        12.7具名常量	312
        12.8数组	314
        12.9创建自定义类型(类型别名)	316
        第13章　不常见的数据类型	323
        13.1结构体	323
        13.2指针	327
        13.3全局数据	340
        第Ⅳ部分语句
        第14章　直线型代码的组织	353
        14.1顺序攸关的语句	353
        14.2顺序无关的语句	356
        第15章　使用条件语句	361
        15.1if语句	361
        15.2case语句	367
        第16章　控制循环	373
        16.1选择循环类型	373
        16.2控制循环	379
        16.3轻松创建循环：由内而外 	391
        16.4循环和数组的对应关系	393
        第17章　不常见的控制结构	395
        17.1子程序中的多个返回点	395
        17.2递归	397
        17.3goto语句	402
        17.4众说纷纭，谈谈不常见的控制结构	413
        第18章　表驱动法	417
        18.1表驱动法使用总则	417
        18.2直接访问表	419
        18.3索引访问表	431
        18.4阶梯访问表	433
        18.5表查询的其他示例	436
        第19章　常规控制问题	437
        19.1布尔表达式	437
        19.2复合语句(语句块)	448
        19.3空语句	449
        19.4驾驭深层嵌套	451
        19.5编程基础：结构化编程	460
        19.6控制结构与复杂度	462
        第Ⅴ部分代码改进
        第20章　软件质量概述	469
        20.1软件质量的特性	469
        20.2改进软件质量的技术	472
        20.3质量保证技术的相对效能	475
        20.4何时进行质量保证	479
        20.5软件质量的普遍原理	479
        第21章　协同构建	483
        21.1协同开发实践概述	484
        21.2结对编程	487
        21.3正式审查	489
        21.4其他类型的协同开发实践	496
        第22章　开发人员测试	503
        22.1开发者测试
        对软件质量所起的作用	504
        22.2开发人员测试的推荐方法	507
        22.3一些测试技巧	509
        22.4典型错误 	522
        22.5测试支持工具	528
        22.6改进测试	534
        22.7维护测试记录 	535
        第23章　调试	541
        23.1调试问题概述	541
        23.2发现缺陷	546
        23.3修复缺陷	557
        23.4调试中的心理因素	560
        23.5那些显而易见和
        不太明显的调试工具	563
        第24章　重构	569
        24.1软件演变的类型	570
        24.2重构简介	571
        24.3特定的重构	577
        24.4安全重构	585
        24.5重构策略	587
        第25章　代码调优策略	591
        25.1性能概述	592
        25.2代码调优简介	595
        25.3各式各样的臃肿和蜜糖	601
        25.4度量	607
        25.5迭代	608
        25.6代码调优方法总结	609
        第26章　代码调优技术	613
        26.1逻辑	614
        26.2循环	619
        26.3数据变换	628
        26.4表达式	633
        26.5子程序	642
        26.6用低级语言重新编码	643
        26.7改得越多，越不会有大的改观	646
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响	651
        27.1沟通和规模	651
        27.2项目规模的范围	652
        27.3项目规模对错误的影响	653
        27.4项目规模对生产力的影响	655
        27.5项目规模对开发活动的影响	656
        第28章　管理构建	663
        28.1鼓励良好的编码实践	664
        28.2配置管理	666
        28.3评估构建进度表	673
        28.4度量	679
        28.5以人为本，善待每一位程序员	683
        28.6向上管理	689
        第29章　集成	693
        29.1集成方法的重要性	693
        29.2集成的频率，阶段式还是增量式	695
        29.3增量式集成策略	698
        29.4每日构建和冒烟测试	707
        第30章　编程工具	715
        30.1设计工具	716
        30.2源代码工具	716
        30.3可执行码工具	721
        30.4面向工具的环境	726
        30.5自己动手写编程工具	726
        30.6工具的幻境	728
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格	733
        31.1基本理论	734
        31.2布局技术	741
        31.3布局风格	743
        31.4控制结构的布局	750
        31.5单条语句的布局	757
        31.6注释的布局	768
        31.7子程序的布局	771
        31.8类的布局	772
        第32章　自文档代码	781
        32.1外部文档	781
        32.2编程风格即文档	782
        32.3注释，还是不注释	785
        32.4高效注释的关键	788
        32.5注释的技术	795
        32.6IEEE标准	815
        第33章　个人性格	821
        33.1个人性格与本书主题有关	822
        33.2聪明与谦卑	823
        33.3好奇心	824
        33.4理性诚实	827
        33.5沟通与合作	830
        33.6创造力与规范	830
        33.7懒惰	831
        33.8没有想象中那么重要的性格因素	832
        33.9习惯	833
        第34章　关于软件匠艺	837
        34.1征服复杂性	837
        34.2优选开发过程	839
        34.3编写程序时，先考虑人，
        再考虑机器	840
        34.4深入语言去编程，
        而不是用语言来编程	842
        34.5借助于规范来保持专注	843
        34.6面向问题域编程	844
        34.7 当心落石	846
        34.8迭代，迭代，迭代，
        重要的事情说三遍	848
        34.9警惕编程中的执念	849
        试验	851
        第35章　更多信息来源	853
        35.1与软件构建相关的信息	853
        35.2软件构建之外的话题	854
        35.3出版物	856
        35.4软件开发者的阅读计划	857
        35.5加入专业组织	859
        参考文献	861
     · · · · · ·     (收起)"
35520512,深入浅出Pandas,8.6,(97人评价),李庆辉 / 机械工业出版社 / 2021-7-10 / 99.00,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。
这是一本全面覆盖了Pandas使用者的普遍需求和...",https://book.douban.com/subject/35520512/,https://img9.doubanio.com/view/subject/s/public/s33944495.jpg,99.00,9787111685456,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 ...(展开全部)





如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 第三部分（第6～9章） 数据形式变化 讲解了Pandas的分组聚合操作、合并操作、对比操作、数据透视、转置、归一化、标准化等，以及如何利用多层索引对数据进行升降维。 第四部分（第10～12章） 数据清洗 讲解了缺失值和重复值的识别、删除、填充，数据的替换、格式转换，文本的提取、连接、匹配、切分、替换、格式化、虚拟变量化等，以及分类数据的应用场景和操作方法。 第五部分（第13～14章）时序数据分析 讲解了Pandas中对于各种时间类型数据的处理和分析，以及在时序数据处理中经常使用的窗口计算。 第六部分（第15～16章） 可视化 讲解了Pandas的样式功能如何让数据表格更有表现力，以及Pandas的绘图功能如何让数据自己说话。 第七部分（第17章） 实战案例 介绍了从需求到代码的思考过程，如何利用链式编程思想提高代码编写和数据分析效率，以及数据分析的基本方法与需要掌握的数据分析工具和技术栈，此外还从数据处理和数据分析两个角度给出了大量的应用案例及代码详解。",李庆辉，数据产品专家，某电商公司数据产品团队负责人，擅长通过数据治理、数据分析、数据化运营提升公司的数据应用水平。 精通 Python 数据科学及 Python Web 开发，曾独立开发公司的自动化数据分析平台，参与教育部“1+X”数据分析（Python）职业技能等级标准评审。 中国人工智能学会会员，企业数字化、数据产品和数据分析讲师，在个人网站“盖若”上编写的技术和产品教程广受欢迎。,"前言
        第一部分 Pandas入门
        第1章 Pandas简介及快速入门2
        1.1 Pandas是什么2
        1.1.1 Python简介2
        1.1.2 Python的应用3
        1.1.3 为什么不选择R4
        1.1.4 Pandas简介4
        1.1.5 Pandas的使用人群5
        1.1.6 Pandas的基本功能5
        1.1.7 Pandas的学习方法6
        1.1.8 小结6
        1.2 环境搭建及安装6
        1.2.1 Python环境安装7
        1.2.2 Anaconda简介7
        1.2.3 安装miniconda8
        1.2.4 多Python版本环境9
        1.2.5 安装编辑器10
        1.2.6 Jupyter Notebook10
        1.2.7 用pip安装三方库11
        1.2.8 安装Jupyter Notebook12
        1.2.9 启动Jupyter Notebook12
        1.2.10 使用Jupyter Notebook13
        1.2.11 安装Pandas14
        1.2.12 小结14
        1.3 Pandas快速入门14
        1.3.1 安装导入14
        1.3.2 准备数据集15
        1.3.3 读取数据15
        1.3.4 查看数据16
        1.3.5 验证数据17
        1.3.6 建立索引17
        1.3.7 数据选取18
        1.3.8 排序19
        1.3.9 分组聚合19
        1.3.10 数据转换20
        1.3.11 增加列21
        1.3.12 统计分析21
        1.3.13 绘图21
        1.3.14 导出24
        1.3.15 小结24
        1.4 本章小结24
        第2章 数据结构25
        2.1 数据结构概述25
        2.1.1 什么是数据25
        2.1.2 什么是数据结构26
        2.1.3 小结26
        2.2 Python的数据结构26
        2.2.1 数字27
        2.2.2 字符串27
        2.2.3 布尔型28
        2.2.4 列表29
        2.2.5 元组30
        2.2.6 字典30
        2.2.7 集合31
        2.2.8 小结32
        2.3 NumPy32
        2.3.1 NumPy简介33
        2.3.2 数据结构33
        2.3.3 创建数据34
        2.3.4 数据类型34
        2.3.5 数组信息35
        2.3.6 统计计算35
        2.3.7 小结35
        2.4 Pandas的数据结构35
        2.4.1 Series36
        2.4.2 DataFrame36
        2.4.3 索引37
        2.4.4 小结38
        2.5 Pandas生成数据38
        2.5.1 导入Pandas38
        2.5.2 创建数据38
        2.5.3 生成Series40
        2.5.4 生成DataFrame41
        2.5.5 小结43
        2.6 Pandas的数据类型43
        2.6.1 数据类型查看43
        2.6.2 常见数据类型44
        2.6.3 数据检测44
        2.6.4 小结45
        2.7 本章小结45
        第二部分 Pandas数据分析基础
        第3章 Pandas数据读取与输出48
        3.1 数据读取48
        3.1.1 CSV文件49
        3.1.2 Excel49
        3.1.3 JSON 50
        3.1.4 HTML50
        3.1.5 剪贴板51
        3.1.6 SQL51
        3.1.7 小结52
        3.2 读取CSV52
        3.2.1 语法52
        3.2.2 数据内容53
        3.2.3 分隔符53
        3.2.4 表头54
        3.2.5 列名54
        3.2.6 索引54
        3.2.7 使用部分列54
        3.2.8 返回序列55
        3.2.9 表头前缀55
        3.2.10 处理重复列名55
        3.2.11 数据类型55
        3.2.12 引擎55
        3.2.13 列数据处理56
        3.2.14 真假值转换56
        3.2.15 跳过指定行56
        3.2.16 读取指定行57
        3.2.17 空值替换57
        3.2.18 保留默认空值57
        3.2.19 日期时间解析58
        3.2.20 文件处理59
        3.2.21 符号60
        3.2.22 小结61
        3.3 读取Excel61
        3.3.1 语法61
        3.3.2 文件内容62
        3.3.3 表格62
        3.3.4 表头62
        3.3.5 列名62
        3.3.6 其他62
        3.3.7 小结63
        3.4 数据输出63
        3.4.1 CSV63
        3.4.2 Excel63
        3.4.3 HTML64
        3.4.4 数据库（SQL）64
        3.4.5 Markdown65
        3.4.6 小结65
        3.5 本章小结65
        第4章 Pandas基础操作66
        4.1 索引操作66
        4.1.1 认识索引66
        4.1.2 建立索引67
        4.1.3 重置索引68
        4.1.4 索引类型68
        4.1.5 索引对象69
        4.1.6 索引的属性70
        4.1.7 索引的操作70
        4.1.8 索引重命名72
        4.1.9 修改索引内容72
        4.1.10 小结73
        4.2 数据的信息73
        4.2.1 查看样本73
        4.2.2 数据形状74
        4.2.3 基础信息74
        4.2.4 数据类型74
        4.2.5 行列索引内容75
        4.2.6 其他信息75
        4.2.7 小结75
        4.3 统计计算76
        4.3.1 描述统计76
        4.3.2 数学统计77
        4.3.3 统计函数78
        4.3.4 非统计计算79
        4.3.5 小结80
        4.4 位置计算80
        4.4.1 位置差值diff()80
        4.4.2 位置移动shift()81
        4.4.3 位置序号rank()81
        4.4.4 小结82
        4.5 数据选择82
        4.5.1 选择列83
        4.5.2 切片[]83
        4.5.3 按轴标签.loc84
        4.5.4 按数字索引.iloc86
        4.5.5 取具体值.at/.iat86
        4.5.6 获取数据.get86
        4.5.7 数据截取.truncate87
        4.5.8 索引选择器87
        4.5.9 小结87
        4.6 本章小结88
        第5章 Pandas高级操作89
        5.1 复杂查询89
        5.1.1 逻辑运算89
        5.1.2 逻辑筛选数据91
        5.1.3 函数筛选92
        5.1.4 比较函数92
        5.1.5 查询df.query()93
        5.1.6 筛选df.filter()93
        5.1.7 按数据类型查询93
        5.1.8 小结94
        5.2 数据类型转换94
        5.2.1 推断类型94
        5.2.2 指定类型95
        5.2.3 类型转换astype()95
        5.2.4 转为时间类型96
        5.2.5 小结96
        5.3 数据排序96
        5.3.1 索引排序97
        5.3.2 数值排序98
        5.3.3 混合排序100
        5.3.4 按值大小排序101
        5.3.5 小结101
        5.4 添加修改101
        5.4.1 修改数值101
        5.4.2 替换数据103
        5.4.3 填充空值103
        5.4.4 修改索引名104
        5.4.5 增加列104
        5.4.6 插入列df.insert()105
        5.4.7 指定列df.assign()106
        5.4.8 执行表达式df.eval()108
        5.4.9 增加行109
        5.4.10 追加合并109
        5.4.11 删除110
        5.4.12 删除空值111
        5.4.13 小结111
        5.5 高级过滤111
        5.5.1 df.where()111
        5.5.2 np.where()113
        5.5.3 df.mask()115
        5.5.4 df.lookup()116
        5.5.5 小结116
        5.6 数据迭代116
        5.6.1 迭代Series116
        5.6.2 df.iterrows()117
        5.6.3 df.itertuples()117
        5.6.4 df.items()118
        5.6.5 按列迭代119
        5.6.6 小结119
        5.7 函数应用120
        5.7.1 pipe()120
        5.7.2 apply()121
        5.7.3 applymap()123
        5.7.4 map()124
        5.7.5 agg()124
        5.7.6 transform()125
        5.7.7 copy()126
        5.7.8 小结126
        5.8 本章小结126
        第三部分 数据形式变化
        第6章 Pandas分组聚合128
        6.1 概述128
        6.1.1 原理128
        6.1.2 groupby语法129
        6.1.3 DataFrame应用分组130
        6.1.4 Series应用分组131
        6.1.5 小结131
        6.2 分组131
        6.2.1 分组对象131
        6.2.2 按标签分组132
        6.2.3 表达式132
        6.2.4 函数分组133
        6.2.5 多种方法混合134
        6.2.6 用pipe调用分组方法134
        6.2.7 分组器Grouper135
        6.2.8 索引136
        6.2.9 排序136
        6.2.10 小结136
        6.3 分组对象的操作136
        6.3.1 选择分组137
        6.3.2 迭代分组138
        6.3.3 选择列139
        6.3.4 应用函数apply()139
        6.3.5 管道方法pipe()142
        6.3.6 转换方法transform()142
        6.3.7 筛选方法filter()144
        6.3.8 其他功能145
        6.3.9 小结146
        6.4 聚合统计146
        6.4.1 描述统计146
        6.4.2 统计函数147
        6.4.3 聚合方法agg()147
        6.4.4 时序重采样方法resample()149
        6.4.5 组内头尾值150
        6.4.6 组内分位数150
        6.4.7 组内差值151
        6.4.8 小结151
        6.5 数据分箱151
        6.5.1 定界分箱pd.cut()152
        6.5.2 等宽分箱pd.qcut()152
        6.5.3 小结154
        6.6 分组可视化154
        6.6.1 绘图方法plot()154
        6.6.2 直方图hist()155
        6.6.3 箱线图boxplot()156
        6.6.4 小结157
        6.7 本章小结158
        第7章 Pandas数据合并与对比159
        7.1 数据追加df.append159
        7.1.1 基本语法159
        7.1.2 相同结构160
        7.1.3 不同结构161
        7.1.4 忽略索引161
        7.1.5 重复内容162
        7.1.6 追加序列162
        7.1.7 追加字典163
        7.1.8 小结163
        7.2 数据连接pd.concat163
        7.2.1 基本语法163
        7.2.2 简单连接164
        7.2.3 按列连接164
        7.2.4 合并交集165
        7.2.5 与序列合并165
        7.2.6 指定索引166
        7.2.7 多文件合并166
        7.2.8 目录文件合并167
        7.2.9 小结167
        7.3 数据合并pd.merge167
        7.3.1 基本语法168
        7.3.2 连接键168
        7.3.3 索引连接169
        7.3.4 多连接键169
        7.3.5 连接方法170
        7.3.6 连接指示170
        7.3.7 小结171
        7.4 按元素合并171
        7.4.1 df.combine_first()171
        7.4.2 df.combine()172
        7.4.3 df.update()173
        7.4.4 小结173
        7.5 数据对比df.compare173
        7.5.1 简单对比174
        7.5.2 对齐方式174
        7.5.3 显示相同值174
        7.5.4 保持形状175
        7.5.5 小结175
        7.6 本章小结175
        第8章 Pandas多层索引177
        8.1 概述177
        8.1.1 什么是多层索引177
        8.1.2 通过分组产生多层索引178
        8.1.3 由序列创建多层索引179
        8.1.4 由元组创建多层索引179
        8.1.5 可迭代对象的笛卡儿积180
        8.1.6 将DataFrame转为多层索引对象180
        8.1.7 小结180
        8.2 多层索引操作181
        8.2.1 生成数据181
        8.2.2 索引信息181
        8.2.3 查看层级182
        8.2.4 索引内容182
        8.2.5 排序183
        8.2.6 其他操作183
        8.2.7 小结183
        8.3 数据查询183
        8.3.1 查询行183
        8.3.2 查询列184
        8.3.3 行列查询185
        8.3.4 条件查询185
        8.3.5 用pd.IndexSlice索引数据186
        8.3.6 df.xs()186
        8.3.7 小结186
        8.4 本章小结186
        第9章 Pandas数据重塑与透视187
        9.1 数据透视187
        9.1.1 整理透视187
        9.1.2 整理透视操作188
        9.1.3 聚合透视189
        9.1.4 聚合透视操作190
        9.1.5 聚合透视高级操作191
        9.1.6 小结192
        9.2 数据堆叠192
        9.2.1 理解堆叠193
        9.2.2 堆叠操作df.stack()194
        9.2.3 解堆操作df.unstack()195
        9.2.4 小结195
        9.3 交叉表195
        9.3.1 基本语法196
        9.3.2 生成交叉表196
        9.3.3 归一化197
        9.3.4 指定聚合方法198
        9.3.5 汇总198
        9.3.6 小结199
        9.4 数据转置df.T199
        9.4.1 理解转置199
        9.4.2 转置操作200
        9.4.3 类型变化200
        9.4.4 轴交换df.swapaxes()201
        9.4.5 小结201
        9.5 数据融合201
        9.5.1 基本语法201
        9.5.2 融合操作202
        9.5.3 标识和值203
        9.5.4 指定名称204
        9.5.5 小结204
        9.6 虚拟变量204
        9.6.1 语法结构204
        9.6.2 生成虚拟变量205
        9.6.3 列前缀205
        9.6.4 从DataFrame生成206
        9.6.5 小结207
        9.7 因子化207
        9.7.1 基本方法207
        9.7.2 排序208
        9.7.3 缺失值208
        9.7.4 枚举类型208
        9.7.5 小结208
        9.8 爆炸列表208
        9.8.1 基本功能209
        9.8.2 DataFrame的爆炸209
        9.8.3 非列表格式210
        9.8.4 小结210
        9.9 本章小结210
        第四部分 数据清洗
        第10章 Pandas数据清洗212
        10.1 缺失值的认定212
        10.1.1 缺失值类型212
        10.1.2 缺失值判断213
        10.1.3 缺失值统计214
        10.1.4 缺失值筛选214
        10.1.5 NA标量215
        10.1.6 时间数据中的缺失值216
        10.1.7 整型数据中的缺失值216
        10.1.8 插入缺失值217
        10.1.9 小结217
        10.2 缺失值的操作217
        10.2.1 缺失值填充217
        10.2.2 插值填充219
        10.2.3 缺失值删除220
        10.2.4 缺失值参与计算221
        10.2.5 小结223
        10.3 数据替换223
        10.3.1 指定值替换223
        10.3.2 使用替换方式223
        10.3.3 字符替换223
        10.3.4 缺失值替换224
        10.3.5 数字替换224
        10.3.6 数据修剪225
        10.3.7 小结226
        10.4 重复值及删除数据226
        10.4.1 重复值识别226
        10.4.2 删除重复值228
        10.4.3 删除数据229
        10.4.4 小结229
        10.5 NumPy格式转换230
        10.5.1 转换方法230
        10.5.2 DataFrame转为ndarray230
        10.5.3 Series转为ndarray231
        10.5.4 df.to_records()231
        10.5.5 np.array读取231
        10.5.6 小结232
        10.6 本章小结232
        第11章 Pandas文本处理233
        11.1 数据类型233
        11.1.1 文本数据类型233
        11.1.2 类型转换234
        11.1.3 类型异同234
        11.1.4 小结235
        11.2 字符的操作235
        11.2.1 .str访问器235
        11.2.2 文本格式236
        11.2.3 文本对齐236
        11.2.4 计数和编码236
        11.2.5 格式判定237
        11.2.6 小结237
        11.3 文本高级处理237
        11.3.1 文本分隔237
        11.3.2 字符分隔展开238
        11.3.3 文本切片选择239
        11.3.4 文本划分240
        11.3.5 文本替换241
        11.3.6 指定替换241
        11.3.7 重复替换242
        11.3.8 文本连接243
        11.3.9 文本查询244
        11.3.10 文本包含245
        11.3.11 文本提取246
        11.3.12 提取虚拟变量247
        11.3.13 小结248
        11.4 本章小结248
        第12章 Pandas分类数据249
        12.1 分类数据249
        12.1.1 创建分类数据249
        12.1.2 pd.Categorical()251
        12.1.3 CategoricalDtype对象251
        12.1.4 类型转换252
        12.1.5 小结253
        12.2 分类的操作253
        12.2.1 修改分类253
        12.2.2 追加新分类254
        12.2.3 删除分类254
        12.2.4 顺序255
        12.2.5 小结256
        12.3 本章小结256
        第五部分 时序数据分析
        第13章 Pandas窗口计算258
        13.1 窗口计算258
        13.1.1 理解窗口计算258
        13.1.2 移动窗口259
        13.1.3 扩展窗口259
        13.1.4 指数加权移动260
        13.1.5 小结260
        13.2 窗口操作260
        13.2.1 计算方法260
        13.2.2 基本语法261
        13.2.3 移动窗口使用262
        13.2.4 统计方法263
        13.2.5 agg()264
        13.2.6 apply()264
        13.2.7 扩展窗口265
        13.2.8 小结266
        13.3 本章小结266
        第14章 Pandas时序数据267
        14.1 固定时间267
        14.1.1 时间的表示267
        14.1.2 创建时间点268
        14.1.3 时间的属性269
        14.1.4 时间的方法270
        14.1.5 时间缺失值271
        14.1.6 小结272
        14.2 时长数据272
        14.2.1 创建时间差272
        14.2.2 时长的加减274
        14.2.3 时长的属性275
        14.2.4 时长索引275
        14.2.5 小结275
        14.3 时间序列275
        14.3.1 时序索引275
        14.3.2 创建时序数据276
        14.3.3 数据访问277
        14.3.4 类型转换279
        14.3.5 按格式转换281
        14.3.6 时间访问器.dt282
        14.3.7 时长数据访问器284
        14.3.8 时序数据移动284
        14.3.9 频率转换285
        14.3.10 小结286
        14.4 时间偏移286
        14.4.1 DateOffset对象286
        14.4.2 偏移别名287
        14.4.3 移动偏移289
        14.4.4 应用偏移289
        14.4.5 偏移参数290
        14.4.6 相关查询290
        14.4.7 与时序的计算291
        14.4.8 锚定偏移292
        14.4.9 自定义工作时间294
        14.4.10 小结296
        14.5 时间段297
        14.5.1 Period对象297
        14.5.2 属性方法297
        14.5.3 时间段的计算298
        14.5.4 时间段索引299
        14.5.5 数据查询300
        14.5.6 相关类型转换301
        14.5.7 小结302
        14.6 时间操作302
        14.6.1 时区转换302
        14.6.2 时间的格式化303
        14.6.3 时间重采样304
        14.6.4 上采样306
        14.6.5 重采样聚合307
        14.6.6 时间类型间转换307
        14.6.7 超出时间戳范围时间308
        14.6.8 区间间隔309
        14.6.9 小结311
        14.7 本章小结312
        第六部分 可视化
        第15章 Pandas样式314
        15.1 内置样式314
        15.1.1 样式功能314
        15.1.2 Styler对象315
        15.1.3 空值高亮315
        15.1.4 极值高亮316
        15.1.5 背景渐变317
        15.1.6 条形图318
        15.1.7 小结320
        15.2 显示格式320
        15.2.1 语法结构320
        15.2.2 常用方法320
        15.2.3 综合运用321
        15.2.4 小结321
        15.3 样式高级操作322
        15.3.1 样式配置操作322
        15.3.2 表格CSS样式323
        15.3.3 应用函数324
        15.3.4 样式复用325
        15.3.5 样式清除325
        15.3.6 导出Excel326
        15.3.7 生成HTML326
        15.3.8 小结327
        15.4 本章小结327
        第16章 Pandas可视化328
        16.1 plot()方法328
        16.1.1 plot()概述328
        16.1.2 plot()基础方法329
        16.1.3 图形类型331
        16.1.4 x轴和y轴331
        16.1.5 图形标题332
        16.1.6 字体大小332
        16.1.7 线条样式333
        16.1.8 背景辅助线334
        16.1.9 图例334
        16.1.10 图形大小334
        16.1.11 色系335
        16.1.12 绘图引擎336
        16.1.13 Matplotlib的其他参数337
        16.1.14 图形叠加337
        16.1.15 颜色的表示337
        16.1.16 解决图形中的中文乱码问题338
        16.1.17 小结340
        16.2 常用可视化图形340
        16.2.1 折线图plot.line340
        16.2.2 饼图plot.pie342
        16.2.3 柱状图plot.bar345
        16.2.4 直方图plot.hist348
        16.2.5 箱形图plot.box351
        16.2.6 面积图plot.area353
        16.2.7 散点图plot.scatter354
        16.2.8 六边形分箱图plot.hexbin356
        16.2.9 小结357
        16.3 本章小结357
        第七部分 实战案例
        第17章 Pandas实战案例360
        17.1 实战思想360
        17.1.1 链式方法360
        17.1.2 代码思路362
        17.1.3 分析方法366
        17.1.4 分析流程368
        17.1.5 分析工具368
        17.1.6 小结369
        17.2 数据处理案例370
        17.2.1 剧组表格道具370
        17.2.2 当月最后一个星期三371
        17.2.3 同组数据转为同一行372
        17.2.4 相关性最强的两个变量373
        17.2.5 全表最大值的位置375
        17.2.6 编写年会抽奖程序376
        17.2.7 北京各区无新增新冠肺炎确诊病例天数377
        17.2.8 生成SQL378
        17.2.9 圣诞节的星期分布379
        17.2.10 试验三天中恰有两天下雨的概率381
        17.2.11 计算平均打卡上班时间382
        17.2.12 小结383
        17.3 综合案例383
        17.3.1 中国经济发展分析383
        17.3.2 新冠肺炎疫情分析387
        17.3.3 利用爬虫获取房价390
        17.3.4 全国城市房价分析392
        17.3.5 客服对话文本分析396
        17.3.6 RFM用户分层399
        17.3.7 自动邮件报表404
        17.3.8 鸢尾花品种预测407
        17.3.9 小结410
        17.4 本章小结410
     · · · · · ·     (收起)"
35768338,Vue.js设计与实现,9.6,(197人评价),霍春阳 / 人民邮电出版社 / 2022-2-10 / 119.8,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章...,https://book.douban.com/subject/35768338/,https://img9.doubanio.com/view/subject/s/public/s34120804.jpg,119.8,9787115583864,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章，分为六篇，主要内容包括：框架设计概览、响应系统、渲染器、组件化、编译器和服务端渲染等。通过阅读本书，对Vue.js 2/3具有上手经验的开发人员能够进一步理解Vue.js框架的实现细节，没有Vue.js使用经验但对框架设计感兴趣的前端开发人员，能够快速掌握Vue.js的设计原理。,霍春阳（HcySunYang） Vue.js官方团队成员，专注于Web研发领域，是Vue.js 3的核心贡献者之一，Vue.js文档生成工具Vuese的作者，技术社区活跃者，曾撰写大量颇受好评的技术博客。,"序
        前言
        第　1章 权衡的艺术　2
        1．1　命令式和声明式　2
        1．2　性能与可维护性的权衡　3
        1．3　虚拟DOM的性能到底如何　4
        1．4　运行时和编译时　8
        1．5　总结　11
        第　2章 框架设计的核心要素　12
        2．1　提升用户的开发体验　12
        2．2　控制框架代码的体积　14
        2．3　框架要做到良好的Tree-Shaking　15
        2．4　框架应该输出怎样的构建产物　17
        2．5　特性开关　19
        2．6　错误处理　21
        2．7　良好的TypeScript类型支持　23
        2．8　总结　25
        第3章　Vue．js 3的设计思路　27
        3．1　声明式地描述UI　27
        3．2　初识渲染器　29
        3．3　组件的本质　32
        3．4　模板的工作原理　34
        3．5　Vue．js是各个模块组成的有机整体　36
        3．6　总结　37
        第4章　响应系统的作用与实现　40
        4．1　响应式数据与副作用函数　40
        4．2　响应式数据的基本实现　41
        4．3　设计一个完善的响应系统　43
        4．4　分支切换与cleanup　50
        4．5　嵌套的effect与effect栈　55
        4．6　避免无限递归循环　59
        4．7　调度执行　60
        4．8　计算属性computed与lazy　64
        4．9　watch的实现原理　71
        4．10　立即执行的watch与回调执行时机　75
        4．11　过期的副作用　77
        4．12　总结　82
        第5章　非原始值的响应式方案　84
        5．1　理解Proxy和Reflect　84
        5．2　JavaScript对象及Proxy的工作原理　88
        5．3　如何代理Object　92
        5．4　合理地触发响应　102
        5．5　浅响应与深响应　108
        5．6　只读和浅只读　110
        5．7　代理数组　113
        5．7．1　数组的索引与 length　114
        5．7．2　遍历数组　119
        5．7．3　数组的查找方法　124
        5．7．4　隐式修改数组长度的原型方法　129
        5．8　代理Set和Map　132
        5．8．1　如何代理Set和Map　133
        5．8．2　建立响应联系　137
        5．8．3　避免污染原始数据　140
        5．8．4　处理forEach　143
        5．8．5　迭代器方法　147
        5．8．6　values与keys方法　152
        5．9　总结　155
        第6章　原始值的响应式方案　158
        6．1　引入ref的概念　158
        6．2　响应丢失问题　160
        6．3　自动脱ref　164
        6．4　总结　166
        第7章　渲染器的设计　170
        7．1　渲染器与响应系统的结合　170
        7．2　渲染器的基本概念　172
        7．3　自定义渲染器　175
        7．4　总结　179
        第8章　挂载与更新　180
        8．1　挂载子节点和元素的属性　180
        8．2　HTML Attributes与DOM Properties　182
        8．3　正确地设置元素属性　184
        8．4　class的处理　189
        8．5　卸载操作　192
        8．6　区分vnode的类型　195
        8．7　事件的处理　196
        8．8　事件冒泡与更新时机问题　201
        8．9　更新子节点　204
        8．10　文本节点和注释节点　209
        8．11　Fragment　212
        8．12　总结　215
        第9章　简单Diff算法　218
        9．1　减少DOM操作的性能开销　218
        9．2　DOM复用与key的作用　221
        9．3　找到需要移动的元素　225
        9．4　如何移动元素　228
        9．5　添加新元素　233
        9．6　移除不存在的元素　238
        9．7　总结　241
        第　10章 双端Diff算法　242
        10．1　双端比较的原理　242
        10．2　双端比较的优势　252
        10．3　非理想状况的处理方式　255
        10．4　添加新元素　263
        10．5　移除不存在的元素　268
        10．6　总结　270
        第　11章 快速Diff算法　271
        11．1　相同的前置元素和后置元素　271
        11．2　判断是否需要进行DOM移动操作　279
        11．3　如何移动元素　288
        11．4　总结　296
        第　12章 组件的实现原理　298
        12．1　渲染组件　298
        12．2　组件状态与自更新　301
        12．3　组件实例与组件的生命周期　304
        12．4　props与组件的被动更新　306
        12．5　setup函数的作用与实现　311
        12．6　组件事件与emit的实现　314
        12．7　插槽的工作原理与实现　316
        12．8　注册生命周期　318
        12．9　总结　320
        第　13章 异步组件与函数式组件　322
        13．1　异步组件要解决的问题　322
        13．2　异步组件的实现原理　324
        13．2．1　封装defineAsyncComponent函数　324
        13．2．2　超时与Error组件　325
        13．2．3　延迟与Loading组件　328
        13．2．4　重试机制　331
        13．3　函数式组件　333
        13．4　总结　335
        第　14章 内建组件和模块　337
        14．1　KeepAlive组件的实现原理　337
        14．1．1　组件的激活与失活　337
        14．1．2　include和exclude　342
        14．1．3　缓存管理　343
        14．2　Teleport组件的实现原理　346
        14．2．1　Teleport组件要解决的问题　346
        14．2．2　实现Teleport组件　347
        14．3　Transition组件的实现原理　350
        14．3．1　原生DOM的过渡　351
        14．3．2　实现Transition组件　356
        14．4　总结　360
        第　15章 编译器核心技术概览　364
        15．1　模板DSL的编译器　364
        15．2　parser的实现原理与状态机　368
        15．3　构造AST　374
        15．4　AST的转换与插件化架构　383
        15．4．1　节点的访问　383
        15．4．2　转换上下文与节点操作　387
        15．4．3　进入与退出　392
        15．5　将模板AST转为JavaScript AST　396
        15．6　代码生成　402
        15．7　总结　407
        第　16章 解析器　409
        16．1　文本模式及其对解析器的影响　409
        16．2　递归下降算法构造模板AST　413
        16．3　状态机的开启与停止　419
        16．4　解析标签节点　426
        16．5　解析属性　430
        16．6　解析文本与解码HTML实体　436
        16．6．1　解析文本　436
        16．6．2　解码命名字符引用　438
        16．6．3　解码数字字符引用　445
        16．7　解析插值与注释　449
        16．8　总结　451
        第　17章 编译优化　453
        17．1　动态节点收集与补丁标志　453
        17．1．1　传统Diff算法的问题　453
        17．1．2　Block与PatchFlags　454
        17．1．3　收集动态节点　457
        17．1．4　渲染器的运行时支持　459
        17．2　Block树　461
        17．2．1　带有v-if指令的节点　462
        17．2．2　带有v-for指令的节点　464
        17．2．3　Fragment的稳定性　465
        17．3　静态提升　466
        17．4　预字符串化　468
        17．5　缓存内联事件处理函数　469
        17．6　v-once　470
        17．7　总结　471
        第　18章 同构渲染　474
        18．1　CSR、SSR以及同构渲染　474
        18．2　将虚拟DOM渲染为HTML字符串　478
        18．3　将组件渲染为HTML字符串　484
        18．4　客户端激活的原理　489
        18．5　编写同构的代码　494
        18．5．1　组件的生命周期　494
        18．5．2　使用跨平台的API　496
        18．5．3　只在某一端引入模块　496
        18．5．4　避免交叉请求引起的状态污染　497
        18．5．5　组件　498
        18．6　总结　499
     · · · · · ·     (收起)"
33450010,动手学深度学习,9.3,(552人评价),阿斯顿·张（Aston Zhang）、李沐（Mu Li）、[美] 扎卡里·C. 立顿（Zachary C. Lipton）、[德] 亚历山大·J. 斯莫拉（Alexander J. Smola） / 人民邮电出版社 / 2019-6 / 85.00元,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的...,https://book.douban.com/subject/33450010/,https://img9.doubanio.com/view/subject/s/public/s32322795.jpg,85.00元,9787115490841,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的 Jupyter记事本，它将文字、公式、图像、代码和运行结果结合在了一起。此外，读者还可以访问并参与书中内容的讨论。 全书的内容分为3个部分：第一部分介绍深度学习的背景，提供预备知识，并包括深度学习最基础的概念和技术；第二部分描述深度学习计算的重要组成部分，还解释近年来令深度学习在多个领域大获成功的卷积神经网络和循环神经网络；第三部分评价优化算法，检验影响深度学习计算性能的重要因素，并分别列举深度学习在计算机视觉和自然语言处理中的重要应用。 本书同时覆盖深度学习的方法和实践，主要面向在校大学生、技术人员和研究人员。阅读本书需要读者了解基本的Python编程或附录中描述的线性代数、微分和概率基础。,"阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、Ne...(展开全部)




阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、NeurIPS、AISTATS、CVPR、KDD 、WSDM、OSDI）上发表过论文。 扎卡里·C. 立顿（Zachary C. Lipton） 亚马逊应用科学家，美国卡内基梅隆大学助理教授，美国加州大学圣迭戈分校博士。他专注于机器学习算法及其社会影响的研究，特别是在时序数据与序列决策上的深度学习。这类工作有着广泛的应用场景，包括医疗诊断、对话系统和产品推荐。他创立了博客“Approximately Correct”（approximatelycorrect.com）。 亚历山大·J. 斯莫拉（Alexander J. Smola） 亚马逊副总裁/ 杰出科学家，德国柏林工业大学计算机科学博士。他曾在澳大利亚国立大学、美国加州大学伯克利分校和卡内基梅隆大学任教。他发表了超过200 篇学术论文，并著有5 本书，其论文及书被引用超过10 万次。他的研究兴趣包括深度学习、贝叶斯非参数、核方法、统计建模和可扩展算法。","对本书的赞誉
        前言
        如何使用本书
        资源与支持
        主要符号表
        第1 章　深度学习简介… ………………… 1
        1.1　起源…………………………………………… 2
        1.2　发展…………………………………………… 4
        1.3　成功案例……………………………………… 6
        1.4　特点………………………………………… 7
        小结…………………………………………… 8
        练习…………………………………………… 8
        第2 章　预备知识… ……………………… 9
        2.1　获取和运行本书的代码……………………… 9
        2.1.1　获取代码并安装运行环境 … ……… 9
        2.1.2　更新代码和运行环境 … …………… 11
        2.1.3　使用GPU版的MXNet … ………… 11
        小结……………………………………………12
        练习……………………………………………12
        2.2　数据操作… ……………………………… 12
        2.2.1　创建NDArray ………………………12
        2.2.2　运算 …………………………………14
        2.2.3　广播机制 ……………………………16
        2.2.4　索引 …………………………………17
        2.2.5　运算的内存开销 ……………………17
        2.2.6　NDArray和NumPy相互变换………18
        小结……………………………………………19
        练习……………………………………………19
        2.3　自动求梯度… …………………………… 19
        2.3.1　简单例子 … …………………………19
        2.3.2　训练模式和预测模式 …………… 20
        2.3.3　对Python控制流求梯度 … …… 20
        小结……………………………………………21
        练习……………………………………………21
        2.4　查阅文档… ……………………………… 21
        2.4.1　查找模块里的所有函数和类 … ……21
        2.4.2　查找特定函数和类的使用 ……… 22
        2.4.3　在MXNet网站上查阅 …………… 23
        小结………………………………………… 24
        练习………………………………………… 24
        第3 章　深度学习基础… ……………… 25
        3.1　线性回归…………………………………… 25
        3.1.1　线性回归的基本要素 … ………… 25
        3.1.2　线性回归的表示方法 … ………… 28
        小结………………………………………… 30
        练习………………………………………… 30
        3.2　线性回归的从零开始实现… …………… 30
        3.2.1　生成数据集 … …………………… 30
        3.2.2　读取数据集 ……………………… 32
        3.2.3　初始化模型参数 ………………… 32
        3.2.4　定义模型 ………………………… 33
        3.2.5　定义损失函数 …………………… 33
        3.2.6　定义优化算法 …………………… 33
        3.2.7　训练模型 ………………………… 33
        小结………………………………………… 34
        练习………………………………………… 34
        3.3　线性回归的简洁实现… ………………… 35
        3.3.1　生成数据集 … …………………… 35
        3.3.2　读取数据集 ……………………… 35
        3.3.3　定义模型 ………………………… 36
        3.3.4　初始化模型参数 ………………… 36
        3.3.5　定义损失函数 …………………… 37
        3.3.6　定义优化算法 …………………… 37
        3.3.7　训练模型 ………………………… 37
        小结………………………………………… 38
        练习………………………………………… 38
        3.4　softmax回归… ………………………… 38
        3.4.1　分类问题 … ……………………… 38
        3.4.2　softmax回归模型… …………… 39
        3.4.3　单样本分类的矢量计算表达式…… 40
        3.4.4　小批量样本分类的矢量计算表达式 …………………………… 40
        3.4.5　交叉熵损失函数 ……………………41
        3.4.6　模型预测及评价 ………………… 42
        小结………………………………………… 42
        练习………………………………………… 42
        3.5　图像分类数据集（Fashion-MNIST）… ……………… 42
        3.5.1　获取数据集 … …………………… 42
        3.5.2　读取小批量 ……………………… 44
        小结………………………………………… 45
        练习………………………………………… 45
        3.6　softmax回归的从零开始实现… ……… 45
        3.6.1　读取数据集 … …………………… 45
        3.6.2　初始化模型参数 ………………… 45
        3.6.3　实现softmax运算 … …………… 46
        3.6.4　定义模型 ………………………… 46
        3.6.5　定义损失函数 …………………… 47
        3.6.6　计算分类准确率 ………………… 47
        3.6.7　训练模型 ………………………… 48
        3.6.8　预测… …………………………… 48
        小结………………………………………… 49
        练习………………………………………… 49
        3.7　softmax回归的简洁实现… …………… 49
        3.7.1　读取数据集 … …………………… 49
        3.7.2　定义和初始化模型 ……………… 50
        3.7.3　softmax和交叉熵损失函数 … … 50
        3.7.4　定义优化算法 …………………… 50
        3.7.5　训练模型 ………………………… 50
        小结………………………………………… 50
        练习………………………………………… 50
        3.8　多层感知机… …………………………… 51
        3.8.1　隐藏层 … ……………………………51
        3.8.2　激活函数 ………………………… 52
        3.8.3　多层感知机 ……………………… 55
        小结………………………………………… 55
        练习………………………………………… 55
        3.9　多层感知机的从零开始实现… ………… 56
        3.9.1　读取数据集 … …………………… 56
        3.9.2　定义模型参数 …………………… 56
        3.9.3　定义激活函数 …………………… 56
        3.9.4　定义模型 ………………………… 56
        3.9.5　定义损失函数 …………………… 57
        3.9.6　训练模型 ………………………… 57
        小结………………………………………… 57
        练习………………………………………… 57
        3.10　多层感知机的简洁实现………………… 57
        3.10.1　定义模型 ………………………… 58
        3.10.2　训练模型 … …………………… 58
        小结………………………………………… 58
        练习………………………………………… 58
        3.11　模型选择、欠拟合和过拟合… ………… 58
        3.11.1　训练误差和泛化误差 …………… 59
        3.11.2　模型选择 ………………………… 59
        3.11.3　欠拟合和过拟合 ………………… 60
        3.11.4　多项式函数拟合实验 ……………61
        小结………………………………………… 65
        练习………………………………………… 65
        3.12　权重衰减………………………………… 65
        3.12.1　方法 ……………………………… 65
        3.12.2　高维线性回归实验 … ………… 66
        3.12.3　从零开始实现 … ……………… 66
        3.12.4　简洁实现 … …………………… 68
        小结………………………………………… 70
        练习………………………………………… 70
        3.13　丢弃法…………………………………… 70
        3.13.1　方法 ……………………………… 70
        3.13.2　从零开始实现 … …………………71
        3.13.3　简洁实现 … …………………… 73
        小结………………………………………… 74
        练习………………………………………… 74
        3.14　正向传播、反向传播和计算图………… 74
        3.14.1　正向传播 ……………………… 74
        3.14.2　正向传播的计算图 … ………… 75
        3.14.3　反向传播 … …………………… 75
        3.14.4　训练深度学习模型 … ………… 76
        小结………………………………………… 77
        练习………………………………………… 77
        3.15　数值稳定性和模型初始化……………… 77
        3.15.1　衰减和爆炸 ……………………… 77
        3.15.2　随机初始化模型参数 … ……… 78
        小结………………………………………… 78
        练习………………………………………… 79
        3.16　实战Kaggle比赛：房价预测… ……… 79
        3.16.1　Kaggle比赛 … ………………… 79
        3.16.2　读取数据集 … ………………… 80
        3.16.3　预处理数据集 … …………………81
        3.16.4　训练模型 … …………………… 82
        3.16.5　k 折交叉验证 …………………… 82
        3.16.6　模型选择 … …………………… 83
        3.16.7　预测并在Kaggle提交结果… … 84
        小结………………………………………… 85
        练习………………………………………… 85
        第4 章　深度学习计算… ……………… 86
        4.1　模型构造………………………………… 86
        4.1.1　继承Block类来构造模型 … …… 86
        4.1.2　Sequential类继承自Block类…………………………… 87
        4.1.3　构造复杂的模型… ……………… 88
        小结………………………………………… 89
        练习………………………………………… 90
        4.2　模型参数的访问、初始化和共享… …… 90
        4.2.1　访问模型参数 … ………………… 90
        4.2.2　初始化模型参数 ………………… 92
        4.2.3　自定义初始化方法 ……………… 93
        4.2.4　共享模型参数 …………………… 94
        小结………………………………………… 94
        练习………………………………………… 94
        4.3　模型参数的延后初始化… ……………… 95
        4.3.1　延后初始化 … …………………… 95
        4.3.2　避免延后初始化 ………………… 96
        小结………………………………………… 96
        练习………………………………………… 97
        4.4　自定义层… ……………………………… 97
        4.4.1　不含模型参数的自定义层 … …… 97
        4.4.2　含模型参数的自定义层 ………… 98
        小结………………………………………… 99
        练习………………………………………… 99
        4.5　读取和存储… …………………………… 99
        4.5.1　读写NDArray… ………………… 99
        4.5.2　读写Gluon模型的参数… ……… 100
        小结………………………………………… 101
        练习………………………………………… 101
        4.6　GPU计算………………………………… 101
        4.6.1　计算设备 … ……………………… 102
        4.6.2　NDArray的GPU计算…………… 102
        4.6.3　Gluon的GPU计算 ……………… 104
        小结………………………………………… 105
        练习………………………………………… 105
        第5 章　卷积神经网络… ……………… 106
        5.1　二维卷积层………………………………… 106
        5.1.1　二维互相关运算 … ……………… 106
        5.1.2　二维卷积层 … …………………… 107
        5.1.3　图像中物体边缘检测 … ………… 108
        5.1.4　通过数据学习核数组 … ………… 109
        5.1.5　互相关运算和卷积运算 … ……… 109
        5.1.6　特征图和感受野… ……………… 110
        小结………………………………………… 110
        练习………………………………………… 110
        5.2　填充和步幅… …………………………… 111
        5.2.1　填充 … …………………………… 111
        5.2.2　步幅 ……………………………… 112
        小结………………………………………… 113
        练习………………………………………… 113
        5.3　多输入通道和多输出通道… …………… 114
        5.3.1　多输入通道 … …………………… 114
        5.3.2　多输出通道… …………………… 115
        5.3.3　1×1卷积层 ……………………… 116
        小结………………………………………… 117
        练习………………………………………… 117
        5.4　池化层… ………………………………… 117
        5.4.1　二维最大池化层和平均池化层 … ………………………… 117
        5.4.2　填充和步幅 ……………………… 119
        5.4.3　多通道 …………………………… 120
        小结………………………………………… 120
        练习………………………………………… 121
        5.5　卷积神经网络（LeNet）… …………… 121
        5.5.1　LeNet模型 … …………………… 121
        5.5.2　训练模型… ……………………… 122
        小结………………………………………… 124
        练习………………………………………… 124
        5.6　深度卷积神经网络（AlexNet）… …… 124
        5.6.1　学习特征表示 … ………………… 125
        5.6.2　AlexNet… ……………………… 126
        5.6.3　读取数据集 ……………………… 127
        5.6.4　训练模型 ………………………… 128
        小结………………………………………… 128
        练习………………………………………… 129
        5.7　使用重复元素的网络（VGG）………… 129
        5.7.1　VGG块 …………………………… 129
        5.7.2　VGG网络 … …………………… 129
        5.7.3　训练模型… ……………………… 130
        小结………………………………………… 131
        练习………………………………………… 131
        5.8　网络中的网络（NiN）… ……………… 131
        5.8.1　NiN块 … ………………………… 131
        5.8.2　NiN模型 … ……………………… 132
        5.8.3　训练模型… ……………………… 133
        小结………………………………………… 134
        练习………………………………………… 134
        5.9　含并行连结的网络（GoogLeNet）…… 134
        5.9.1　Inception块 ……………………… 134
        5.9.2　GoogLeNet模型 … …………… 135
        5.9.3　训练模型 ………………………… 137
        小结………………………………………… 137
        练习………………………………………… 137
        5.10　批量归一化……………………………… 138
        5.10.1　批量归一化层 ………………… 138
        5.10.2　从零开始实现 … ……………… 139
        5.10.3　使用批量归一化层的LeNet … … 140
        5.10.4　简洁实现 … …………………… 141
        小结………………………………………… 142
        练习………………………………………… 142
        5.11　残差网络（ResNet） ……………… 143
        5.11.1　残差块 …………………………… 143
        5.11.2　ResNet模型… ………………… 145
        5.11.3　训练模型………………………… 146
        小结………………………………………… 146
        练习………………………………………… 146
        5.12　稠密连接网络（DenseNet）………… 147
        5.12.1　稠密块 …………………………… 147
        5.12.2　过渡层 … ……………………… 148
        5.12.3　DenseNet模型 ………………… 148
        5.12.4　训练模型 … …………………… 149
        小结………………………………………… 149
        练习………………………………………… 149
        第6 章　循环神经网络… ……………… 150
        6.1　语言模型………………………………… 150
        6.1.1　语言模型的计算 … ……………… 151
        6.1.2　n 元语法 … ……………………… 151
        小结………………………………………… 152
        练习………………………………………… 152
        6.2　循环神经网络… ………………………… 152
        6.2.1　不含隐藏状态的神经网络 … …… 152
        6.2.2　含隐藏状态的循环神经网络… … 152
        6.2.3　应用：基于字符级循环神经网络的语言模型 … ……………………… 154
        小结………………………………………… 155
        练习………………………………………… 155
        6.3　语言模型数据集（歌词）…… 155
        6.3.1　读取数据集 … …………………… 155
        6.3.2　建立字符索引 …………………… 156
        6.3.3　时序数据的采样 ………………… 156
        小结………………………………………… 158
        练习………………………………………… 159
        6.4　循环神经网络的从零开始实现… ……… 159
        6.4.1　one-hot向量 … ………………… 159
        6.4.2　初始化模型参数 ………………… 160
        6.4.3　定义模型 ………………………… 160
        6.4.4　定义预测函数 …………………… 161
        6.4.5　裁剪梯度 ………………………… 161
        6.4.6　困惑度 …………………………… 162
        6.4.7　定义模型训练函数 ……………… 162
        6.4.8　训练模型并创作歌词 …………… 163
        小结………………………………………… 164
        练习………………………………………… 164
        6.5　循环神经网络的简洁实现… …………… 165
        6.5.1　定义模型 … ……………………… 165
        6.5.2　训练模型 ………………………… 166
        小结………………………………………… 168
        练习………………………………………… 168
        6.6　通过时间反向传播… …………………… 168
        6.6.1　定义模型 … ……………………… 168
        6.6.2　模型计算图 ……………………… 169
        6.6.3　方法 ……………………………… 169
        小结………………………………………… 170
        练习………………………………………… 170
        6.7　门控循环单元（GRU）………………… 170
        6.7.1　门控循环单元 … ………………… 171
        6.7.2　读取数据集 ……………………… 173
        6.7.3　从零开始实现 …………………… 173
        6.7.4　简洁实现 ………………………… 175
        小结………………………………………… 176
        练习………………………………………… 176
        6.8　长短期记忆（LSTM）… ……………… 176
        6.8.1　长短期记忆 … …………………… 176
        6.8.2　读取数据集 ……………………… 179
        6.8.3　从零开始实现 …………………… 179
        6.8.4　简洁实现 ………………………… 181
        小结………………………………………… 181
        练习………………………………………… 182
        6.9　深度循环神经网络… …………………… 182
        小结………………………………………… 183
        练习………………………………………… 183
        6.10　双向循环神经网络……………………… 183
        小结………………………………………… 184
        练习………………………………………… 184
        第7 章　优化算法… …………………… 185
        7.1　优化与深度学习…………………………… 185
        7.1.1　优化与深度学习的关系 … ……… 185
        7.1.2　优化在深度学习中的挑战 … …… 186
        小结………………………………………… 188
        练习………………………………………… 189
        7.2　梯度下降和随机梯度下降… …………… 189
        7.2.1　一维梯度下降 … ………………… 189
        7.2.2　学习率 …………………………… 190
        7.2.3　多维梯度下降 …………………… 191
        7.2.4　随机梯度下降 …………………… 193
        小结………………………………………… 194
        练习………………………………………… 194
        7.3　小批量随机梯度下降… ………………… 194
        7.3.1　读取数据集 … …………………… 195
        7.3.2　从零开始实现 …………………… 196
        7.3.3　简洁实现 ………………………… 198
        小结………………………………………… 199
        练习………………………………………… 199
        7.4　动量法… …………………………………200
        7.4.1　梯度下降的问题 … ……………… 200
        7.4.2　动量法 …………………………… 201
        ·6·　目　　录
        7.4.3　从零开始实现 …………………… 203
        7.4.4　简洁实现 ………………………… 205
        小结………………………………………… 205
        练习………………………………………… 205
        7.5　AdaGrad算法……………………………206
        7.5.1　算法 … …………………………… 206
        7.5.2　特点 ……………………………… 206
        7.5.3　从零开始实现 …………………… 208
        7.5.4　简洁实现 ………………………… 209
        小结………………………………………… 209
        练习………………………………………… 209
        7.6　RMSProp算法… ………………………209
        7.6.1　算法 … …………………………… 210
        7.6.2　从零开始实现 …………………… 211
        7.6.3　简洁实现 ………………………… 212
        小结………………………………………… 212
        练习………………………………………… 212
        7.7　AdaDelta算法… ……………………… 212
        7.7.1　算法… …………………………… 212
        7.7.2　从零开始实现 …………………… 213
        7.7.3　简洁实现 ………………………… 214
        小结………………………………………… 214
        练习………………………………………… 214
        7.8　Adam算法… …………………………… 215
        7.8.1　算法 … …………………………… 215
        7.8.2　从零开始实现 …………………… 216
        7.8.3　简洁实现 ………………………… 216
        小结………………………………………… 217
        练习………………………………………… 217
        第8 章　计算性能… …………………… 218
        8.1　命令式和符号式混合编程… …………… 218
        8.1.1　混合式编程取两者之长 … ……… 220
        8.1.2　使用HybridSequential类构造模型 … …………………………… 220
        8.1.3　使用HybridBlock类构造模型… …………………………… 222
        小结………………………………………… 224
        练习………………………………………… 224
        8.2　异步计算… ………………………………224
        8.2.1　MXNet中的异步计算 …………… 224
        8.2.2　用同步函数让前端等待计算结果 … …………………………… 226
        8.2.3　使用异步计算提升计算性能 …… 226
        8.2.4　异步计算对内存的影响 ………… 227
        小结………………………………………… 229
        练习………………………………………… 229
        8.3　自动并行计算… …………………………229
        8.3.1　CPU和GPU的并行计算 … …… 230
        8.3.2　计算和通信的并行计算 ………… 231
        小结………………………………………… 231
        练习………………………………………… 231
        8.4　多GPU计算……………………………… 232
        8.4.1　数据并行 … ……………………… 232
        8.4.2　定义模型 ………………………… 233
        8.4.3　多GPU之间同步数据 … ……… 234
        8.4.4　单个小批量上的多GPU训练 … …………………………… 236
        8.4.5　定义训练函数 …………………… 236
        8.4.6　多GPU训练实验 … …………… 237
        小结………………………………………… 237
        练习………………………………………… 237
        8.5　多GPU计算的简洁实现………………… 237
        8.5.1　多GPU上初始化模型参数……… 238
        8.5.2　多GPU训练模型 … …………… 239
        小结………………………………………… 241
        练习………………………………………… 241
        第9 章　计算机视觉… ………………… 242
        9.1　图像增广…………………………………242
        9.1.1　常用的图像增广方法 … ………… 243
        9.1.2　使用图像增广训练模型 … ……… 246
        小结………………………………………… 250
        练习………………………………………… 250
        9.2　微调… ……………………………………250
        热狗识别 … ……………………………… 251
        小结………………………………………… 255
        练习………………………………………… 255
        目　　录　·7·
        9.3　目标检测和边界框… ……………………255
        边界框 … ………………………………… 256
        小结………………………………………… 257
        练习………………………………………… 257
        9.4　锚框… …………………………………… 257
        9.4.1　生成多个锚框… ………………… 257
        9.4.2　交并比 …………………………… 259
        9.4.3　标注训练集的锚框 ……………… 260
        9.4.4　输出预测边界框… ……………… 263
        小结………………………………………… 265
        练习………………………………………… 265
        9.5　多尺度目标检测… ………………………265
        小结………………………………………… 268
        练习………………………………………… 268
        9.6　目标检测数据集（皮卡丘）… …………268
        9.6.1　获取数据集 … …………………… 269
        9.6.2　读取数据集… …………………… 269
        9.6.3　图示数据 ………………………… 270
        小结………………………………………… 270
        练习………………………………………… 271
        9.7　单发多框检测（SSD）… ……………… 271
        9.7.1　定义模型… ……………………… 271
        9.7.2　训练模型 ………………………… 275
        9.7.3　预测目标 ………………………… 277
        小结………………………………………… 278
        练习………………………………………… 278
        9.8　区域卷积神经网络（R-CNN）系列……280
        9.8.1　R-CNN … ……………………… 280
        9.8.2　Fast R-CNN …………………… 281
        9.8.3　Faster R-CNN ………………… 283
        9.8.4　Mask R-CNN … ……………… 284
        小结………………………………………… 285
        练习………………………………………… 285
        9.9　语义分割和数据集… ……………………285
        9.9.1　图像分割和实例分割 … ………… 285
        9.9.2　Pascal VOC2012语义分割数据集 … ………………………… 286
        小结………………………………………… 290
        练习………………………………………… 290
        9.10　全卷积网络（FCN）… ………………290
        9.10.1　转置卷积层 …………………… 291
        9.10.2　构造模型 … …………………… 292
        9.10.3　初始化转置卷积层……………… 294
        9.10.4　读取数据集 … ………………… 295
        9.10.5　训练模型………………………… 296
        9.10.6　预测像素类别…………………… 296
        小结………………………………………… 297
        练习………………………………………… 297
        9.11　样式迁移… ………………………………298
        9.11.1　方法 ……………………………… 298
        9.11.2　读取内容图像和样式图像……… 299
        9.11.3　预处理和后处理图像 ………… 300
        9.11.4　抽取特征 ……………………… 301
        9.11.5　定义损失函数 ………………… 302
        9.11.6　创建和初始化合成图像 ……… 303
        9.11.7　训练模型………………………… 304
        小结………………………………………… 306
        练习………………………………………… 306
        9.12　实战Kaggle比赛：图像
        分类（CIFAR-10）……………………306
        9.12.1　获取和整理数据集 ……………… 307
        9.12.2　图像增广 … …………………… 310
        9.12.3　读取数据集 … ………………… 310
        9.12.4　定义模型………………………… 311
        9.12.5　定义训练函数 … ……………… 312
        9.12.6　训练模型 … …………………… 312
        9.12.7　对测试集分类并在Kaggle
        提交结果 … …………………… 313
        小结………………………………………… 313
        练习………………………………………… 313
        9.13　实战Kaggle比赛：狗的品种
        识别（ImageNet Dogs）…………… 314
        9.13.1　获取和整理数据集 …………… 315
        9.13.2　图像增广 … …………………… 316
        9.13.3　读取数据集 … ………………… 317
        9.13.4　定义模型 … …………………… 318
        9.13.5　定义训练函数 … ……………… 318
        9.13.6　训练模型 … …………………… 319
        ·8·　目　　录
        9.13.7　对测试集分类并在Kaggle提交结果 … …………………… 319
        小结………………………………………… 320
        练习………………………………………… 320
        第10 章　自然语言处理………………… 321
        10.1　词嵌入（word2vec）………………… 321
        10.1.1　为何不采用one-hot向量… …… 321
        10.1.2　跳字模型 ………………………… 322
        10.1.3　连续词袋模型 …………………… 323
        小结………………………………………… 325
        练习………………………………………… 325
        10.2　近似训练…………………………………325
        10.2.1　负采样 …………………………… 325
        10.2.2　层序softmax …………………… 326
        小结………………………………………… 327
        练习………………………………………… 328
        10.3　word2vec的实现………………………328
        10.3.1　预处理数据集 …………………… 328
        10.3.2　负采样 … ……………………… 331
        10.3.3　读取数据集 … ………………… 331
        10.3.4　跳字模型 … …………………… 332
        10.3.5　训练模型 … …………………… 333
        10.3.6　应用词嵌入模型 … …………… 335
        小结………………………………………… 336
        练习………………………………………… 336
        10.4　子词嵌入（fastText）… ……………336
        小结………………………………………… 337
        练习………………………………………… 337
        10.5　全局向量的词嵌入（GloVe）…………337
        10.5.1　GloVe模型 …………………… 338
        10.5.2　从条件概率比值理解GloVe模型……………………… 339
        小结………………………………………… 340
        练习………………………………………… 340
        10.6　求近义词和类比词………………………340
        10.6.1　使用预训练的词向量 ………… 340
        10.6.2　应用预训练词向量 … ………… 341
        小结………………………………………… 343
        练习………………………………………… 343
        10.7　文本情感分类：使用循环神经网络…… 343
        10.7.1　文本情感分类数据集 ………… 343
        10.7.2　使用循环神经网络的模型……… 345
        小结………………………………………… 347
        练习………………………………………… 347
        10.8　文本情感分类：使用卷积神经网络（textCNN）… …………………347
        10.8.1　一维卷积层 … ………………… 348
        10.8.2　时序最大池化层 … …………… 349
        10.8.3　读取和预处理IMDb数据集 … ……………………… 350
        10.8.4　textCNN模型 … ……………… 350
        小结………………………………………… 353
        练习………………………………………… 353
        10.9　编码器-解码器（seq2seq）…………353
        10.9.1　编码器 ………………………… 354
        10.9.2　解码器 … ……………………… 354
        10.9.3　训练模型………………………… 355
        小结………………………………………… 355
        练习………………………………………… 355
        10.10　 束搜索… ………………………………355
        10.10.1　贪婪搜索 … …………………… 356
        10.10.2　穷举搜索 ……………………… 357
        10.10.3　束搜索 ………………………… 357
        小结………………………………………… 358
        练习………………………………………… 358
        10.11　注意力机制… …………………………358
        10.11.1　计算背景变量 … ……………… 359
        10.11.2　更新隐藏状态 … ……………… 360
        10.11.3　发展… ………………………… 361
        小结………………………………………… 361
        练习………………………………………… 361
        10.12　机器翻译… …………………………… 361
        10.12.1　读取和预处理数据集… ……… 361
        10.12.2　含注意力机制的编码器-解码器 … …………… 363
        10.12.3　训练模型 ……………………… 365
        10.12.4　预测不定长的序列… ………… 367
        10.12.5　评价翻译结果 ………………… 367
        小结………………………………………… 369
        练习………………………………………… 369
        附录A　数学基础… …………………… 370
        附录B　使用 Jupyter 记事本… ……… 376
        附录C　使用 AWS 运行代码…………… 381
        附录D　GPU 购买指南………………… 388
        附录E　如何为本书做贡献… ………… 391
        附录F　d2lzh 包索引…………………… 395
        附录G　中英文术语对照表… ………… 397
        参考文献………………………………… 402
        索引……………………………………… 407
     · · · · · ·     (收起)"
26349607,MATLAB之父:编程实践(中译本),9.3,(20人评价),[ MEI ] Cleve Moler / 薛定宇 / 北京航空航天大学出版社 / 2014-3-1 / 39.9,《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Compu...,https://book.douban.com/subject/26349607/,https://img9.doubanio.com/view/subject/s/public/s28031915.jpg,39.9,9787512414655,"《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求...(展开全部)





《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求式的好奇精神。强烈的好奇心，是克利夫给人留下的最深印象，大到人文历史风土人情，小到会议讲座礼尚往来，他都保持着一种童真般的好奇。这种强烈的好奇心也可以从这本书涉猎广泛的内容中得到体会―― 矩阵、历法、谷歌网页排名、音乐、天体运行、分形图、生命进化、数独等等包罗万象。 这些精彩的内容连同生动文笔都在薛定宇老师的译本中得到了很好的体现。薛老师自己的书在读者中享有很高声誉，我最早拜读的就是他写的自动控制领域经典的教材《控制系统计算机辅助设计―― MATLAB 语言与应用》，结构严谨，思维缜密，内容翔实。这种风格在此书中文版的翻译中与原文达到了奇妙融合，使读者在领略克利夫的独特思路时逻辑清晰，而且兴趣盎然，一定是一次非常愉快的阅读体验。 《MATLAB 之父：编程实践》是北京航空航天大学出版社与迈斯沃克公司在图书合作方面的一个杰作，是迈斯沃克公司近两年中国图书计划中最重要的一个项目。《MATLAB之父：编程实践》一书也获得国内最大的MATLAB/Simulink技术交流平台——MATLAB中文论坛的鼎力推荐,MATLAB中文论坛的“MATLAB读书频道”为本书提供了专门版块供读者交流，以期共同进步。","作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国...(展开全部)




作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国家工程院院士，并获多项荣誉，包括瑞典林学平大学荣誉学位，加拿大滑铁卢大学荣誉数学博士学位，丹麦科技大学荣誉博士等。Cleve还获得IEEE计算机学会的2012年计算机先驱奖。","写在前面
        译者的话
        前言
        第1章迭代（Iteration）1
        第2章斐波那契数（FibonacciNumbers）15
        第3章日历与时钟（CalendarsandClocks）29
        第4章矩阵（Matrices）39
        第5章线性方程组（LinearEquations）53
        第6章蕨型叶分形（FractalFern）63
        第7章谷歌的网页排名值（GooglePageRank）71
        第8章指数函数（ExponentialFunction）85
        第9章T形积木（TPuzzle）99
        第10章幻方问题（MagicSquares）107
        第11章井字棋的魅力（TicTacToeMagic）123
        第12章生命游戏（GameofLife）131
        第13章曼德勃罗集（MandelbrotSet）141
        第14章数独（Sudoku）159
        第15章常微分方程（OrdinaryDifferentialEquations）173
        第16章捕食者与猎物模型（Predator-PreyModel）185
        第17章轨道（Orbits）191
        第18章浅水方程（ShallowWaterEquations）207
        第19章摩尔斯电码（MorseCode）211
        第20章音乐（Music）227
     · · · · · ·     (收起)"
35602582,现代C++语言核心特性解析,8.9,(46人评价),谢丙堃 / 人民邮电出版社 / 2021-10,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还...,https://book.douban.com/subject/35602582/,https://img3.doubanio.com/view/subject/s/public/s33999027.jpg,,9787115564177,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理，让读者能够知其然也知其所以然。本书适合出于工作需要而学习 C++ 新特性的 C++ 从业者，也适合对 C++ 新特性有浓烈兴趣的 C++ 爱好者。而对 C++ 入门者来说，也有必要在有一定的 C++ 基础后阅读本书，通过本书来进一步学习 C++ 的核心特性。本书的多媒体版本已由“盛格塾”以微信小程序方式推出，包含作者的语音讲解、插图、PPT 和示例代码。读者可以在手机上学习，也可以在线提问，与老师和其他同学互动。,谢丙堃，从事 C++ 开发工作十余年，先后在数家知名互联网公司担任 C++ 高级开发工程师、技术专家和技术经理。他也是 C++ 语言的爱好者，热衷于研究 C++ 语言的新特性以及 C++ 模板元编程技术。,"第1章　新基础类型（C++11～C++20） 1
        1.1 整数类型long long 1
        1.2 新字符类型char16_t和char32_t 4
        1.2.1 字符集和编码方法 4
        1.2.2 使用新字符类型char16_t和char32_t 5
        1.2.3 wchar_t存在的问题 6
        1.2.4 新字符串连接 7
        1.2.5 库对新字符类型的支持 7
        1.3 char8_t字符类型 8
        1.4 总结 8
        第2章　内联和嵌套命名空间（C++11～C++20） 9
        2.1 内联命名空间的定义和使用 9
        2.2 嵌套命名空间的简化语法 11
        2.3 总结 13
        第3章　auto占位符（C++11～C++17） 14
        3.1 重新定义的auto关键字 14
        3.2 推导规则 16
        3.3 什么时候使用auto 18
        3.4 返回类型推导 20
        3.5 lambda表达式中使用auto类型推导 20
        3.6 非类型模板形参占位符 21
        3.7 总结 22
        第4章　decltype说明符（C++11～C++17） 23
        4.1 回顾typeof和typeid 23
        4.2 使用decltype说明符 24
        4.3 推导规则 27
        4.4 cv限定符的推导 29
        4.5 decltype(auto) 30
        4.6 decltype(auto)作为非类型模板形参占位符 31
        4.7 总结 32
        第5章　函数返回类型后置（C++11） 33
        5.1 使用函数返回类型后置声明函数 33
        5.2 推导函数模板返回类型 34
        5.3 总结 36
        第6章　右值引用（C++11 C++17 C++20） 37
        6.1 左值和右值 37
        6.2 左值引用 39
        6.3 右值引用 40
        6.4 右值的性能优化空间 42
        6.5 移动语义 43
        6.6 值类别 47
        6.7 将左值转换为右值 48
        6.8 万能引用和引用折叠 50
        6.9 完美转发 52
        6.10 针对局部变量和右值引用的隐式移动操作 55
        6.11 总结 57
        第7章　lambda表达式（C++11～C++20） 58
        7.1 lambda表达式语法 58
        7.2 捕获列表 60
        7.2.1 作用域 60
        7.2.2 捕获值和捕获引用 61
        7.2.3 特殊的捕获方法 64
        7.3 lambda表达式的实现原理 65
        7.4 无状态lambda表达式 68
        7.5 在STL中使用lambda表达式 68
        7.6 广义捕获 69
        7.7 泛型lambda表达式 72
        7.8 常量lambda表达式和捕获*this 72
        7.9 捕获[=, this] 73
        7.10 模板语法的泛型lambda表达式 74
        7.11 可构造和可赋值的无状态lambda表达式 76
        7.12 总结 77
        第8章　非静态数据成员默认初始化（C++11 C++20） 78
        8.1 使用默认初始化 78
        8.2 位域的默认初始化 79
        8.3 总结 80
        第9章　列表初始化（C++11 C++20） 81
        9.1 回顾变量初始化 81
        9.2 使用列表初始化 82
        9.3 std::initializer_list详解 84
        9.4 使用列表初始化的注意事项 86
        9.4.1 隐式缩窄转换问题 86
        9.4.2 列表初始化的优先级问题 87
        9.5 指定初始化 88
        9.6 总结 90
        第10章　默认和删除函数（C++11） 91
        10.1 类的特殊成员函数 91
        10.2 显式默认和显式删除 95
        10.3 显式删除的其他用法 98
        10.4 explicit和=delete 99
        10.5 总结 100
        第11章　非受限联合类型（C++11） 101
        11.1 联合类型在C++中的局限性 101
        11.2 使用非受限联合类型 102
        11.3 总结 106
        第12章　委托构造函数（C++11） 107
        12.1 冗余的构造函数 107
        12.2 委托构造函数 110
        12.3 委托模板构造函数 114
        12.4 捕获委托构造函数的异常 115
        12.5 委托参数较少的构造函数 116
        12.6 总结 117
        第13章　继承构造函数（C++11） 118
        13.1 继承关系中构造函数的困局 118
        13.2 使用继承构造函数 119
        13.3 总结 123
        第14章　强枚举类型（C++11 C++17 C++20） 124
        14.1 枚举类型的弊端 124
        14.2 使用强枚举类型 129
        14.3 列表初始化有底层类型枚举对象 131
        14.4 使用using打开强枚举类型 133
        14.5 总结 135
        第15章　扩展的聚合类型（C++17 C++20） 136
        15.1 聚合类型的新定义 136
        15.2 聚合类型的初始化 137
        15.3 扩展聚合类型的兼容问题 139
        15.4 禁止聚合类型使用用户声明的构造函数 140
        15.5 使用带小括号的列表初始化聚合类型对象 142
        15.6 总结 143
        第16章　override和final说明符（C++11） 144
        16.1 重写、重载和隐藏 144
        16.2 重写引发的问题 145
        16.3 使用override说明符 145
        16.4 使用final说明符 146
        16.5 override和final说明符的特别之处 148
        16.6 总结 148
        第17章　基于范围的for循环（C++11 C++17 C++20） 149
        17.1 烦琐的容器遍历 149
        17.2 基于范围的for循环语法 150
        17.3 begin和end函数不必返回相同类型 151
        17.4 临时范围表达式的陷阱 152
        17.5 实现一个支持基于范围的for循环的类 153
        17.6 总结 155
        第18章　支持初始化语句的if和switch（C++17） 156
        18.1 支持初始化语句的if 156
        18.2 支持初始化语句的switch 159
        18.3 总结 160
        第19章　static_assert声明 161
        19.1 运行时断言 161
        19.2 静态断言的需求 162
        19.3 静态断言 163
        19.4 单参数static_assert 164
        19.5 总结 165
        第20章　结构化绑定（C++17 C++20） 166
        20.1 使用结构化绑定 166
        20.2 深入理解结构化绑定 169
        20.3 结构化绑定的3种类型 171
        20.3.1 绑定到原生数组 171
        20.3.2 绑定到结构体和类对象 172
        20.3.3 绑定到元组和类元组的对象 173
        20.4 实现一个类元组类型 175
        20.5 绑定的访问权限问题 178
        20.6 总结 179
        第21章　noexcept关键字（C++11 C++17 C++20） 180
        21.1 使用noexcept代替throw 180
        21.2 用noexcept来解决移动构造问题 183
        21.3 noexcept和throw() 185
        21.4 默认使用noexcept的函数 186
        21.5 使用noexcept的时机 189
        21.6 将异常规范作为类型的一部分 190
        21.7 总结 192
        第22章　类型别名和别名模板（C++11 C++14） 193
        22.1 类型别名 193
        22.2 别名模板 194
        22.3 总结 196
        第23章　指针字面量nullptr（C++11） 197
        23.1 零值整数字面量 197
        23.2 nullptr关键字 198
        23.3 总结 201
        第24章　三向比较（C++20） 202
        24.1 “太空飞船”（spaceship）运算符 202
        24.2 三向比较的返回类型 202
        24.2.1 std::strong_ordering 203
        24.2.2 std::weak_ordering 204
        24.2.3 std::partial_ordering 205
        24.3 对基础类型的支持 206
        24.4 自动生成的比较运算符函数 207
        24.5 兼容旧代码 210
        24.6 总结 211
        第25章　线程局部存储（C++11） 212
        25.1 操作系统和编译器对线程局部存储的支持 212
        25.2 thread_local说明符 213
        25.3 总结 217
        第26章　扩展的inline说明符（C++17） 218
        26.1 定义非常量静态成员变量的问题 218
        26.2 使用inline说明符 219
        26.3 总结 220
        第27章　常量表达式（C++11～C++20） 221
        27.1 常量的不确定性 221
        27.2 constexpr值 224
        27.3 constexpr函数 225
        27.4 constexpr构造函数 228
        27.5 对浮点的支持 230
        27.6 C++14标准对常量表达式函数的增强 230
        27.7 constexpr lambdas表达式 233
        27.8 constexpr的内联属性 235
        27.9 if constexpr 236
        27.10 允许constexpr虚函数 240
        27.11 允许在constexpr函数中出现Try-catch 244
        27.12 允许在constexpr中进行平凡的默认初始化 244
        27.13 允许在constexpr中更改联合类型的有效成员 245
        27.14 使用consteval声明立即函数 246
        27.15 使用constinit检查常量初始化 247
        27.16 判断常量求值环境 248
        27.17 总结 252
        第28章　确定的表达式求值顺序（C++17） 253
        28.1 表达式求值顺序的不确定性 253
        28.2 表达式求值顺序详解 254
        28.3 总结 255
        第29章　字面量优化（C++11～C++17） 257
        29.1 十六进制浮点字面量 257
        29.2 二进制整数字面量 258
        29.3 单引号作为整数分隔符 258
        29.4 原生字符串字面量 259
        29.5 用户自定义字面量 261
        29.6 总结 267
        第30章　alignas和alignof（C++11 C++17） 268
        30.1 不可忽视的数据对齐问题 268
        30.2 C++11标准之前控制数据对齐的方法 270
        30.3 使用alignof运算符 272
        30.4 使用alignas说明符 273
        30.5 其他关于对齐字节长度的支持 276
        30.6 C++17中使用new分配指定对齐字节长度的对象 278
        30.7 总结 279
        第31章　属性说明符和标准属性（C++11～C++20） 280
        31.1 GCC的属性语法 280
        31.2 MSVC的属性语法 281
        31.3 标准属性说明符语法 282
        31.4 使用using打开属性的命名空间 283
        31.5 标准属性 283
        31.5.1 noreturn 284
        31.5.2 carries_dependency 286
        31.5.3 deprecated 286
        31.5.4 fallthrough 287
        31.5.5 nodiscard 288
        31.5.6 maybe_unused 290
        31.5.7 likely和unlikely 290
        31.5.8 no_unique_address 291
        31.6 总结 293
        第32章　新增预处理器和宏（C++17 C++20） 294
        32.1 预处理器__has_include 294
        32.2 特性测试宏 295
        32.2.1 属性特性测试宏 295
        32.2.2 语言功能特性测试宏 295
        32.2.3 标准库功能特性测试宏 297
        32.3 新增宏__VA_OPT__ 301
        32.4 总结 302
        第33章　协程（C++20） 303
        33.1 协程的使用方法 303
        33.2 协程的实现原理 308
        33.2.1 co_await运算符原理 308
        33.2.2 co_yield运算符原理 313
        33.2.3 co_return运算符原理 317
        33.2.4 promise_type的其他功能 319
        33.3 总结 320
        第34章　基础特性的其他优化（C++11～C++20） 321
        34.1 显式自定义类型转换运算符（C++11） 321
        34.2 关于std::launder()（C++17） 325
        34.3 返回值优化（C++11～C++17） 326
        34.4 允许按值进行默认比较（C++20） 333
        34.5 支持new表达式推导数组长度（C++20） 334
        34.6 允许数组转换为未知范围的数组（C++20） 335
        34.7 在delete运算符函数中析构对象（C++20） 336
        34.8 调用伪析构函数结束对象声明周期（C++20） 337
        34.9 修复const和默认复制构造函数不匹配造成无法编译的问题（C++20） 338
        34.10 不推荐使用volatile的情况（C++20） 339
        34.11 不推荐在下标表达式中使用逗号运算符（C++20） 340
        34.12 模块（C++20） 340
        34.13 总结 341
        第35章　可变参数模板（C++11 C++17 C++20） 342
        35.1 可变参数模板的概念和语法 342
        35.2 形参包展开 344
        35.3 sizeof...运算符 352
        35.4 可变参数模板的递归计算 353
        35.5 折叠表达式 354
        35.6 一元折叠表达式中空参数包的特殊处理 357
        35.7 using声明中的包展开 358
        35.8 lambda表达式初始化捕获的包展开 359
        35.9 总结 361
        第36章　typename优化（C++17 C++20） 362
        36.1 允许使用typename声明模板形参 362
        36.2 减少typename使用的必要性 363
        36.3 总结 365
        第37章　模板参数优化（C++11 C++17 C++20） 366
        37.1 允许常量求值作为所有非类型模板的实参 366
        37.2 允许局部和匿名类型作为模板实参 368
        37.3 允许函数模板的默认模板参数 369
        37.4 函数模板添加到ADL查找规则 370
        37.5 允许非类型模板形参中的字面量类类型 371
        37.6 扩展的模板参数匹配规则 373
        37.7 总结 374
        第38章　类模板的模板实参推导（C++17 C++20） 375
        38.1 通过初始化构造推导类模板的模板实参 375
        38.2 拷贝初始化优先 377
        38.3 lambda类型的用途 378
        38.4 别名模板的类模板实参推导 380
        38.5 聚合类型的类模板实参推导 380
        38.6 总结 382
        第39章　用户自定义推导指引（C++17） 383
        39.1 使用自定义推导指引推导模板实例 383
        39.2 聚合类型类模板的推导指引 386
        39.3 总结 387
        第40章　SFINAE（C++11） 388
        40.1 替换失败和编译错误 388
        40.2 SFINAE规则详解 389
        40.3 总结 394
        第41章　概念和约束（C++20） 395
        41.1 使用std::enable_if约束模板 395
        41.2 概念的背景介绍 396
        41.3 使用concept和约束表达式定义概念 397
        41.4 requires子句和约束检查顺序 398
        41.5 原子约束 401
        41.6 requires表达式 403
        41.6.1 简单要求 404
        41.6.2 类型要求 405
        41.6.3 复合要求 405
        41.6.4 嵌套要求 406
        41.7 约束可变参数模板 407
        41.8 约束类模板特化 408
        41.9 约束auto 409
        41.10 总结 410
        第42章　模板特性的其他优化（C++11 C++14） 411
        42.1 外部模板（C++11） 411
        42.2 连续右尖括号的解析优化（C++11） 413
        42.3 friend声明模板形参（C++11） 415
        42.4 变量模板（C++14） 417
        42.5 explicit(bool) 419
        42.6 总结 423
        附录   特性章节对照表 424
     · · · · · ·     (收起)"
36303408,深度学习入门2,9.7,(32人评价),[日]斋藤康毅 / 郑明智 / 人民邮电出版社 / 2023-3 / 129.80元,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。
手把手带你创建深度学习框架，直击现代深度学习框架本质！
◎ 编辑推荐
• 简明易懂，讲...",https://book.douban.com/subject/36303408/,https://img3.doubanio.com/view/subject/s/public/s34476102.jpg,129.80元,9787115607515,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，...(展开全部)





“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，本书旨在揭开这些技术和机制的神秘面纱，帮助读者正确理解技术，体会它们的有趣之处。为此，本书会带领读者从零开始创建一个深度学习框架——DeZero。 DeZero 是本书原创的框架，它用最少的代码实现了现代深度学习框架的功能。本书分60 个步骤来完成这个框架，在此过程中，读者会加深对PyTorch、TensorFlow 和Chainer 等现代深度学习框架的理解，看清深度学习框架的本质。 本书沿袭《深度学习入门：基于Python 的理论与实现》的风格，语言通俗，代码简洁，讲解详细。在自制框架的过程中，读者还能进一步巩固Python 编程和软件开发相关的知识。 本书适合对深度学习框架感兴趣的读者阅读。",斋藤康毅 1984年生于日本长崎县，东京工业大学毕业，并完成东京大学研究生院课程。目前在某企业从事人工智能相关的研究和开发工作。著有《深度学习入门：基于Python的理论与实现》，同时也是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。,"前言
        第1阶段 自动微分 1
        步骤1 作为“箱子”的变量  3
        1.1 什么是变量  3
        1.2 实现Variable类  4
        1.3 （补充）NumPy的多维数组    6
        步骤2 创建变量的函数     8
        2.1 什么是函数      8
        2.2 Function类的实现   9
        2.3 使用Function类     10
        步骤3 函数的连续调用       13
        3.1 Exp函数的实现     13
        3.2 函数的连续调用     14
        步骤4 数值微分       16
        4.1 什么是导数       16
        4.2 数值微分的实现     17
        4.3 复合函数的导数     20
        4.4 数值微分存在的问题      21
        步骤5 反向传播的理论知识       22
        5.1 链式法则        22
        5.2 反向传播的推导      23
        5.3 用计算图表示       25
        步骤6 手动进行反向传播        27
        6.1 Variable类的功能扩展       27
        6.2 Function类的功能扩展       28
        6.3 Square类和Exp类的功能扩展      28
        6.4 反向传播的实现      29
        步骤7 反向传播的自动化        32
        7.1 为反向传播的自动化创造条件      33
        7.2 尝试反向传播       36
        7.3 增加backward方法       38
        步骤8 从递归到循环        40
        8.1 现在的Variable类       40
        8.2 使用循环实现       41
        8.3 代码验证        42
        步骤9 让函数更易用        43
        9.1 作为Python函数使用       43
        9.2 简化backward方法       45
        9.3 只支持ndarray       46
        步骤10 测试         50
        10.1 Python的单元测试       50
        10.2 square函数反向传播的测试      52
        10.3 通过梯度检验来自动测试      53
        10.4 测试小结       54
        第2阶段 用自然的代码表达       59
        步骤11 可变长参数（正向传播篇)       61
        11.1 修改Function类       62
        11.2 Add类的实现      64
        步骤12 可变长参数（改进篇)        65
        12.1 第1项改进：使函数更容易使用      65
        12.2 第2项改进：使函数更容易实现      67
        12.3 add函数的实现       69
        步骤13 可变长参数（反向传播篇)       70
        13.1 支持可变长参数的Add类的反向传播     70
        13.2 修改Variable类       71
        13.3 Square类的实现      73
        步骤14 重复使用同一个变量        75
        14.1 问题的原因 76
        14.2 解决方案       77
        14.3 重置导数       79
        步骤15 复杂的计算图（理论篇）81
        15.1 反向传播的正确顺序       82
        15.2 当前的DeZero        84
        15.3 函数的优先级      87
        步骤16 复杂的计算图（实现篇）88
        16.1 增加“辈分”变量      88
        16.2 按照“辈分”顺序取出元素     90
        16.3 Variable类的backward       92
        16.4 代码验证       93
        步骤17 内存管理和循环引用        97
        17.1 内存管理       97
        17.2 引用计数方式的内存管理      98
        17.3 循环引用      100
        17.4 weakref模块      102
        17.5 代码验证      104
        步骤18 减少内存使用量的模式      106
        18.1 不保留不必要的导数      106
        18.2 回顾Function类      109
        18.3 使用Confifig类进行切换      110
        18.4 模式的切换      111
        18.5 使用with语句切换    112
        步骤19 让变量更易用       116
        19.1 命名变量      116
        19.2 实例变量ndarray      117
        19.3 len函数和print函数      119
        步骤20 运算符重载（1）122
        20.1 Mul类的实现      122
        20.2 运算符重载      125
        步骤21 运算符重载（2）128
        21.1 与ndarray一起使用     128
        21.2 与flfloat和int一起使用    130
        21.3 问题1：左项为flfloat或int的情况    131
        21.4 问题2：左项为ndarray实例的情况   133
        步骤22 运算符重载（3）134
        22.1 负数       135
        22.2 减法       136
        22.3 除法       138
        22.4 幂运算       139
        步骤23 打包         141
        23.1 文件结构      142
        23.2 将代码移到核心类     142
        23.3 运算符重载      144
        23.4 实际的_ _init_ _.py文件     146
        23.5 导入dezero       147
        步骤24 复杂函数的求导        149
        24.1 Sphere函数       150
        24.2 matyas函数       151
        24.3 GoldsteinPrice函数      152
        第3阶段 实现高阶导数         161
        步骤25 计算图的可视化（1） 163
        25.1 安装Graphviz       163
        25.2 使用DOT语言描述图形     165
        25.3 指定节点属性     165
        25.4 连接节点      167
        步骤26 计算图的可视化（2）169
        26.1 可视化代码的使用示例      169
        26.2 从计算图转换为DOT语言    171
        26.3 从DOT语言转换为图像     174
        26.4 代码验证      176
        步骤27 泰勒展开的导数        178
        27.1 sin函数的实现       178
        27.2 泰勒展开的理论知识      179
        27.3 泰勒展开的实现     180
        27.4 计算图的可视化     182
        步骤28 函数优化        184
        28.1 Rosenbrock函数      184
        28.2 求导       185
        28.3 梯度下降法的实现     186
        步骤29 使用牛顿法进行优化（手动计算）190
        29.1 使用牛顿法进行优化的理论知识    191
        29.2 使用牛顿法实现优化      195
        步骤30 高阶导数（准备篇） 197
        30.1 确认工作①：Variable实例变量    197
        30.2 确认工作②：Function类     199
        30.3 确认工作③：Variable类的反向传播    201
        步骤31 高阶导数（理论篇） 204
        31.1 在反向传播时进行的计算     204
        31.2 创建反向传播的计算图的方法    206
        步骤32 高阶导数（实现篇） 209
        32.1 新的DeZero       209
        32.2 函数类的反向传播     210
        32.3 实现更有效的反向传播（增加模式控制代码）211
        32.4 修改_ _init_ _.py      213
        步骤33 使用牛顿法进行优化（自动计算） 215
        33.1 求二阶导数      215
        33.2 使用牛顿法进行优化      217
        步骤34 sin函数的高阶导数        219
        34.1 sin函数的实现       219
        34.2 cos函数的实现      220
        34.3 sin函数的高阶导数      221
        步骤35 高阶导数的计算图       225
        35.1 tanh函数的导数     226
        35.2 tanh函数的实现     226
        35.3 高阶导数的计算图可视化     227
        步骤36 DeZero的其他用途        234
        36.1 double backprop的用途     234
        36.2 深度学习研究中的应用示例     236
        第4阶段 创建神经网络         243
        步骤37 处理张量        245
        37.1 对各元素进行计算     245
        37.2 使用张量时的反向传播      247
        37.3 使用张量时的反向传播（补充内容）249
        步骤38 改变形状的函数        254
        38.1 reshape函数的实现      254
        38.2 从Variable对象调用reshape    258
        38.3 矩阵的转置      259
        38.4 实际的transpose函数（补充内容）262
        步骤39 求和的函数        264
        39.1 sum函数的反向传播      264
        39.2 sum函数的实现      266
        39.3 axis和keepdims      268
        步骤40 进行广播的函数        272
        40.1 broadcast_to函数和sum_to函数    272
        40.2 DeZero的broadcast_to函数和sum_to函数  275
        40.3 支持广播      277
        步骤41 矩阵的乘积        280
        41.1 向量的内积和矩阵的乘积     280
        41.2 检查矩阵的形状     282
        41.3 矩阵乘积的反向传播      282
        步骤42 线性回归        288
        42.1 玩具数据集      288
        42.2 线性回归的理论知识      289
        42.3 线性回归的实现     291
        42.4 DeZero的mean_squared_error函数（补充内容）  295
        步骤43 神经网络        298
        43.1 DeZero中的linear函数      298
        43.2 非线性数据集     301
        43.3 激活函数和神经网络      302
        43.4 神经网络的实现     303
        步骤44 汇总参数的层       307
        44.1 Parameter类的实现     307
        44.2 Layer类的实现      309
        44.3 Linear类的实现      312
        44.4 使用Layer实现神经网络    314
        步骤45 汇总层的层        316
        45.1 扩展Layer类      316
        45.2 Model类      319
        45.3 使用Model来解决问题      321
        45.4 MLP类      323
        步骤46 通过Optimizer更新参数      325
        46.1 Optimizer类      325
        46.2 SGD类的实现       326
        46.3 使用SGD类来解决问题     327
        46.4 SGD以外的优化方法     328
        步骤47 softmax函数和交叉熵误差      331
        47.1 用于切片操作的函数      331
        47.2 softmax函数      334
        47.3 交叉熵误差      337
        步骤48 多分类       340
        48.1 螺旋数据集      340
        48.2 用于训练的代码     341
        步骤49 Dataset类和预处理        346
        49.1 Dataset类的实现     346
        49.2 大型数据集的情况     348
        49.3 数据的连接      349
        49.4 用于训练的代码     350
        49.5 数据集的预处理     351
        步骤50 用于取出小批量数据的DataLoader     354
        50.1 什么是迭代器     354
        50.2 使用DataLoader      358
        50.3 accuracy函数的实现      359
        50.4 螺旋数据集的训练代码      360
        步骤51 MINST的训练       363
        51.1 MNIST数据集       364
        51.2 训练MNIST       366
        51.3 改进模型      368
        第5阶段 DeZero高级挑战      377
        步骤52 支持GPU        379
        52.1 CuPy的安装和使用方法     379
        52.2 cuda模块      382
        52.3 向Variable / Layer / DataLoader类添加代码   383
        52.4 函数的相应修改     386
        52.5 在GPU上训练MNIST      388
        步骤53 模型的保存和加载       391
        53.1 NumPy的save函数和load函数     391
        53.2 Layer类参数的扁平化    394
        53.3 Layer类的save函数和load函数     395
        步骤54 Dropout和测试模式       398
        54.1 什么是Dropout      398
        54.2 Inverted Dropout     401
        54.3 增加测试模式     401
        54.4 Dropout的实现      402
        步骤55 CNN的机制（1） 404
        55.1 CNN的网络结构      404
        55.2 卷积运算      405
        55.3 填充       407
        55.4 步幅       408
        55.5 输出大小的计算方法      409
        步骤56 CNN的机制（2）411
        56.1 三阶张量      411
        56.2 结合方块进行思考     412
        56.3 小批量处理      414
        56.4 池化层       415
        步骤57 conv2d函数和pooling函数     418
        57.1 使用im2col展开     418
        57.2 conv2d函数的实现      420
        57.3 Conv2d层的实现      425
        57.4 pooling函数的实现      426
        步骤58 具有代表性的CNN（VGG16）429
        58.1 VGG16的实现      429
        58.2 已训练的权重数据     431
        58.3 使用已训练的VGG16     435
        步骤59 使用RNN处理时间序列数据      438
        59.1 RNN层的实现       438
        59.2 RNN模型的实现      442
        59.3 切断连接的方法     445
        59.4 正弦波的预测     446
        步骤60 LSTM与数据加载器       451
        60.1 用于时间序列数据的数据加载器    451
        60.2 LSTM层的实现      453
        附录A inplace运算（步骤14的补充内容）463
        A.1 问题确认        463
        A.2 关于复制和覆盖        464
        A.3 DeZero的反向传播        465
        附录B 实现get_item函数（步骤47的补充内容）466
        附录C 在Google Colaboratory上运行      469
        后 记         473
        参考文献          477
     · · · · · ·     (收起)"
35863224,C++20高级编程(第5版),8.4,(195人评价),[比]马克·格雷戈勒（Marc Gregoire） / 程序喵大人、惠惠、墨梵 / 清华大学出版社 / 2022-4 / 228,"拥抱C++的深度和复杂性，挖掘更多可能
众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉...",https://book.douban.com/subject/35863224/,https://img3.doubanio.com/view/subject/s/public/s34341252.jpg,228,9787302602132,"拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函...(展开全部)





拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函数等 ● 深入讨论新的C++20标准库功能，例如文本格式化、范围、原子智能指针、同步原语、日期、时区等","Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Win...(展开全部)




Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Windows和Linux平台上开发24×7运行的C++程序，例如KNX/EIB家庭自动化监控软件。除了C/C++之外，Marc还喜欢C#。 2007年4月，他凭借Visual C++方面的专业技能，获得了微软年度MVP称号。 Marc还是比利时C++用户组(www.becpp.org)的创始人，是C++ Standard Library Quick Reference 第1版和第2版(Apress)的共同作者，以及多家出版社出版的多种书籍的技术编辑，是C++大会CppCon的活跃演讲者。","第I部分  专业的C++简介
        第1章  C++和标准库速成   3
        1.1  C++速成   3
        1.1.1  小程序“Hello World”   4
        1.1.2  名称空间   7
        1.1.3  字面量   9
        1.1.4  变量   9
        1.1.5  运算符   12
        1.1.6  枚举类型   14
        1.1.7  结构体   16
        1.1.8  条件语句   17
        1.1.9  条件运算符   19
        1.1.10  逻辑比较运算符   20
        1.1.11  三向比较运算符   21
        1.1.12  函数   22
        1.1.13  属性   23
        1.1.14  C风格的数组   26
        1.1.15  std::array   27
        1.1.16  std::vector   28
        1.1.17  std::pair   28
        1.1.18  std::optional   29
        1.1.19  结构化绑定   30
        1.1.20  循环   30
        1.1.21  初始化列表   31
        1.1.22  C++中的字符串   32
        1.1.23  作为面向对象语言的C++   32
        1.1.24  作用域解析   35
        1.1.25  统一初始化   36
        1.1.26  指针和动态内存   39
        1.1.27  const的用法   43
        1.1.28  constexpr关键字   45
        1.1.29  consteval关键字   46
        1.1.30  引用   47
        1.1.31  const_cast()   55
        1.1.32  异常   56
        1.1.33  类型别名   56
        1.1.34  类型定义   57
        1.1.35  类型推断   58
        1.1.36  标准库   60
        1.2  第一个大型的C++程序   61
        1.2.1  雇员记录系统   61
        1.2.2  Employee类   61
        1.2.3  Database类   64
        1.2.4  用户界面   67
        1.2.5  评估程序   69
        1.3  本章小结   69
        1.4  练习   69
        第2章  使用string和string_view   71
        2.1  动态字符串   71
        2.1.1  C风格字符串   71
        2.1.2  字符串字面量   73
        2.1.3  C++ std::string类   75
        2.1.4  数值转换   78
        2.1.5  std::string_view类   81
        2.1.6  非标准字符串   84
        2.2  字符串格式化   84
        2.2.1  格式说明符   85
        2.2.2  格式说明符错误   87
        2.2.3  支持自定义类型   87
        2.3  本章小结   90
        2.4  练习   90
        第3章  编码风格   91
        3.1  良好外观的重要性   91
        3.1.1  事先考虑   91
        3.1.2  良好风格的元素   92
        3.2  为代码编写文档   92
        3.2.1  使用注释的原因   92
        3.2.2  注释的风格   96
        3.3  分解   99
        3.3.1  通过重构分解   100
        3.3.2  通过设计分解   101
        3.3.3  本书中的分解   101
        3.4  命名   101
        3.4.1  选择恰当的名称   101
        3.4.2  命名约定   102
        3.5  使用具有风格的语言特性   103
        3.5.1  使用常量   104
        3.5.2  使用引用代替指针   104
        3.5.3  使用自定义异常   104
        3.6  格式   105
        3.6.1  关于大括号对齐的争论   105
        3.6.2  关于空格和圆括号的争论   106
        3.6.3  空格、制表符、换行符   106
        3.7  风格的挑战   107
        3.8  本章小结   107
        3.9  练习   107
        第II部分  专业的C++软件设计
        第4章  设计专业的C++程序   113
        4.1  程序设计概述   113
        4.2  程序设计的重要性   114
        4.3  C++设计   116
        4.4  C++设计的两个原则   116
        4.4.1  抽象   116
        4.4.2  重用   118
        4.5  重用现有代码   119
        4.5.1  关于术语的说明   119
        4.5.2  决定是否重用代码   120
        4.5.3  重用代码的指导原则   121
        4.6  设计一个国际象棋程序   127
        4.6.1  需求   127
        4.6.2  设计步骤   127
        4.7  本章小结   132
        4.8  练习   133
        第5章  面向对象设计   135
        5.1  过程化的思考方式   135
        5.2  面向对象思想   136
        5.2.1  类   136
        5.2.2  组件   136
        5.2.3  属性   136
        5.2.4  行为   137
        5.2.5  综合考虑   137
        5.3  生活在类的世界里   138
        5.3.1  过度使用类   138
        5.3.2  过于通用的类   139
        5.4  类之间的关系   139
        5.4.1  “有一个”关系   139
        5.4.2  “是一个”关系(继承)   140
        5.4.3  “有一个”与“是一个”的
        区别   142
        5.4.4  not-a关系   144
        5.4.5  层次结构   145
        5.4.6  多重继承   146
        5.4.7  混入类   147
        5.5  本章小结   147
        5.6  练习   148
        第6章  设计可重用代码   149
        6.1  重用哲学   149
        6.2  如何设计可重用代码   150
        6.2.1  使用抽象   150
        6.2.2  构建理想的重用代码   151
        6.2.3  设计有用的接口   157
        6.2.4  设计成功的抽象   162
        6.2.5  SOLID原则   162
        6.3  本章小结   163
        6.4  练习   163
        第III部分  C++编码方法
        第7章  内存管理   167
        7.1  使用动态内存   167
        7.1.1  如何描绘内存   168
        7.1.2  分配和释放   169
        7.1.3  数组   170
        7.1.4  使用指针   177
        7.2  数组-指针的对偶性   178
        7.2.1  数组就是指针   178
        7.2.2  并非所有指针都是数组   180
        7.3  底层内存操作   180
        7.3.1  指针运算   180
        7.3.2  自定义内存管理   181
        7.3.3  垃圾回收   181
        7.3.4  对象池   182
        7.4  常见的内存陷阱   182
        7.4.1  数据缓冲区分配不足以及
        内存访问越界   182
        7.4.2  内存泄漏   183
        7.4.3  双重释放和无效指针   186
        7.5  智能指针   186
        7.5.1  unique_ptr   187
        7.5.2  shared_ptr   190
        7.5.3  weak_ptr   193
        7.5.4  向函数传递参数   193
        7.5.5  从函数中返回   194
        7.5.6  enable_shared_from_this   194
        7.5.7  过时的、移除的auto_ptr   195
        7.6  本章小结   195
        7.7  练习   195
        第8章  类和对象   197
        8.1  电子表格示例介绍   197
        8.2  编写类   198
        8.2.1  类定义   198
        8.2.2  定义方法   200
        8.2.3  使用对象   203
        8.3  对象的生命周期   205
        8.3.1  创建对象   205
        8.3.2  销毁对象   219
        8.3.3  对象赋值   220
        8.3.4  编译器生成的拷贝构造函数和
        拷贝赋值运算符   223
        8.3.5  复制和赋值的区别   223
        8.4  本章小结   224
        8.5  练习   225
        第9章  精通类和对象   227
        9.1  友元   227
        9.2  对象中的动态内存分配   228
        9.2.1  Spreadsheet类   228
        9.2.2  使用析构函数释放内存   231
        9.2.3  处理复制和赋值   231
        9.2.4  使用移动语义处理移动   237
        9.2.5  零规则   246
        9.3  与方法有关的更多内容   246
        9.3.1  static方法   246
        9.3.2  const方法   247
        9.3.3  方法重载   248
        9.3.4  内联方法   251
        9.3.5  默认参数   252
        9.4  不同的数据成员类型   252
        9.4.1  静态数据成员   253
        9.4.2  const static数据成员   254
        9.4.3  引用数据成员   255
        9.5  嵌套类   256
        9.6  类内的枚举类型   257
        9.7  运算符重载   258
        9.7.1  示例：为SpreadsheetCell
        实现加法   258
        9.7.2  重载算术运算符   261
        9.7.3  重载比较运算符   262
        9.7.4  创建具有运算符重载的类型   266
        9.8  创建稳定的接口   266
        9.9  本章小结   270
        9.10  练习   270
        第10章  揭秘继承技术   271
        10.1  使用继承构建类   271
        10.1.1  扩展类   272
        10.1.2  重写方法   275
        10.2  使用继承重用代码   282
        10.2.1  WeatherPrediction类   282
        10.2.2  在派生类中添加功能   283
        10.2.3  在派生类中替换功能   284
        10.3  利用父类   285
        10.3.1  父类构造函数   285
        10.3.2  父类的析构函数   286
        10.3.3  使用父类方法   287
        10.3.4  向上转型和向下转型   289
        10.4  继承与多态性   290
        10.4.1  回到电子表格   290
        10.4.2  设计多态性的电子表格
        单元格   291
        10.4.3  SpreadsheetCell基类   291
        10.4.4  独立的派生类   293
        10.4.5  利用多态性   294
        10.4.6  考虑将来   295
        10.5  多重继承   296
        10.5.1  从多个类继承   296
        10.5.2  名称冲突和歧义基类   297
        10.6  有趣而晦涩的继承问题   300
        10.6.1  修改重写方法的返回类型   300
        10.6.2  派生类中添加虚基类方法的
        重载   301
        10.6.3  继承的构造函数   302
        10.6.4  重写方法时的特殊情况   306
        10.6.5  派生类中的复制构造函数和
        赋值运算符   312
        10.6.6  运行期类型工具   313
        10.6.7  非public继承   314
        10.6.8  虚基类   315
        10.7  类型转换   316
        10.7.1  static_cast()   316
        10.7.2  reinterpret_cast()   317
        10.7.3  std::bit_cast()   318
        10.7.4  dynamic_cast()   318
        10.7.5  类型转换小结   319
        10.8  本章小结   319
        10.9  练习   320
        第11章  零碎的工作   321
        11.1  模块   321
        11.1.1  模块接口文件   322
        11.1.2  模块实现文件   324
        11.1.3  从实现中分离接口   325
        11.1.4  可见性和可访问性   326
        11.1.5  子模块   326
        11.1.6  模块划分   327
        11.1.7  头文件单元   329
        11.2  头文件   330
        11.2.1  重复定义   330
        11.2.2  循环依赖   330
        11.2.3  查询头文件是否存在   331
        11.3  核心语言特性的特性测试宏   331
        11.4  STATIC关键字   332
        11.4.1  静态数据成员和方法   332
        11.4.2  静态链接   332
        11.4.3  函数中的静态变量   334
        11.4.4  非局部变量的初始化顺序   335
        11.4.5  非局部变量的销毁顺序   335
        11.5  C的实用工具   335
        11.5.1  变长参数列表   336
        11.5.2  预处理器宏   337
        11.6  本章小结   338
        11.7  练习   338
        第12章  利用模板编写泛型代码   341
        12.1  模板概述   341
        12.2  类模板   342
        12.2.1  编写类模板   342
        12.2.2  编译器处理模板的原理   349
        12.2.3  将模板代码分布到多个
        文件中   350
        12.2.4  模板参数   351
        12.2.5  方法模板   355
        12.2.6  类模板的特化   359
        12.2.7  从类模板派生   361
        12.2.8  继承还是特化   362
        12.2.9  模板别名   362
        12.3  函数模板   363
        12.3.1  函数模板的重载   364
        12.3.2  类模板的友元函数模板   365
        12.3.3  对模板参数推导的更多介绍   366
        12.3.4  函数模板的返回类型   367
        12.4  简化函数模板的语法   368
        12.5  变量模板   369
        12.6  概念   369
        12.6.1  语法   369
        12.6.2  约束表达式   370
        12.6.3  预定义的标准概念   372
        12.6.4  类型约束的auto   372
        12.6.5  类型约束和函数模板   373
        12.6.6  类型约束和类模板   375
        12.6.7  类型约束和类方法   375
        12.6.8  类型约束和模板特化   376
        12.7  本章小结   376
        12.8  练习   377
        第13章  C++ I/O揭秘   379
        13.1  使用流   379
        13.1.1  流的含义   380
        13.1.2  流的来源和目的地   381
        13.1.3  流式输出   381
        13.1.4  流式输入   386
        13.1.5  对象的输入输出   392
        13.1.6  自定义的操作算子   393
        13.2  字符串流   393
        13.3  文件流   394
        13.3.1  文本模式与二进制模式   395
        13.3.2  通过seek()和tell()在文件中
        转移   395
        13.3.3  将流链接在一起   397
        13.4  双向I/O   398
        13.5  文件系统支持库   399
        13.5.1  路径   399
        13.5.2  目录条目   401
        13.5.3  辅助函数   401
        13.5.4  目录遍历   401
        13.6  本章小结   402
        13.7  练习   403
        第14章  错误处理   405
        14.1  错误与异常   405
        14.1.1  异常的含义   405
        14.1.2  C++中异常的优点   406
        14.1.3  建议   407
        14.2  异常机制   407
        14.2.1  抛出和捕获异常   408
        14.2.2  异常类型   410
        14.2.3  按const引用捕获异常对象   411
        14.2.4  抛出并捕获多个异常   411
        14.2.5  未捕获的异常   414
        14.2.6  noexcept说明符   415
        14.2.7  noexcept(expression)说明符   415
        14.2.8  noexcept(expression)运算符   415
        14.2.9  抛出列表   416
        14.3  异常与多态性   416
        14.3.1  标准异常层次结构   416
        14.3.2  在类层次结构中捕获异常   418
        14.3.3  编写自己的异常类   419
        14.3.4  源码位置   421
        14.3.5  日志记录的源码位置   422
        14.3.6  异常的源码位置   422
        14.3.7  嵌套异常   423
        14.4 重新抛出异常   425
        14.5  堆栈的释放与清理   426
        14.5.1  使用智能指针   427
        14.5.2  捕获、清理并重新抛出   428
        14.6  常见的错误处理问题   428
        14.6.1  内存分配错误   428
        14.6.2  构造函数中的错误   430
        14.6.3  构造函数的function-try-blocks   432
        14.6.4  析构函数中的错误   435
        14.7  本章小结   435
        14.8  练习   435
        第15章  C++运算符重载   437
        15.1  运算符重载概述   437
        15.1.1  重载运算符的原因   438
        15.1.2  运算符重载的限制   438
        15.1.3  运算符重载的选择   438
        15.1.4  不应重载的运算符   440
        15.1.5  可重载运算符小结   440
        15.1.6  右值引用   443
        15.1.7  优先级和结合性   444
        15.1.8  关系运算符   444
        15.2  重载算术运算符   445
        15.2.1  重载一元负号和一元正号
        运算符   445
        15.2.2  重载递增和递减运算符   446
        15.3  重载按位运算符和二元逻辑
        运算符   446
        15.4  重载插入运算符和提取运算符   447
        15.5  重载下标运算符   448
        15.5.1  通过operator[]提供只读访问   451
        15.5.2  非整数数组索引   452
        15.6  重载函数调用运算符   452
        15.7  重载解除引用运算符   453
        15.7.1  实现operator*   454
        15.7.2  实现operator->   455
        15.7.3  operator.*和operator ->*的
        含义   455
        15.8  编写转换运算符   456
        15.8.1  auto运算符   456
        15.8.2  使用显式转换运算符解决
        多义性问题   457
        15.8.3  用于布尔表达式的转换   457
        15.9  重载内存分配和内存释放
        运算符   459
        15.9.1  new和delete的工作原理   459
        15.9.2  重载operator new和
        operator delete   461
        15.9.3  显式地删除/默认化operator new
        和operator delete   463
        15.9.4  重载带有额外参数的operator new
        和operator delete   463
        15.9.5  重载带有内存大小参数的
        operator delete   464
        15.9.6  重载用户定义的字面量
        运算符   464
        15.9.7  cooked模式字面量运算符   465
        15.9.8  raw模式字面量运算符   465
        15.9.9  标准用户定义的字面量   466
        15.10  本章小结   466
        15.11  练习   466
        第16章  C++标准库概述   469
        16.1  编码原则   470
        16.1.1  使用模板   470
        16.1.2  使用运算符重载   470
        16.2  C++标准库概述   470
        16.2.1  字符串   470
        16.2.2  正则表达式   471
        16.2.3  I/O流   471
        16.2.4  智能指针   471
        16.2.5  异常   471
        16.2.6  数学工具   472
        16.2.7  时间和日期工具   473
        16.2.8  随机数   473
        16.2.9  初始化列表   474
        16.2.10  Pair和Tuple   474
        16.2.11  词汇类型   474
        16.2.12  函数对象   474
        16.2.13  文件系统   474
        16.2.14  多线程   475
        16.2.15  类型萃取   475
        16.2.16  标准整数类型   475
        16.2.17  标准库特性测试宏   475
        16.2.18  <version>   476
        16.2.19  源位置   476
        16.2.20  容器   476
        16.2.21  算法   482
        16.2.22  范围库   488
        16.2.23  标准库中还缺什么   488
        16.3  本章小结   489
        16.4  练习   489
        第17章  理解迭代器与范围库   491
        17.1  迭代器   491
        17.1.1  获取容器的迭代器   494
        17.1.2  迭代器萃取   495
        17.1.3  示例   495
        17.2  流迭代器   496
        17.2.1  输出流迭代器   497
        17.2.2  输入流迭代器   497
        17.3  迭代器适配器   498
        17.3.1  插入迭代器   498
        17.3.2  逆向迭代器   499
        17.3.3  移动迭代器   500
        17.4  范围   502
        17.4.1  基于范围的算法   502
        17.4.2  视图   504
        17.4.3  范围工厂   508
        17.5  本章小结   509
        17.6  练习   509
        第18章  标准库容器   511
        18.1  容器概述   511
        18.1.1  对元素的要求   512
        18.1.2  异常和错误检查   513
        18.2  顺序容器   514
        18.2.1  vector   514
        18.2.2  vector<bool>特化   531
        18.2.3  deque   532
        18.2.4  list   532
        18.2.5  forward_list   535
        18.2.6  array   537
        18.2.7  span   538
        18.3  容器适配器   540
        18.3.1  queue   540
        18.3.2  priority_queue   542
        18.3.3  stack   545
        18.4  有序关联容器   545
        18.4.1  pair工具类   545
        18.4.2  map   546
        18.4.3  multimap   554
        18.4.4  set   556
        18.4.5  multiset   558
        18.5  无序关联容器/哈希表   558
        18.5.1  哈希函数   559
        18.5.2  unordered_map   560
        18.5.3  unordered_multimap   563
        18.5.4  unordered_set/
        unordered_multiset   564
        18.6  其他容器   564
        18.6.1  标准C风格数组   564
        18.6.2  string   565
        18.6.3  流   566
        18.6.4  bitset   566
        18.7  本章小结   570
        18.8  练习   570
        第19章  函数指针，函数对象，lambda
        表达式   571
        19.1  函数指针   571
        19.2  指向方法(和数据成员)的指针   573
        19.3  函数对象   576
        19.3.1  编写第一个函数对象   576
        19.3.2  标准库中的函数对象   576
        19.4  lambda表达式   582
        19.4.1  语法   583
        19.4.2  lambda表达式作为参数   587
        19.4.3  泛型lambda表达式   587
        19.4.4  lambda捕获表达式   587
        19.4.5  模板化lambda表达式   588
        19.4.6  lambda表达式作为返回类型   589
        19.4.7  未计算上下文中的lambda
        表达式   589
        19.4.8  默认构造、拷贝和赋值   589
        19.5  调用   590
        19.6  本章小结   590
        19.7  练习   590
        第20章  掌握标准库算法   593
        20.1  算法概述   593
        20.1.1  find()和find_if()算法   594
        20.1.2  accumulate()算法   596
        20.1.3  在算法中使用移动语义   597
        20.1.4  算法回调   597
        20.2  算法详解   598
        20.2.1  非修改序列算法   598
        20.2.2  修改序列算法   603
        20.2.3  操作算法   611
        20.2.4  分区算法   613
        20.2.5  排序算法   614
        20.2.6  二分查找算法   615
        20.2.7  集合算法   616
        20.2.8  最小/最大算法   618
        20.2.9  并行算法   619
        20.2.10  约束算法   620
        20.2.11  数值处理算法   621
        20.3  本章小结   622
        20.4  练习   622
        第21章  字符串的本地化与正则表达式   625
        21.1  本地化   625
        21.1.1  宽字符   625
        21.1.2  本地化字符串字面量   626
        21.1.3  非西方字符集   626
        21.1.4  locale和facet   628
        21.1.5  转换   631
        21.2  正则表达式   632
        21.2.1  ECMAScript语法   632
        21.2.2  regex库   637
        21.2.3  regex_match()   638
        21.2.4  regex_search()   640
        21.2.5  regex_iterator   641
        21.2.6  regex_token_iterator   642
        21.2.7  regex_replace()   644
        21.3  本章小结   646
        21.4  练习   646
        第22章  日期和时间工具   647
        22.1  编译期有理数   647
        22.2  持续时间   649
        22.3  时钟   653
        22.4  时间点   655
        22.5  日期   656
        22.6  时区   658
        22.7  本章小结   659
        22.8  练习   659
        第23章  随机数工具   661
        23.1  C风格随机数生成器   661
        23.1.1  随机数引擎   662
        23.1.2  随机数引擎适配器   663
        23.1.3  预定义的随机数引擎和
        引擎适配器   664
        23.1.4  生成随机数   664
        23.1.5  随机数分布   666
        23.2  本章小结   668
        23.3  练习   669
        第24章  其他库工具   671
        24.1  variant   671
        24.2  any   673
        24.3  元组   674
        24.3.1  分解元组   676
        24.3.2  串联   677
        24.3.3  比较   677
        24.3.4  make_from_tuple()   678
        24.3.5  apply()   678
        24.4  本章小结   678
        24.5  练习   678
        第IV部分  掌握C++的高级特性
        第25章  自定义和扩展标准库   683
        25.1  分配器   683
        25.2  扩展标准库   684
        25.2.1  扩展标准库的原因   685
        25.2.2  编写标准库算法   685
        25.2.3  编写标准库容器   686
        25.2.4  将directed_graph实现为
        标准库容器   696
        25.2.5  添加分配器支持   712
        25.2.6  改善graph_node   716
        25.2.7  附加的标准库类似功能   717
        25.2.8  进一步改善   719
        25.2.9  其他容器类型   719
        25.3  本章小结   720
        25.4  练习   720
        第26章  高级模板   721
        26.1  深入了解模板参数   721
        26.1.1  深入了解模板类型参数   721
        26.1.2  template template参数介绍   724
        26.1.3  深入了解非类型模板参数   725
        26.2  类模板部分特例化   727
        26.3  通过重载模拟函数部分特例化   730
        26.4  模板递归   731
        26.4.1  N维网格：初次尝试   731
        26.4.2  真正的N维网格   732
        26.5  可变参数模板   734
        26.5.1  类型安全的变长参数列表   734
        26.5.2  可变数目的混入类   736
        26.5.3  折叠表达式   737
        26.6  模板元编程   739
        26.6.1  编译时阶乘   739
        26.6.2  循环展开   740
        26.6.3  打印元组   741
        26.6.4  类型trait   744
        26.6.5  模板元编程结论   752
        26.7  本章小结   752
        26.8  练习   752
        第27章  C++多线程编程   753
        27.1  多线程编程概述   754
        27.1.1  争用条件   755
        27.1.2  撕裂   756
        27.1.3  死锁   756
        27.1.4  伪共享   757
        27.2  线程   757
        27.2.1  通过函数指针创建线程   758
        27.2.2  通过函数对象创建线程   759
        27.2.3  通过lambda创建线程   760
        27.2.4  通过成员函数创建线程   760
        27.2.5  线程本地存储   761
        27.2.6  取消线程   761
        27.2.7  自动join线程   761
        27.2.8  从线程获得结果   762
        27.2.9  复制和重新抛出异常   762
        27.3  原子操作库   764
        27.3.1  原子操作   766
        27.3.2  原子智能指针   767
        27.3.3  原子引用   767
        27.3.4  使用原子类型   767
        27.3.5  等待原子变量   769
        27.4  互斥   770
        27.4.1  互斥体类   770
        27.4.2  锁   772
        27.4.3  std::call_once   774
        27.4.4  互斥体对象的用法示例   776
        27.5  条件变量   779
        27.5.1  虚假唤醒   780
        27.5.2  使用条件变量   780
        27.6  latch   781
        27.7  barrier   782
        27.8  semaphore   782
        27.9  future   783
        27.9.1  std::promise和std::future   784
        27.9.2  std::packaged_task   784
        27.9.3  std::async   785
        27.9.4  异常处理   786
        27.9.5  std::shared_future   786
        27.10  示例：多线程的Logger类   787
        27.11  线程池   791
        27.12  协程   792
        27.13  线程设计和最佳实践   793
        27.14  本章小结   794
        27.15  练习   794
        第V部分  C++软件工程
        第28章  充分利用软件工程方法   799
        28.1  过程的必要性   799
        28.2  软件生命周期模型   800
        28.2.1  瀑布模型   800
        28.2.2  生鱼片模型   802
        28.2.3  螺旋类模型   802
        28.2.4  敏捷   804
        28.3  软件工程方法论   805
        28.3.1  UP   805
        28.3.2  RUP   806
        28.3.3  Scrum   806
        28.3.4  极限编程   808
        28.3.5  软件分流   812
        28.4  构建自己的过程和方法   812
        28.4.1  对新思想采取开放态度   812
        28.4.2  提出新想法   812
        28.4.3  知道什么行得通、什么行不通   812
        28.4.4  不要逃避   813
        28.5  源代码控制   813
        28.6  本章小结   814
        28.7  练习   814
        第29章  编写高效的C++程序   817
        29.1  性能和效率概述   817
        29.1.1  提升效率的两种方式   818
        29.1.2  两种程序   818
        29.1.3  C++是不是低效的语言   818
        29.2  语言层次的效率   818
        29.2.1  高效地操纵对象   819
        29.2.2  预分配内存   823
        29.2.3  使用内联方法和函数   823
        29.3  设计层次的效率   823
        29.3.1  尽可能多地缓存   823
        29.3.2  使用对象池   824
        29.4  剖析   829
        29.4.1  使用gprof的剖析示例   829
        29.4.2  使用Visual C++ 2019的剖析示例   836
        29.5  本章小结   838
        29.6  练习   838
        第30章  熟练掌握测试技术   841
        30.1  质量控制   841
        30.1.1  谁负责测试   842
        30.1.2  bug的生命周期   842
        30.1.3  bug跟踪工具   843
        30.2  单元测试   844
        30.2.1  单元测试方法   844
        30.2.2  单元测试过程   845
        30.2.3  实际中的单元测试   848
        30.3  模糊测试   855
        30.4  高级测试   855
        30.4.1  集成测试   855
        30.4.2  系统测试   856
        30.4.3  回归测试   857
        30.5  用于成功测试的建议   857
        30.6  本章小结   858
        30.7  练习   858
        第31章  熟练掌握调试技术   859
        31.1  调试的基本定律   859
        31.2  bug分类学   860
        31.3  避免bug   860
        31.4  为bug做好规划   861
        31.4.1  错误日志   861
        31.4.2  调试跟踪   862
        31.4.3  断言   869
        31.4.4  崩溃转储   870
        31.5  调试技术   870
        31.5.1  重现bug   870
        31.5.2  调试可重复的bug   871
        31.5.3  调试不可重现的bug   871
        31.5.4  调试退化   872
        31.5.5  调试内存问题   872
        31.5.6  调试多线程程序   876
        31.5.7  调试示例：文章引用   876
        31.5.8  从ArticleCitations示例中总结出的教训   887
        31.6  本章小结   887
        31.7  练习   887
        第32章  使用设计技术和框架   889
        32.1  容易忘记的语法   890
        32.1.1  编写类   890
        32.1.2  派生类   891
        32.1.3  编写lambda表达式   892
        32.1.4  使用“复制和交换”惯用语法   892
        32.1.5  抛出和捕捉异常   893
        32.1.6  写入文件   894
        32.1.7  读取文件   894
        32.1.8  写入类模板   895
        32.1.9  约束模板参数   895
        32.2  始终存在更好的方法   896
        32.2.1  RAII   896
        32.2.2  双分派   898
        32.2.3  混入类   902
        32.3  面向对象的框架   904
        32.3.1  使用框架   904
        32.3.2  MVC范型   905
        32.4  本章小结   906
        32.5  练习   906
        第33章  应用设计模式   907
        33.1  依赖注入   908
        33.1.1  示例：日志机制   908
        33.1.2  依赖注入logger的实现   908
        33.1.3  使用依赖注入   909
        33.2  抽象工厂模式   910
        33.2.1  示例：模拟汽车工厂   910
        33.2.2  实现抽象工厂   911
        33.2.3  使用抽象工厂   912
        33.3  工厂方法模式   913
        33.3.1  示例：模拟第二个汽车工厂   913
        33.3.2  实现工厂   914
        33.3.3  使用工厂   915
        33.3.4  工厂的其他类型   917
        33.3.5  工厂的其他用法   917
        33.4  适配器模式   918
        33.4.1  示例：适配Logger类   918
        33.4.2  实现适配器   919
        33.4.3  使用适配器   920
        33.5  代理模式   920
        33.5.1  示例：隐藏网络连接问题   920
        33.5.2  实现代理   921
        33.5.3  使用代理   922
        33.6  迭代器模式   922
        33.7  观察者模式   923
        33.7.1  示例：从主题中暴露事件   923
        33.7.2  实现观察者   923
        33.7.3  使用观察者   924
        33.8  装饰器模式   925
        33.8.1  示例：在网页中定义样式   926
        33.8.2  装饰器的实现   926
        33.8.3  使用装饰器   927
        33.9  责任链模式   928
        33.9.1  示例：事件处理   928
        33.9.2  实现责任链   928
        33.9.3  使用责任链   929
        33.10  单例模式   930
        33.10.1  日志记录机制   931
        33.10.2  实现单例   931
        33.10.3  使用单例   933
        33.11  本章小结   933
        33.12  练习   933
        第34章  开发跨平台和跨语言的应用程序   935
        34.1  跨平台开发   935
        34.1.1  架构问题   935
        34.1.2  实现问题   938
        34.1.3  平台专用功能   940
        34.2  跨语言开发   940
        34.2.1  混用C和C++   941
        34.2.2  改变范型   941
        34.2.3  链接C代码   944
        34.2.4  从C#调用C++代码   946
        34.2.5  C++/CLI在C++中使用C#代码和在C#中使用C++代码   947
        34.2.6  在Java中使用JNI调用C++代码   948
        34.2.7  从C++代码调用脚本   950
        34.2.8  从脚本调用C++代码   950
        34.2.9  从C++调用汇编代码   952
        34.3  本章小结   953
        34.4  练习   953
        第VI部分  附录
        附录A  C++面试   957
        在线资源(扫描封底二维码下载)
        附录B  标准库头文件   977
        附录C  UML简介   983
        附录D  带注解的参考文献   989
     · · · · · ·     (收起)"
30329536,数据密集型应用系统设计,9.7,(1709人评价),Martin Kleppmann / 赵军平、李三平、吕云松、耿煜 / 中国电力出版社 / 2018-9-1 / 128,"全书分为三大部分：
第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以...",https://book.douban.com/subject/30329536/,https://img1.doubanio.com/view/subject/s/public/s34186559.jpg,128,9787519821968,"全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方...(展开全部)





全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方式就是集成多个不同的数据库、缓存模块以及索引模块等。首先第10章以批处理开始来处理派生数据，紧接着第11章采用流式处理。第12章总结之前介绍的多种技术，并分析讨论未来构建可靠、可扩展和可维护应用系统可能的新方向或方法。","作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, ...(展开全部)




作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, Nvidia GPU Tech Conf等做技术分享，持续关注数据密集和计算密集相关技术的演进、融合与赋能推广。 吕云松，北京大学计算机硕士，硕士及DELL EMC中国研究院实习期间专注于大数据实时流式处理相关的研究。现就职于华为2012中软院黎曼实验室，主要从事深度学习的研发。 耿煜，DELL EMC架构师兼GTM负责人，致力于推广企业级数字化转型方案。深耕分布式架构以及云计算12年，先后任职于ChinaCache，Sun Microsystems以及EMC等公司。 李三平，美国麻省大学计算机工程专业博士，DELL EMC中国研究院首席科学家，研究方向为机器学习、深度学习、智能运维、遥感影像等。已在IEEE Transactions期刊和会议上发表论文数十篇，申请美国专利20余项。推崇简约，热衷机器学习。","前言 .....................................................1
        第一部分 数据系统基础
        第1章 可靠、可扩展与可维护的应用系统 ................... 11
        认识数据系统 ...........................................12
        可靠性 ..................................................14
        可扩展性 ................................................18
        可维护性 ................................................25
        小结 .....................................................28
        第2章 数据模型与查询语言 ............................... 33
        关系模型与文档模型 .......................................34
        数据查询语言 ...........................................46
        图状数据模型 ......................................52
        小结 ...................................................65
        第3章 数据存储与检索 .................................. 71
        数据库核心：数据结构 ...................................72
        事务处理与分析处理 ...................................89
        列式存储 .........................................94
        小结 ..............................................101
        第4章 数据编码与演化 .............................. 109
        数据编码格式 .................................... 110
        数据流模式 ......................................124
        小结 .............................................134
        第二部分 分布式数据系统
        第5章 数据复制 ................................. 145
        主节点与从节点 ..................................146
        复制滞后问题 ......................................154
        多主节点复制 .......................................160
        无主节点复制 .....................................168
        小结 ..............................................181
        第6章 数据分区 ............................... 189
        数据分区与数据复制 .................................190
        键-值数据的分区 ...................................190
        分区与二级索引 ...................................195
        分区再平衡 ....................................198
        请求路由 ..................................202
        小结 .................................204
        第7章 事务 .............................. 211
        深入理解事务 ......................................212
        弱隔离级别 .................................221
        串行化 ...........................................237
        小结 ...........................................250
        第8章 分布式系统的挑战 ...................... 259
        故障与部分失效 ...............................260
        不可靠的网络 ..................................262
        不可靠的时钟 ..................................271
        知识，真相与谎言 ...............................282
        小结 ..........................................292
        第9章 一致性与共识 ..................... 303
        一致性保证 ....................................304
        可线性化 ........................................305
        顺序保证 ........................................319
        分布式事务与共识 .................................330
        小结 ...............................................349
        第三部分 派生数据
        第10章 批处理系统 ................................ 367
        使用UNIX工具进行批处理 .............................368
        MapReduce与分布式文件系统 .........................375
        超越MapReduce ....................................394
        小结 ............................................403
        第11章 流处理系统 .............................. 413
        发送事件流 .......................................414
        数据库与流 .......................................424
        流处理 .........................................435
        小结 ............................................449
        第12章 数据系统的未来 ............................ 461
        数据集成 .........................................461
        分拆数据库 .......................................469
        端到端的正确性 ....................................484
        做正确的事情 .......................................500
        小结 ..............................................509
        术语表 ............................................ 521
     · · · · · ·     (收起)"
35144587,Go专家编程,9.1,(128人评价),任洪彩 / 电子工业出版社 / 2020-7 / 108.00元,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松...,https://book.douban.com/subject/35144587/,https://img3.doubanio.com/view/subject/s/public/s33699643.jpg,108.00元,9787121365577,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松地了解Go语言的内部运作机制。 本书首先介绍Go语言常见的数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者可以借此测验自身对该知识点的掌握程度。接着介绍了Go语言最基础的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了一些标准库、异常处理和依赖管理等非语法相关但非常重要的内容。最后结合作者的见闻，整理了一些发生在真实项目中的编程陷阱。,任洪彩，华为云原生团队核心成员，开源爱好者，深度参与CNCF（云原生计算基金会）旗下Kubernetes、Prometheus等项目贡献，Kubernetes资深成员，担任Kubernetes SIG-Instrumentation Approver，敏捷软件思想深度实践者，在Nokia、华为等公司参与过多个大型项目的研发与重构，对Go、C/C++、Python、Swift等语言均有深入的研究与实践。,"第1章　常见数据结构的实现原理
        1.1　管道
        1.1.1　热身测验
        1.1.2　特性速览
        1.1.3　实现原理
        1.2　slice
        1.2.1　热身测验
        1.2.2　特性速览
        1.2.3　实现原理
        1.2.4　切片表达式
        1.3　map
        1.3.1　热身测验
        1.3.2　特性速览
        1.3.3　实现原理
        1.4　struct
        1.4.1　热身测验
        1.4.2　内嵌字段
        1.4.3　方法受体
        1.4.4　字段标签
        1.5　iota
        1.5.1　热身测验
        1.5.2　特性速览
        1.5.3　实现原理
        1.6　string
        1.6.1　热身测验
        1.6.2　特性速览
        1.6.3　实现原理
        第2章　控制结构
        2.1　select
        2.1.1　热身测验
        2.1.2　特性速览
        2.1.3　实现原理
        2.2　for-range
        2.2.1　热身测验
        2.2.2　特性速览
        2.2.3　实现原理
        第3章　协程
        3.1　协程的概念
        3.2　调度模型
        3.3　调度策略
        第4章　内存管理
        4.1　内存分配
        4.2　垃圾回收
        4.3　逃逸分析
        第5章　并发控制
        5.1　channel
        5.2　WaitGroup
        5.3　context
        5.4　Mutex
        5.5　RWMutex
        5.5.1　读写锁的数据结构
        5.5.2　场景分析
        第6章　反射
        6.1　热身测验
        6.2　接口
        6.3　反射定律
        第7章　测试
        7.1　快速开始
        7.1.1　单元测试
        7.1.2　基准测试
        7.1.3　示例测试
        7.2　进阶测试
        7.2.1　子测试
        7.2.2　Main测试
        7.3　实现原理
        7.3.1　testing.common
        7.3.2　testing.TB接口
        7.3.3　单元测试的实现原理
        7.3.4　性能测试的实现原理
        7.3.5　示例测试的实现原理
        7.3.6　Main测试的实现原理
        7.3.7　go test的工作机制
        7.4　扩展阅读
        7.4.1　测试参数
        7.4.2　benchstat
        第8章　异常处理
        8.1　error
        8.1.1　热身测验
        8.1.2　基础error
        8.1.3　链式error
        8.1.4　工程迁移
        8.2　defer
        8.2.1　热身测验
        8.2.2　约法三章
        8.2.3　实现原理
        8.2.4　性能优化
        8.3　panic
        8.3.1　热身测验
        8.3.2　工作机制
        8.3.3　源码剖析
        8.4　recover
        8.4.1　热身测验
        8.4.2　工作机制
        8.4.3　源码剖析
        第9章　定时器
        9.1　一次性定时器（Timer）
        9.1.1　快速开始
        9.1.2　实现原理
        9.2　周期性定时器（Ticker）
        9.2.1　快速开始
        9.2.2　实现原理
        9.3　runtimeTimer
        9.3.1　实现原理
        9.3.2　性能优化
        9.4　案例分享
        第10章　语法糖
        10.1　简短变量声明符
        10.1.1　热身测验
        10.1.2　规则
        10.2　可变参函数
        第11章　版本管理
        11.1　安装Go
        11.2　删除Go
        11.3　升级Go
        11.4　Go版本管理器
        11.4.1　快速开始
        11.4.2　工作机制
        11.4.3　小结
        11.5　源码编译
        11.5.1　源码下载
        11.5.2　源码编译过程
        第12章　Go语言依赖管理
        12.1　GOPATH
        12.1.1　GOROOT是什么
        12.1.2　GOPATH是什么
        12.1.3　依赖查找
        12.1.4　GOPATH的缺点
        12.2　vendor
        12.2.1　vendor目录位置
        12.2.2　搜索顺序
        12.2.3　vendor的不足
        12.3　Go Module
        12.3.1　Go Module基础
        12.3.2　快速实践
        12.3.3　replace指令
        12.3.4　exclude指令
        12.3.5　indirect指令
        12.3.6　版本选择机制
        12.3.7　incompatible
        12.3.8　伪版本
        12.3.9　依赖包存储
        12.3.10　go.sum
        12.3.11　模块代理
        12.3.12　GOSUMDB的工作机制
        12.3.13　GOSUMDB的实现原理
        12.3.14　第三方代理
        12.3.15　私有模块
        12.3.16　Go Module的演进
        第13章　编程陷阱
        13.1　切片扩容
        13.2　空切片
        13.3　append的本质
        13.4　循环变量引用
        13.5　协程引用循环变量
        13.6　recover失效
     · · · · · ·     (收起)"
25844633,实现领域驱动设计,8.4,(416人评价),Vaughn Vernon / 滕云 / 电子工业出版社 / 2014-3 / 99.00元,领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如...,https://book.douban.com/subject/25844633/,https://img1.doubanio.com/view/subject/s/public/s29544670.jpg,99.00元,9787121224485,"领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为...(展开全部)





领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为一本DDD 参考书。",作者：Vaughn Vernon是一个经验丰富的软件工匠，在软件设计、开发和架构方面拥有超过25年的从业经验。他提倡通过创新来简化软件的设计和实现。从20世纪80年代开始，他便开始使用面向对象语言进行编程；在 20世纪 90年代早期，他便在领域建模中应用了领域驱动设计，那时他使用的是Smalltalk语言。他在很多业务领域都有从业经验，包括航空、环境、地理、保险、医学和电信等领域。同时，Vaughn在技术上也取得了很大的成功，包括开发可重用的框架和类库等。他在全球范围之内提供软件咨询和演讲，此外，他还在许多国家教授《实现领域驱动设计》的课程。你可以通过www.VaughnVernon.co访问到他的最新研究成果。他的Twitter：@VaughnVernon。,"序............... xix
        前言............. xxi
        致谢............ xxxi
        关于作者................... xxxv
        如何使用本书.........xxxvii
        第1章 DDD入门...............1
        我能DDD吗？..................2
        为什么我们需要DDD.............5
        如何DDD...................... 17
        使用DDD的业务价值..............22
        1.你获得了一个非常有用的领域模型................22
        2.你的业务得到了更准确的定义和理解............23
        3.领域专家可以为软件设计做出贡献...........23
        4.更好的用户体验....................23
        5.清晰的模型边界.....................24
        6.更好的企业架构..............24
        7.敏捷、迭代式和持续建模....................24
        8.使用战略和战术新工具........................24
        实施DDD所面临的挑战.....................25
        虚构的案例，真实的实践................... 33
        本章小结.........................36
        第2章 领域、子域和限界上下文.....................37
        总览....................... 37
        工作中的子域和限界上下文............................. 38
        将关注点放在核心域上............................. 42
        战略设计为什么重要.................... 45
        现实世界中领域和子域...................48
        理解限界上下文..................... 53
        限界上下文不仅仅只包含模型..................... 57
        限界上下文的大小...................... 59
        与技术组件保持一致................... 61
        示例上下文........................ 62
        协作上下文..................63
        身份与访问上下文..................69
        敏捷项目管理上下文................. 71
        本章小结....................................73
        第3章 上下文映射图............................75
        上下文映射图为什么重要........................ 75
        绘制上下文映射图......................77
        产品和组织关系........................79
        映射3个示例限界上下文........................82
        本章小结............................97
        第4章 架构.......................99
        采访一个成功的CIO.................... 100
        分层................................. 104
        依赖倒置原则.................... 107
        六边形架构（端口与适配器）..................... 110
        面向服务架构.......................114
        REST................................117
        REST作为一种架构风格...........................117
        RESTful HTTP服务器的关键方面 ........................................ 118
        RESTful HTTP客户端的关键方面 ........................................ 119
        REST和DDD..................... 120
        为什么是REST？......................... 121
        命令和查询职责分离——CQRS................. 121
        CQRS的各个方面........................ 123
        处理具有最终一致性的查询模型.................. 128
        事件驱动架构................... 129
        管道和过滤器..................... 131
        长时处理过程（也叫Saga）................... 134
        事件源...................... 140
        数据网织和基于网格的分布式计算....................... 143
        数据复制..................... 144
        事件驱动网织和领域事件.................. 145
        持续查询................... 145
        分布式处理...................... 146
        本章小结............................ 148
        第5章 实体......................... 149
        为什么使用实体......................... 149
        唯一标识............................ 151
        用户提供唯一标识......................... 152
        应用程序生成唯一标识........................... 153
        持久化机制生成唯一标识............................ 156
        另一个限界上下文提供唯一标识..................... 160
        标识生成时间..................... 161
        委派标识......................... 163
        标识稳定性.......................... 165
        发现实体及其本质特征............................. 167
        揭开实体及其本质特征的神秘面纱................. 168
        挖掘实体的关键行为.......................... 172
        角色和职责......................... 176
        创建实体......................... 181
        验证................................... 183
        跟踪变化............................ 192
        本章小结................................ 192
        第6章 值对象..................... 193
        值对象的特征.......................... 194
        度量或描述.......................... 195
        不变性........................... 195
        概念整体................................ 196
        可替换性.......................... 199
        值对象相等性..........................200
        无副作用行为............................. 201
        最小化集成..................204
        用值对象表示标准类型........................206
        测试值对象........................ 210
        实现.............................. 214
        持久化值对象................. 219
        拒绝由数据建模泄漏带来的不利影响..................220
        ORM与单个值对象................................ 221
        多个值对象序列化到单个列中.....................224
        使用数据库实体保存多个值对象....................225
        使用联合表保存多个值对象..........................229
        ORM与枚举状态对象........................................230
        本章小结....................... 233
        第7章 领域服务.................................235
        什么是领域服务（首先，什么不是领域服务）.................. 237
        请确定你是否需要一个领域服务................................ 238
        建模领域服务.................. 241
        独立接口有必要吗.............................244
        一个计算过程..........................246
        转换服务........................249
        为领域服务创建一个迷你层.........................250
        测试领域服务............................250
        本章小结.................. 253
        第8章 领域事件...............................255
        何时/为什么使用领域事件.......................... 255
        建模领域事件.................... 258
        创建具有聚合特征的领域事件................... 263
        身份标识............................264
        从领域模型中发布领域事件.............................. 265
        发送方................... 265
        订阅方.....................269
        向远程限界上下文发布领域事件............................. 271
        消息设施的一致性........................... 271
        自治服务和系统............................. 272
        容许时延.................. 273
        事件存储.................. 274
        转发存储事件的架构风格........................... 279
        以REST资源的方式发布事件通知....................... 279
        通过消息中间件发布事件通知.................. 283
        实现............................284
        发布NotificationLog............... 285
        发布基于消息的事件通知..............................290
        本章小结........................297
        第9章 模块................................299
        通过模块完成设计..................................299
        模块的基本命名规范..........................302
        领域模型的命名规范...........................302
        敏捷项目管理上下文中的模块..............................305
        其他层中的模块..................308
        先考虑模块，再是限界上下文...............................309
        本章小结......................... 310
        第10章 聚合...................... 311
        在Scrum核心领域中使用聚合........................ 312
        第一次尝试：臃肿的聚合....................... 313
        第二次尝试：多个聚合........................... 314
        原则：在一致性边界之内建模真正的不变条件................317
        原则：设计小聚合............................. 319
        不要相信每一个用例............................ 321
        原则：通过唯一标识引用其他聚合......................... 322
        通过标识引用使多个聚合协同工作 ...................................... 324
        建模对象导航性............................ 325
        可伸缩性和分布式............................. 326
        原则：在边界之外使用最终一致性............................. 327
        谁的任务？............................ 328
        打破原则的理由......................... 329
        理由之一：方便用户界面................................. 329
        理由之二：缺乏技术机制............................. 330
        理由之三：全局事务.......................................... 331
        理由之四：查询性能.................................. 331
        遵循原则.................... 332
        通过发现，深入理解............................... 332
        重新思考设计............................... 332
        估算聚合成本............................. 334
        常见用例场景........................ 335
        内存消耗............................ 336
        探索另外的设计................................... 337
        实现最终一致性.............................. 338
        这是Scrum团队成员的任务吗？......................... 339
        决定的时候到了.............................. 341
        实现........................................ 341
        创建具有唯一标识的根实体........................ 342
        优先使用值对象...................... 343
        使用迪米特法则和“告诉而非询问”原则 ...............344
        乐观并发...............346
        避免依赖注入................348
        本章小结................................ 349
        第11章 工厂................. 351
        领域模型中的工厂................. 351
        聚合根中的工厂方法............................. 352
        创建CalendarEntry实例................... 353
        创建Discussion实例............................ 357
        领域服务中的工厂.......................... 358
        本章小结.......................... 361
        第12章 资源库...........................363
        面向集合资源库...........................364
        Hibernate实现...................... 369
        TopLink实现.................... 377
        面向持久化资源库........................ 379
        Coherence实现............................ 381
        MongoDB实现......................... 386
        额外的行为...................................... 391
        管理事务................................. 393
        警告................................. 397
        类型层级............................... 397
        资源库 vs 数据访问对象（DAO）..............................400
        测试资源库.......................................... 401
        以内存实现进行测试...................404
        本章小结................................407
        第13章 集成限界上下文...............................409
        集成基础知识....................................409
        分布式系统之间存在根本性区别.......................411
        跨系统边界交换信息...............................411
        通过REST资源集成限界上下文......................... 417
        实现REST资源.......................... 418
        使用防腐层实现REST客户端........... 421
        通过消息集成限界上下文................ 428
        从Scrum的产品负责人和团队成员处得到持续通知 .................... 428
        你能处理这样的职责吗？..................... 434
        长时处理过程，以及避免职责............. 439
        长时处理过程的状态机和超时跟踪器 .................................. 450
        设计一个更复杂的长时处理过程 ..........................................460
        当消息机制或你的系统不可用时 ...........................................464
        本章小结.................................465
        第14章 应用程序..................467
        用户界面...................................469
        渲染领域对象............. 470
        渲染数据传输对象................... 471
        使用调停者发布聚合的内部状态 .......................................... 471
        通过领域负载对象渲染聚合实例 .......................................... 472
        聚合实例的状态展现............................. 473
        用例优化资源库查询...................... 474
        处理不同类型的客户端................... 474
        渲染适配器以及处理用户编辑............. 475
        应用服务 ............................................ 478
        示例应用服务 ................................ 478
        解耦服务输出 .....................485
        组合多个限界上下文 .....................487
        基础设施 ...............................489
        企业组件容器 ....................490
        本章小结 ....................494
        附录A 聚合与事件源：A+ES ..........................495
        应用服务内部 ....................... 496
        命令处理器 .....................505
        Lambda语法...................508
        并发控制 ....................... 510
        A+ES所带来的结构自由性 .............. 513
        性能 ............................ 513
        实现事件存储 ..................... 516
        关系型持久化 .................. 520
        BLOB持久化 ...................... 522
        专注的聚合 ............................ 523
        读模型投射 ........................... 524
        与聚合设计一道使用 ................ 527
        增强事件 ........................... 527
        工具和模式 ................... 529
        事件序列器 .......... 530
        事件不变性 ................ 531
        值对象 ..................... 531
        协议生成 .................... 534
        单元测试和需求规范 .............. 535
        事件源和函数式语言 .......... 536
        参考文献 ..................539
     · · · · · ·     (收起)"
30333919,架构整洁之道,8.7,(858人评价),【美】Robert C. Martin（罗伯特 C. 马丁） / 电子工业出版社 / 2018-9 / 99.00元,《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过...,https://book.douban.com/subject/30333919/,https://img9.doubanio.com/view/subject/s/public/s29943454.jpg,99.00元,9787121347962,"《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构...(展开全部)





《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构设计，还是软件研发管理，《架构整洁之道》都是不可或缺的。","Robert C·Martin
作者","第1部分  概述
        第1章  设计与架构究竟是什么  3
        目标是什么  4
        案例分析  5
        本章小结  11
        第2章  两个价值维度  12
        行为价值  13
        架构价值  13
        哪个价值维度更重要  14
        艾森豪威尔矩阵  15
        为好的软件架构而持续斗争  16
        第2部分  从基础构件开始：编程范式
        第3章  编程范式总览  21
        结构化编程  22
        面向对象编程  22
        函数式编程  23
        仅供思考  23
        本章小结  24
        第4章  结构化编程  25
        可推导性  26
        goto是有害的  28
        功能性降解拆分  29
        形式化证明没有发生  29
        科学来救场  29
        测试  30
        本章小结  31
        第5章  面向对象编程  32
        封装  33
        继承  36
        多态  38
        本章小结  44
        第6章  函数式编程  45
        整数平方  46
        不可变性与软件架构  47
        可变性的隔离  48
        事件溯源  49
        本章小结  51
        第3部分  设计原则
        第7章  SRP：单一职责原则  56
        反面案例2：代码合并  59
        解决方案  60
        本章小结  61
        第8章  OCP：开闭原则  62
        思想实验  63
        依赖方向的控制  67
        信息隐藏  67
        本章小结  67
        第9章  LSP：里氏替换原则  68
        继承的使用指导  69
        正方形/长方形问题  70
        LSP与软件架构  70
        违反LSP的案例  71
        本章小结  73
        第10章 ISP：接口隔离原则  74
        ISP与编程语言  76
        ISP与软件架构  76
        本章小结  77
        第11章 DIP：依赖反转原则  78
        稳定的抽象层  79
        工厂模式  80
        具体实现组件  82
        本章小结  82
        第4部分  组件构建原则
        第12章 组件  84
        组件发展史  85
        重定位技术  88
        链接器  88
        本章小结  90
        第13章 组件聚合  91
        复用/发布等同原则  92
        共同闭包原则  93
        共同复用原则  94
        组件聚合张力图  95
        本章小结  97
        第14章 组件耦合  98
        无依赖环原则  99
        自上而下的设计  105
        稳定依赖原则  106
        稳定抽象原则  112
        本章小结  117
        第5部分  软件架构
        第15章 什么是软件架构  120
        开发（Development）  122
        部署（Deployment）  123
        运行（Operation）  123
        维护（Maintenance）  124
        保持可选项  124
        设备无关性  126
        垃圾邮件  128
        物理地址寻址  129
        本章小结  130
        第16章 独立性  131
        用例  132
        运行  133
        开发  133
        部署  134
        保留可选项  134
        按层解耦  135
        用例的解耦  136
        解耦的模式  136
        开发的独立性  137
        部署的独立性  137
        重复  138
        再谈解耦模式  139
        本章小结  141
        第17章 划分边界  142
        几个悲伤的故事  143
        FitNesse  146
        应在何时、何处画这些线  148
        输入和输出怎么办  151
        插件式架构  152
        插件式架构的好处  153
        本章小结  154
        第18章 边界剖析  155
        跨边界调用  156
        令人生畏的单体结构  156
        部署层次的组件  158
        线程  159
        本地进程  159
        服务  160
        本章小结  161
        第19章 策略与层次  162
        层次（Level）  163
        本章小结  166
        第20章 业务逻辑  167
        业务实体  168
        用例  169
        请求和响应模型  171
        本章小结  172
        第21章 尖叫的软件架构  173
        架构设计的主题  174
        架构设计的核心目标  175
        那Web呢  175
        框架是工具而不是生活信条  175
        可测试的架构设计  176
        本章小结  176
        第22章 整洁架构  177
        依赖关系规则  179
        一个常见的应用场景  183
        本章小结  184
        第23章 展示器和谦卑对象  185
        谦卑对象模式  186
        展示器与视图  186
        测试与架构  187
        数据库网关  188
        数据映射器  188
        服务监听器  189
        本章小结  189
        第24章 不完全边界  190
        省掉最后一步  191
        单向边界  192
        门户模式  193
        本章小结  193
        第25章 层次与边界  194
        基于文本的冒险游戏：Hunt The Wumpus  195
        可否采用整洁架构  196
        交汇数据流  199
        数据流的分割  199
        本章小结  201
        第26章 Main组件  203
        最细节化的部分  204
        本章小结  208
        第27章 服务：宏观与微观  209
        面向服务的架构  210
        服务所带来的好处  210
        运送猫咪的难题  212
        对象化是救星  213
        基于组件的服务  215
        横跨型变更  216
        本章小结  216
        第28章 测试边界  217
        测试也是一种系统组件  218
        可测试性设计  219
        测试专用API  220
        本章小结  221
        第29章 整洁的嵌入式架构  222
        “程序适用测试”测试  225
        目标硬件瓶颈  228
        本章小结  238
        第6部分  实现细节
        第30章 数据库只是实现细节  240
        关系型数据库  241
        为什么数据库系统如此流行  242
        假设磁盘不存在会怎样  243
        实现细节  243
        但性能怎么办呢  244
        一段轶事  244
        本章小结  246
        第31章 Web是实现细节  247
        无尽的钟摆  248
        总结一下  250
        本章小结  251
        第32章 应用程序框架是实现细节  252
        框架作者  253
        单向婚姻  253
        风险  254
        解决方案  255
        不得不接受的依赖  255
        本章小结  256
        第33章 案例分析：视频销售网站  257
        产品  258
        用例分析  258
        组件架构  260
        依赖关系管理  261
        本章小结  262
        第34章 拾遗  263
        按层封装  264
        按功能封装  266
        端口和适配器  268
        按组件封装  270
        具体实现细节中的陷阱  274
        组织形式与封装的区别  275
        其他的解耦合模式  277
        本章小结：本书拾遗  279
        后序  280
        附录A  架构设计考古  283
     · · · · · ·     (收起)"
5387403,Effective C++,9.5,(1104人评价),[美] Scott Meyers / 侯捷 / 电子工业出版社 / 2011-1-1 / 65.00元,"在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。
作者高超的技术把握力、独特...",https://book.douban.com/subject/5387403/,https://img2.doubanio.com/view/subject/s/public/s4647091.jpg,65.00元,9787121123320,在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。 作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和仿效。 这本书不是读完一遍就可以束之高阁的快餐读物，也不是用以解决手边问题的参考手册，而是需要你去反复阅读体会的，C++是真正程序员的语言，背后有着精深的思想与无以伦比的表达能力，这使得它具有类似宗教般的魅力。,"侯捷
译者","译序
        中英简繁术语对照
        目录
        序言
        致谢
        导读
        1. 让自己习惯c++
        2. 构造/析构/赋值运算
        3. 资源管理
        4. 设计与声明
        5. 实现
        6. 继承与面向对象设计
        7. 模板与泛型编程
        8. 定制new和delete
        9. 杂项讨论
        a 本书之外
        b 新旧版条款对照
        索引
     · · · · · ·     (收起)"
35006892,程序员修炼之道（第2版）,9.1,(725人评价),[美] David Thomas、[美] Andrew Hunt / 云风 / 电子工业出版社 / 2020-4-1 / 89.00元,本书之所以在全球范围内广泛传播，被一代代开发者奉为圭臬，盖因它可以创造出真正的价值：或编写出更好的软件，或探究出编程的本质，而所有收获均不依赖于特定语言、框...,https://book.douban.com/subject/35006892/,https://img9.doubanio.com/view/subject/s/public/s33836286.jpg,89.00元,9787121384356,本书之所以在全球范围内广泛传播，被一代代开发者奉为圭臬，盖因它可以创造出真正的价值：或编写出更好的软件，或探究出编程的本质，而所有收获均不依赖于特定语言、框架和方法。时隔20年的新版，经过全面的重新选材、组织和编写，覆盖哲学、方法、工具、设计、解耦、并发、重构、需求、团队等务实话题的最佳实践及重大陷阱，以及易于改造、复用的架构技术。本书极具洞察力与趣味性，适合从初学者到架构师的各阶层读者潜心研读或增广见闻。,"云风
译者","序
        新版前言
        第一版前言
        提示1 关注你的技艺
        提示2 思考！思考你的工作
        第1章 务实的哲学
        1 人生是你的
        提示3 你有权选择
        2 我的源码被猫吃了
        提示4 提供选择，别找借口
        3 软件的熵
        提示5 不要放任破窗
        4 石头做的汤和煮熟的青蛙
        提示6 做推动变革的催化剂
        提示7 牢记全景
        5 够好即可的软件
        提示8 将质量要求视为需求问题
        6 知识组合
        提示9 对知识组合做定期投资
        提示10 批判性地分析你读到和听到的东西
        7 交流！
        提示11 英语就是另一门编程语言
        提示12 说什么和怎么说同样重要
        提示13 把文档嵌进去，而不要栓在表面
        第2章 务实的方法
        8 优秀设计的精髓
        提示14 优秀的设计比糟糕的设计更容易变更
        9 DRY ——邪恶的重复
        提示15 DRY——不要重复自己
        提示16 让复用变得更容易
        10 正交性
        提示17 消除不相关事物之间的影响
        11 可逆性
        提示18 不设最终决定
        提示19 放弃追逐时尚
        12 曳光弹
        提示20 使用曳光弹找到目标
        13 原型与便签
        提示21 用原型学习
        14 领域语言
        提示22 靠近问题域编程
        15 估算
        提示23 通过估算来避免意外
        提示24 根据代码不断迭代进度表
        第3章 基础工具
        16 纯文本的威力
        提示25 将知识用纯文本保存
        17 Shell游戏
        提示26 发挥 Shell 命令的威力
        18 加强编辑能力
        提示27 游刃有余地使用编辑器
        19 版本控制
        提示28 永远使用版本控制
        20 调试
        提示29 去解决问题，而不是责备
        提示30 不要恐慌
        提示31 修代码前先让代码在测试中失败
        提示32 读一下那些该死的出错信息
        提示33 “select”没出问题
        提示34 不要假设，要证明
        21 文本处理
        提示35 学习一门文本处理语言
        22 工程日记
        第4章 务实的偏执
        提示36 你无法写出完美的软件
        23 契约式设计
        提示37 通过契约进行设计
        24 死掉的程序不会说谎
        提示38 尽早崩溃
        25 断言式编程
        提示39 使用断言去预防不可能的事情
        26 如何保持资源的平衡
        提示40 有始有终
        提示41 在局部行动
        27 不要冲出前灯范围
        提示42 小步前进——由始至终
        提示43 避免占卜
        第5章 宁弯不折
        28 解耦
        提示44 解耦代码让改变更容易
        提示45 只管命令不要询问
        提示46 不要链式调用方法
        提示47 避免全局数据
        提示48 如果全局唯一非常重要，那么将它包装到API 中
        29 在现实世界中抛球杂耍
        30 变换式编程
        提示49 编程讲的是代码，而程序谈的是数据
        提示50 不要囤积状态，传递下去
        31 继承税
        提示51 不要付继承税
        提示52 尽量用接口来表达多态
        提示53 用委托提供服务：“有一个”胜过“是一个”
        提示54 利用 mixin 共享功能
        32 配置
        提示55 使用外部配置参数化应用程序
        第6章 并发
        33 打破时域耦合
        提示56 通过分析工作流来提高并发性
        34 共享状态是不正确的状态
        提示57 共享状态是不正确的状态
        提示58 随机故障通常是并发问题
        35 角色与进程
        提示59 用角色实现并发性时不必共享状态
        36 黑板
        提示60 使用黑板来协调工作流
        第7章 当你编码时
        37 听从蜥蜴脑
        提示61 倾听你内心的蜥蜴
        38 巧合式编程
        提示62 不要依赖巧合编程
        39 算法速度
        提示63 评估算法的级别
        提示64 对估算做测试
        40 重构
        提示65 尽早重构，经常重构
        41 为编码测试
        提示66 测试与找 Bug 无关
        提示67 测试是代码的第一个用户
        提示68 既非自上而下，也不自下而上，基于端对端构建
        提示69 为测试做设计
        提示70 要对软件做测试，否则只能留给用户去做
        42 基于特性测试
        提示71 使用基于特性的测试来校验假设
        43 出门在外注意安全
        提示72 保持代码简洁，让攻击面最小
        提示73 尽早打上安全补丁
        44 事物命名
        提示74 好好取名；需要时更名
        第8章 项目启动之前
        45 需求之坑
        提示75 无人确切知道自己想要什么
        提示76 程序员帮助人们理解他们想要什么
        提示77 需求是从反馈循环中学到的
        提示78 和用户一起工作以便从用户角度思考
        提示79 策略即元数据
        提示80 使用项目术语表
        46 处理无法解决的难题
        提示81 不要跳出框框思考——找到框框
        47 携手共建
        提示82 不要一个人埋头钻进代码中
        48 敏捷的本质
        提示83 敏捷不是一个名词；敏捷有关你如何做事
        第9章 务实的项目
        49 务实的团队
        提示84 维持小而稳定的团队
        提示85 排上日程以待其成
        提示86 组织全功能的团队
        50 椰子派不上用场
        提示87 做能起作用的事，别赶时髦
        提示88 在用户需要时交付
        51 务实的入门套件
        提示89 使用版本控制来驱动构建、测试和发布
        提示90 尽早测试，经常测试，自动测试
        提示91 直到所有的测试都已运行，编码才算完成
        提示92 使用破坏者检测你的测试
        提示93 测试状态覆盖率，而非代码覆盖率
        提示94 每个 Bug 只找一次
        提示95 不要使用手动程序
        52 取悦用户
        提示96 取悦用户，而不要只是交付代码
        53 傲慢与偏见
        提示97 在作品上签名
        跋
        提示98 先勿伤害
        提示99 不要助纣为虐
        参考文献
        练习的参考答案
        译者跋
     · · · · · ·     (收起)"
36547630,Rust程序设计（第2版）,9.3,(33人评价),[美]吉姆·布兰迪（Jim Blandy）、[美]贾森 • 奥伦多夫（Jason Orendorff）、[美]莉奥诺拉 • F. S. 廷德尔（Leonora F. S. Tindall） / 汪志成（@雪狼） / 人民邮电出版社 / 2023-9-5 / 179.8元,"本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。
书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的...",https://book.douban.com/subject/36547630/,https://img3.doubanio.com/view/subject/s/public/s34641512.jpg,179.8元,9787115621818,"本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。 书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的高性能，并大大简化了并发程序的编写。第2版对上一版内容进行了重组和完善，新增了对“异步编程”的介绍。借助书中的大量案例，你也能用Rust编写出兼顾安全性与高性能的程序。本书内容包括基本数据类型、所有权、引用、表达式、错误处理、crate与模块、结构、枚举与模式等基础知识，以及特型与泛型、闭包、迭代器、集合、字符串与文本、输入与输出、并发、异步编程、宏等进阶知识。 编辑推荐 1.【内容全面】Rust一本就通，涉及Rust所有关键特性 2.【代码开源】基于Rust 2021大版本，开源示例代码 3.【实战性强】讲解深入浅出，含大量案例，实践性强 4.【作译者资深】Mozilla创始团员编写，雪狼翻译 ...(展开全部)





本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。 书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的高性能，并大大简化了并发程序的编写。第2版对上一版内容进行了重组和完善，新增了对“异步编程”的介绍。借助书中的大量案例，你也能用Rust编写出兼顾安全性与高性能的程序。本书内容包括基本数据类型、所有权、引用、表达式、错误处理、crate与模块、结构、枚举与模式等基础知识，以及特型与泛型、闭包、迭代器、集合、字符串与文本、输入与输出、并发、异步编程、宏等进阶知识。 编辑推荐 1.【内容全面】Rust一本就通，涉及Rust所有关键特性 2.【代码开源】基于Rust 2021大版本，开源示例代码 3.【实战性强】讲解深入浅出，含大量案例，实践性强 4.【作译者资深】Mozilla创始团员编写，雪狼翻译 5.【专家推荐】陈天、唐刚、王旭、张汉东、张炎泼 6.【超强品控】30位一线Rust开发者与爱好者精心审读",吉姆·布兰迪（Jim Blandy），Mozilla Firefox工程师，Subversion版本控制系统最初设计者之一。拥有40多年编程经验，其中包括30多年自由软件开发经验，曾在GNU Emacs、GNU Debugger等项目上工作。 贾森·奥伦多夫（Jason Orendorff），GitHub工程师，专注开发尚未公开的Rust项目，曾在Mozilla参与JavaScript引擎SpiderMonkey的开发。兴趣广泛，包括：语法学、烘焙、时间旅行，以及帮助人们理解复杂主题。 莉奥诺拉·F. S. 廷德尔（Leonora F. S. Tindall），软件工程师、类型系统爱好者。她喜欢使用Rust等先进语言在一些关键领域构建健壮且适应性强的系统软件，特别是在医疗保健和数据所有权管理等领域。,"目录
        专家推荐
        译者序
        前言
        中文版审读致谢
        第 1章　系统程序员也能享受美好 1
        1.1　Rust为你负重前行 2
        1.2　高效并行编程 3
        1.3　性能毫不妥协 3
        1.4　协作无边无界 4
        第 2章　Rust导览 5
        2.1　rustup与Cargo 6
        2.2　Rust函数 8
        2.3　编写与运行单元测试 9
        2.4　处理命令行参数 10
        2.5　搭建Web服务器 13
        2.6　并发 18
        2.6.1　什么是曼德博集 19
        2.6.2　解析并配对命令行参数 22
        2.6.3　从像素到复数的映射 24
        2.6.4　绘制曼德博集 25
        2.6.5　写入图像文件 26
        2.6.6　并发版曼德博程序 27
        2.6.7　运行曼德博绘图器 32
        2.6.8　大“安”无形 33
        2.7　文件系统与命令行工具 33
        2.7.1　命令行界面 34
        2.7.2　读写文件 36
        2.7.3　查找并替换 37
        第3章　基本数据类型 39
        3.1　固定宽度的数值类型 41
        3.1.1　整型 42
        3.1.2　检查算法、回绕算法、饱和算法和溢出算法 45
        3.1.3　浮点类型 46
        3.2　布尔类型 48
        3.3　字符 49
        3.4　元组 50
        3.5　指针类型 51
        3.5.1　引用 52
        3.5.2　Box 52
        3.5.3　裸指针 53
        3.6　数组、向量和切片 53
        3.6.1　数组 53
        3.6.2　向量 54
        3.6.3　切片 57
        3.7　字符串类型 58
        3.7.1　字符串字面量 58
        3.7.2　字节串 59
        3.7.3　内存中的字符串 60
        3.7.4　String 61
        3.7.5　使用字符串 62
        3.7.6　其他类似字符串的类型 62
        3.8　类型别名 63
        3.9　前路展望 63
        第4章　所有权与移动 64
        4.1　所有权 65
        4.2　移动 70
        4.2.1　更多移动类操作 74
        4.2.2　移动与控制流 75
        4.2.3　移动与索引内容 75
        4.3　Copy类型：关于移动的例外情况 77
        4.4　Rc与Arc：共享所有权 80
        第5章　引用 83
        5.1　对值的引用 84
        5.2　使用引用 86
        5.2.1　Rust引用与C++引用 87
        5.2.2　对引用变量赋值 88
        5.2.3　对引用进行引用 88
        5.2.4　比较引用 89
        5.2.5　引用永不为空 89
        5.2.6　借用任意表达式结果值的引用 89
        5.2.7　对切片和特型对象的引用 90
        5.3　引用安全 90
        5.3.1　借用局部变量 91
        5.3.2　将引用作为函数参数 93
        5.3.3　把引用传给函数 95
        5.3.4　返回引用 95
        5.3.5　包含引用的结构体 96
        5.3.6　不同的生命周期参数 98
        5.3.7　省略生命周期参数 100
        5.4　共享与可变 101
        5.5　应对复杂对象关系 107
        第6章　表达式 109
        6.1　表达式语言 109
        6.2　优先级与结合性 110
        6.3　块与分号 112
        6.4　声明 113
        6.5　if与match 115
        6.5.1　if let 117
        6.5.2　循环 117
        6.6　循环中的控制流 119
        6.7　return表达式 120
        6.8　为什么Rust中会有loop 121
        6.9　函数与方法调用 122
        6.10　字段与元素 123
        6.11　引用运算符 124
        6.12　算术运算符、按位运算符、比较运算符和逻辑运算符 125
        6.13　赋值 125
        6.14　类型转换 126
        6.15　闭包 127
        6.16　前路展望 127
        第7章　错误处理 128
        7.1　panic 128
        7.1.1　展开调用栈 129
        7.1.2　中止 130
        7.2　Result 130
        7.2.1　捕获错误 131
        7.2.2　Result类型别名 132
        7.2.3　打印错误 132
        7.2.4　传播错误 134
        7.2.5　处理多种Error类型 135
        7.2.6　处理“不可能发生”的错误 136
        7.2.7　忽略错误 138
        7.2.8　处理main()中的错误 138
        7.2.9　声明自定义错误类型 139
        7.2.10　为什么是Result 140
        第8章　crate与模块 141
        8.1　crate 141
        8.1.1　版本 144
        8.1.2　创建配置文件 145
        8.2　模块 145
        8.2.1　嵌套模块 146
        8.2.2　单独文件中的模块 147
        8.2.3　路径与导入 149
        8.2.4　标准库预导入 152
        8.2.5　公开use声明 152
        8.2.6　公开结构体字段 152
        8.2.7　静态变量与常量 153
        8.3　将程序变成库 153
        8.4　src/bin目录 155
        8.5　属性 156
        8.6　测试与文档 158
        8.6.1　集成测试 161
        8.6.2　文档 161
        8.6.3　文档测试 163
        8.7　指定依赖项 166
        8.7.1　版本 166
        8.7.2　Cargo.lock 167
        8.8　将crate发布到crates.io 168
        8.9　工作空间 170
        8.10　更多好资源 170
        第9章　结构体 172
        9.1　具名字段型结构体 172
        9.2　元组型结构体 175
        9.3　单元型结构体 175
        9.4　结构体布局 176
        9.5　用impl定义方法 177
        9.5.1　以Box、Rc或Arc形式传入self 179
        9.5.2　类型关联函数 179
        9.6　关联常量 180
        9.7　泛型结构体 181
        9.8　带生命周期参数的泛型结构体 183
        9.9　带常量参数的泛型结构体 183
        9.10　让结构体类型派生自某些公共特型 185
        9.11　内部可变性 186
        第 10章　枚举与模式 190
        10.1　枚举 191
        10.1.1　带数据的枚举 193
        10.1.2　内存中的枚举 194
        10.1.3　用枚举表示富数据结构 194
        10.1.4　泛型枚举 196
        10.2　模式 198
        10.2.1　模式中的字面量、变量和通配符 201
        10.2.2　元组型模式与结构体型模式 202
        10.2.3　数组型模式与切片型模式 203
        10.2.4　引用型模式 204
        10.2.5　匹配守卫 206
        10.2.6　匹配多种可能性 206
        10.2.7　使用@模式绑定 207
        10.2.8　模式能用在哪里 207
        10.2.9　填充二叉树 209
        10.3　大局观 210
        第 11章　特型与泛型 211
        11.1　使用特型 213
        11.1.1　特型对象 214
        11.1.2　泛型函数与类型参数 215
        11.1.3　使用哪一个 219
        11.2　定义与实现特型 220
        11.2.1　默认方法 221
        11.2.2　特型与其他人的类型 222
        11.2.3　特型中的Self 224
        11.2.4　子特型 225
        11.2.5　类型关联函数 226
        11.3　完全限定的方法调用 227
        11.4　定义类型之间关系的特型 228
        11.4.1　关联类型（或迭代器的工作原理） 229
        11.4.2　泛型特型（或运算符重载的工作原理） 231
        11.4.3　impl Trait 232
        11.4.4　关联常量 234
        11.5　逆向工程求限界 235
        11.6　以特型为基础 238
        第 12章　运算符重载 239
        12.1　算术运算符与按位运算符 240
        12.1.1　一元运算符 242
        12.1.2　二元运算符 243
        12.1.3　复合赋值运算符 244
        12.2　相等性比较 245
        12.3　有序比较 247
        12.4　Index与IndexMut 250
        12.5　其他运算符 252
        第 13章　实用工具特型 253
        13.1　Drop 254
        13.2　Sized 256
        13.3　Clone 259
        13.4　Copy 260
        13.5　Deref与DerefMut 260
        13.6　Default 263
        13.7　AsRef与AsMut 264
        13.8　Borrow与BorrowMut 266
        13.9　From与Into 267
        13.10　TryFrom与TryInto 270
        13.11　ToOwned 271
        13.12　Borrow与ToOwned的实际运用：谦卑的Cow 271
        第 14章　闭包 273
        14.1　捕获变量 274
        14.1.1　借用值的闭包 275
        14.1.2　“窃取”值的闭包 275
        14.2　函数与闭包的类型 277
        14.3　闭包性能 279
        14.4　闭包与安全 280
        14.4.1　“杀死”闭包 280
        14.4.2　FnOnce 281
        14.4.3　FnMut 282
        14.4.4　对闭包的Copy与Clone 284
        14.5　回调 285
        14.6　高效地使用闭包 288
        第 15章　迭代器 290
        15.1　Iterator特型与IntoIterator特型 291
        15.2　创建迭代器 292
        15.2.1　iter方法与iter_mut方法 293
        15.2.2　IntoIterator的实现 293
        15.2.3　from_fn与successors 295
        15.2.4　drain方法 296
        15.2.5　其他迭代器源 297
        15.3　迭代器适配器 298
        15.3.1　map与filter 298
        15.3.2　filter_map与flat_map 300
        15.3.3　flatten 302
        15.3.4　take与take_while 304
        15.3.5　skip与skip_while 305
        15.3.6　peekable 305
        15.3.7　fuse 306
        15.3.8　可逆迭代器与rev 307
        15.3.9　inspect 308
        15.3.10　chain 309
        15.3.11　enumerate 309
        15.3.12　zip 310
        15.3.13　by_ref 310
        15.3.14　cloned与copied 311
        15.3.15　cycle 312
        15.4　消耗迭代器 313
        15.4.1　简单累加：count、sum和product 313
        15.4.2　min与max 313
        15.4.3　max_by与min_by 314
        15.4.4　max_by_key与min_by_key 314
        15.4.5　对条目序列进行比较 315
        15.4.6　any与all 315
        15.4.7　position、rposition和ExactSizeIterator 316
        15.4.8　fold与rfold 316
        15.4.9　try_fold与try_rfold 317
        15.4.10　nth与nth_back 318
        15.4.11　last 319
        15.4.12　find、rfind和find_map 319
        15.4.13　构建集合：collect与FromIterator 320
        15.4.14　Extend特型 322
        15.4.15　partition 322
        15.4.16　for_each与try_for_each 323
        15.5　实现自己的迭代器 324
        第 16章　集合 328
        16.1　概述 329
        16.2　Vec&lt;T> 330
        16.2.1　访问元素 331
        16.2.2　迭代 332
        16.2.3　扩大向量与收缩向量 332
        16.2.4　联结 336
        16.2.5　拆分 336
        16.2.6　交换 339
        16.2.7　填充 339
        16.2.8　排序与搜索 339
        16.2.9　比较切片 341
        16.2.10　随机元素 341
        16.2.11　Rust中不存在失效型错误 342
        16.3　VecDeque&lt;T> 343
        16.4　BinaryHeap&lt;T> 344
        16.5　HashMap&lt;K, V>与BTreeMap&lt;K, V> 346
        16.5.1　条目 349
        16.5.2　对Map进行迭代 351
        16.6　HashSet&lt;T>与BTreeSet&lt;T> 351
        16.6.1　对Set进行迭代 352
        16.6.2　当相等的值不完全相同时 353
        16.6.3　针对整个Set的运算 353
        16.7　哈希 354
        16.8　使用自定义哈希算法 355
        16.9　在标准集合之外 357
        第 17章　字符串与文本 358
        17.1　一些Unicode背景知识 358
        17.1.1　ASCII、Latin-1和Unicode 359
        17.1.2　UTF-8编码 359
        17.1.3　文本方向性 361
        17.2　字符（char） 361
        17.2.1　字符分类 361
        17.2.2　处理数字 362
        17.2.3　字符大小写转换 363
        17.2.4　与整数之间的转换 364
        17.3　String与str 364
        17.3.1　创建字符串值 365
        17.3.2　简单探查 366
        17.3.3　追加文本与插入文本 366
        17.3.4　移除文本与替换文本 368
        17.3.5　搜索与迭代的约定 368
        17.3.6　搜索文本的模式 369
        17.3.7　搜索与替换 370
        17.3.8　遍历文本 371
        17.3.9　修剪 373
        17.3.10　字符串的大小写转换 374
        17.3.11　从字符串中解析出其他类型 374
        17.3.12　将其他类型转换为字符串 374
        17.3.13　借用其他类似文本的类型 375
        17.3.14　以UTF-8格式访问文本 376
        17.3.15　从UTF-8数据生成文本 376
        17.3.16　推迟分配 377
        17.3.17　把字符串当作泛型集合 379
        17.4　格式化各种值 379
        17.4.1　格式化文本值 380
        17.4.2　格式化数值 381
        17.4.3　格式化其他类型 383
        17.4.4　格式化值以进行调试 383
        17.4.5　格式化指针以进行调试 384
        17.4.6　按索引或名称引用参数 385
        17.4.7　动态宽度与动态精度 386
        17.4.8　格式化自己的类型 386
        17.4.9　在自己的代码中使用格式化语言 388
        17.5　正则表达式 389
        17.5.1　Regex的基本用法 389
        17.5.2　惰性构建正则表达式值 390
        17.6　规范化 391
        17.6.1　规范化形式 392
        17.6.2　unicode-normalization crate 393
        第 18章　输入与输出 395
        18.1　读取器与写入器 396
        18.1.1　读取器 397
        18.1.2　缓冲读取器 398
        18.1.3　读取行 399
        18.1.4　收集行 401
        18.1.5　写入器 402
        18.1.6　文件 403
        18.1.7　寻址 404
        18.1.8　其他读取器与写入器类型 404
        18.1.9　二进制数据、压缩和序列化 406
        18.2　文件与目录 407
        18.2.1　OsStr与Path 408
        18.2.2　Path与PathBuf的方法 409
        18.2.3　访问文件系统的函数 411
        18.2.4　读取目录 412
        18.2.5　特定于平台的特性 413
        18.3　网络 414
        第 19章　并发 417
        19.1　分叉与合并并行 418
        19.1.1　启动与联结 420
        19.1.2　跨线程错误处理 422
        19.1.3　跨线程共享不可变数据 422
        19.1.4　rayon 424
        19.1.5　重温曼德博集 426
        19.2　通道 427
        19.2.1　发送值 429
        19.2.2　接收值 431
        19.2.3　运行管道 432
        19.2.4　通道的特性与性能 434
        19.2.5　线程安全：Send与Sync 435
        19.2.6　绝大多数迭代器能通过管道传给通道 437
        19.2.7　除管道之外的用法 438
        19.3　共享可变状态 439
        19.3.1　什么是互斥锁 439
        19.3.2　Mutex&lt;T> 440
        19.3.3　mut与互斥锁 442
        19.3.4　为什么互斥锁不是“银弹” 443
        19.3.5　死锁 443
        19.3.6　“中毒”的互斥锁 444
        19.3.7　使用互斥锁的多消费者通道 444
        19.3.8　读/写锁（RwLock&lt;T>） 445
        19.3.9　条件变量（Condvar） 446
        19.3.10　原子化类型 447
        19.3.11　全局变量 448
        19.4　在Rust中编写并发代码的一点儿经验 451
        第 20章　异步编程 452
        20.1　从同步到异步 453
        20.1.1　Future 455
        20.1.2　异步函数与await表达式 456
        20.1.3　从同步代码调用异步函数：block_on 458
        20.1.4　启动异步任务 460
        20.1.5　异步块 464
        20.1.6　从异步块构建异步函数 466
        20.1.7　在线程池中启动异步任务 467
        20.1.8　你的Future实现Send了吗 467
        20.1.9　长时间运行的计算：yield_now与spawn_blocking 470
        20.1.10　对几种异步设计进行比较 471
        20.1.11　一个真正的异步HTTP客户端 471
        20.2　异步客户端与服务器 472
        20.2.1　Error类型与Result类型 474
        20.2.2　协议 474
        20.2.3　获取用户输入：异步流 475
        20.2.4　发送数据包 477
        20.2.5　接收数据包：更多异步流 478
        20.2.6　客户端的main函数 480
        20.2.7　服务器的main函数 481
        20.2.8　处理聊天连接：异步互斥锁 482
        20.2.9　群组表：同步互斥锁 484
        20.2.10　聊天组：tokio的广播通道 485
        20.3　原始Future与执行器：Future什么时候值得再次轮询 488
        20.3.1　调用唤醒器：spawn_blocking 489
        20.3.2　实现block_on 491
        20.4　固定（Pin） 493
        20.4.1　Future生命周期的两个阶段 493
        20.4.2　固定指针 496
        20.4.3　Unpin特型 497
        20.5　什么时候要用异步代码 498
        第 21章　宏 500
        21.1　宏基础 501
        21.1.1　宏展开的基础 502
        21.1.2　意外后果 503
        21.1.3　重复 505
        21.2　内置宏 507
        21.3　调试宏 508
        21.4　构建json!宏 509
        21.4.1　片段类型 510
        21.4.2　宏中的递归 513
        21.4.3　将特型与宏一起使用 514
        21.4.4　作用域界定与卫生宏 516
        21.4.5　导入宏和导出宏 518
        21.5　在匹配过程中避免语法错误 519
        21.6　超越macro_rules! 520
        第 22章　不安全代码 522
        22.1　不安全因素来自哪里 523
        22.2　不安全块 524
        22.3　示例：高效的ASCII字符串类型 525
        22.4　不安全函数 527
        22.5　不安全块还是不安全函数 528
        22.6　未定义行为 529
        22.7　不安全特型 531
        22.8　裸指针 532
        22.8.1　安全地解引用裸指针 534
        22.8.2　示例：RefWithFlag 535
        22.8.3　可空指针 537
        22.8.4　类型大小与对齐方式 537
        22.8.5　指针运算 538
        22.8.6　移动入和移动出内存 539
        22.8.7　示例：GapBuffer 542
        22.8.8　不安全代码中的panic安全性 548
        22.9　用联合体重新解释内存 549
        22.10　匹配联合体 551
        22.11　借用联合体 551
        第 23章　外部函数 552
        23.1　寻找共同的数据表示 552
        23.2　声明外部函数与变量 556
        23.3　使用库中的函数 557
        23.4　libgit2的裸接口 560
        23.5　libgit2的安全接口 566
        23.6　结论 575
        作者介绍 576
        封面介绍 576
     · · · · · ·     (收起)"
36457109,程序员的README,8.6,(95人评价),[美] 克里斯·里科米尼（Chris Riccomini）、[美] 德米特里·里亚博伊（Dmitriy Ryaboy） / 付裕 / 人民邮电出版社 / 2023-7-10 / 79.8,对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填...,https://book.douban.com/subject/36457109/,https://img9.doubanio.com/view/subject/s/public/s34570616.jpg,79.8,9787115599438,"对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新...(展开全部)





对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新入行的工程师在开始工作之前都能阅读的书。","付裕
译者","第1 章 前面的旅程 1
        1.1 你的目的地 1
        1.2 你的旅程地图 2
        1.2.1 新手营 3
        1.2.2 试炼之河 5
        1.2.3 贡献者之角 5
        1.2.4 运维之海 6
        1.2.5 胜任之湾 6
        1.3 前进！ 7
        第2 章 步入自觉阶段 8
        2.1 学习如何学习 9
        2.1.1 前置学习 9
        2.1.2 在实践中学习 9
        2.1.3 运行实例代码 11
        2.1.4 阅读 11
        2.1.5 观看讲座 13
        2.1.6 适度地参加会议和聚会 14
        2.1.7 跟班学习并同有经验的工程师结对 15
        2.1.8 用副业项目实践 16
        2.2 提出问题 17
        2.2.1 动手调查一下 17
        2.2.2 设置一个时间限制 17
        2.2.3 写下全过程 18
        2.2.4 别打扰别人 19
        2.2.5 多用“非打扰式”交流 20
        2.2.6 批量处理你的同步请求 20
        2.3 克服成长的障碍 21
        2.3.1 冒充者综合征 21
        2.3.2 邓宁-克鲁格效应 22
        2.4 行为准则 23
        2.5 升级加油站 23
        第3 章 玩转代码 25
        3.1 软件的熵 26
        3.2 技术债 26
        3.3 变更代码 29
        3.3.1 善于利用现有代码 30
        3.3.2 过手的代码要比之前更干净 32
        3.3.3 做渐变式的修改 33
        3.3.4 对重构要务实 33
        3.3.5 善用IDE 34
        3.3.6 请使用VCS 的最佳实践 34
        3.4 避“坑”指南 35
        3.4.1 保守一些的技术选型 36
        3.4.2 不要特立独行 39
        3.4.3 不要只分叉而不向上游提交修改 40
        3.4.4 克制重构的冲动 40
        3.5 行为准则 42
        3.6 升级加油站 42
        第4 章 编写可维护的代码 44
        4.1 防御式编程 45
        4.1.1 避免空值 45
        4.1.2 保持变量不可变 46
        4.1.3 使用类型提示和静态类型检查器 46
        4.1.4 验证输入 47
        4.1.5 善用异常 49
        4.1.6 异常要有精确含义 50
        4.1.7 早抛晚捕 51
        4.1.8 智能重试 52
        4.1.9 构建幂等系统 53
        4.1.10 及时释放资源 53
        4.2 关于日志的使用 54
        4.2.1 给日志分级 55
        4.2.2 日志的原子性 56
        4.2.3 关注日志性能 57
        4.2.4 不要记录敏感数据 59
        4.3 系统监控 59
        4.3.1 使用标准的监控组件 60
        4.3.2 测量一切 63
        4.4 跟踪器 64
        4.5 配置相关注意事项 64
        4.5.1 配置无须新花样 65
        4.5.2 记录并校验所有的配置 66
        4.5.3 提供默认值 67
        4.5.4 给配置分组 67
        4.5.5 将配置视为代码 67
        4.5.6 保持配置文件清爽 68
        4.5.7 不要编辑已经部署的配置 68
        4.6 工具集 68
        4.7 行为准则 70
        4.8 升级加油站 71
        第5 章 依赖管理 72
        5.1 依赖管理基础知识 73
        5.1.1 语义化版本 74
        5.1.2 传递依赖 75
        5.2 相依性地狱 76
        5.3 避免相依性地狱 80
        5.3.1 隔离依赖项 80
        5.3.2 按需添加依赖项 81
        5.3.3 指定依赖项的版本 82
        5.3.4 依赖范围最小化 84
        5.3.5 保护自己免受循环依赖的影响 84
        5.4 行为准则 85
        5.5 升级加油站 85
        第6 章 测试 87
        6.1 测试的多种用途 87
        6.2 测试类型 88
        6.3 测试工具 91
        6.3.1 模拟库 91
        6.3.2 测试框架 92
        6.3.3 代码质量工具 93
        6.4 自己动手编写测试 95
        6.4.1 编写干净的测试 95
        6.4.2 避免过度测试 96
        6.5 测试中的确定性 98
        6.5.1 种子随机数生成器 99
        6.5.2 不要在单元测试中调用远程系统 99
        6.5.3 采用注入式时间戳 99
        6.5.4 避免使用休眠和超时 102
        6.5.5 记得关闭网络套接字和文件句柄 102
        6.5.6 绑定到0 端口 103
        6.5.7 生成唯一的文件路径和数据库位置 103
        6.5.8 隔离并清理剩余的测试状态 103
        6.5.9 不要依赖测试顺序 104
        6.6 行为准则 105
        6.7 升级加油站 105
        第7 章 代码评审 107
        7.1 为什么需要评审代码? 107
        7.2 当你的代码被评审时 109
        7.2.1 准备工作 109
        7.2.2 用评审草案降低风险 110
        7.2.3 提交评审请勿触发测试 111
        7.2.4 预排大体量的代码修改 111
        7.2.5 不要太在意 112
        7.2.6 保持同理心，但不要容忍粗鲁 113
        7.2.7 保持主动 113
        7.3 评审别人的代码时 114
        7.3.1 分流评审请求 114
        7.3.2 给评审预留时间 114
        7.3.3 理解修改的意图 115
        7.3.4 提供全面的反馈 115
        7.3.5 要承认优点 116
        7.3.6 区分问题、建议和挑剔 116
        7.3.7 不要只做橡皮图章 117
        7.3.8 不要只局限于使用网页版的评审工具 118
        7.3.9 不要忘记评审测试代码 118
        7.3.10 推动决断 118
        7.4 行为准则 119
        7.5 升级加油站 120
        第8 章 软件交付 121
        8.1 软件交付流程 121
        8.2 分支策略 122
        8.3 构建环节 125
        8.3.1 打包需要带版本号 126
        8.3.2 将不同的资源单独打包 127
        8.4 发布环节 129
        8.4.1 请勿只想着发布 129
        8.4.2 将包发布到仓库 130
        8.4.3 保持版本不变性 131
        8.4.4 频繁发布 131
        8.4.5 对发布计划保持透明 132
        8.4.6 撰写变更日志和发行说明 132
        8.5 部署环节 133
        8.5.1 自动部署 133
        8.5.2 部署的原子性 134
        8.5.3 独立地部署应用 134
        8.6 展开环节 136
        8.6.1 系统监控 137
        8.6.2 特性开关 137
        8.6.3 熔断器 138
        8.6.4 并行的服务版本梯队 139
        8.6.5 摸黑启动 141
        8.7 行为准则 143
        8.8 升级加油站 144
        第9 章 On-Call 146
        9.1 On-Call 的工作方式 147
        9.2 On-Call 技能包 148
        9.2.1 随时响应 148
        9.2.2 保持专注 148
        9.2.3 确定工作优先级 149
        9.2.4 清晰的沟通 150
        9.2.5 跟踪你的工作 151
        9.3 事故处理 152
        9.3.1 分流 153
        9.3.2 协同 154
        9.3.3 应急方案 155
        9.3.4 解决方案 157
        9.3.5 后续行动 159
        9.4 提供支持 162
        9.5 不要逞英雄 164
        9.6 行为准则 165
        9.7 升级加油站 165
        第10 章 技术设计流程 167
        10.1 技术设计的V 形结构 168
        10.2 关于设计的思考 169
        10.2.1 定义问题 170
        10.2.2 着手调查 171
        10.2.3 进行实验 172
        10.2.4 给些时间 173
        10.3 撰写设计文档 174
        10.3.1 文档持续变更 174
        10.3.2 了解撰写文档的目的 175
        10.3.3 学会写作 176
        10.3.4 保证文档是最新的 176
        10.4 使用设计文档模板 177
        10.4.1 概要 178
        10.4.2 现状与背景 178
        10.4.3 变更的目的 178
        10.4.4 需求 179
        10.4.5 潜在的解决方案 179
        10.4.6 建议的解决方案 180
        10.4.7 设计与架构 180
        10.4.8 测试计划 181
        10.4.9 发布计划 181
        10.4.10 遗留的问题 181
        10.4.11 附录 181
        10.5 协作设计 182
        10.5.1 理解你的团队的设计评审流程 182
        10.5.2 不要让人惊讶 183
        10.5.3 用设计讨论来进行头脑风暴 183
        10.5.4 为设计出力 184
        10.6 行为准则 185
        10.7 升级加油站 185
        第11 章 构建可演进的架构 187
        11.1 理解复杂性 188
        11.2 可演进的设计 189
        11.2.1 你不是真的需要 189
        11.2.2 最小惊讶原则 191
        11.2.3 封装专业领域知识 193
        11.3 可演进的API 193
        11.3.1 保持API 小巧 194
        11.3.2 公开定义良好的服务端API 194
        11.3.3 保持API 变更的兼容性 195
        11.3.4 API 版本化 198
        11.4 可持续的数据管理 199
        11.4.1 数据库隔离 199
        11.4.2 使用schema 201
        11.4.3 schema 自动化迁移 203
        11.4.4 保持schema 的兼容性 206
        11.5 行为准则 207
        11.6 升级加油站 208
        第12 章 敏捷计划 210
        12.1 敏捷宣言 210
        12.2 敏捷计划的框架 211
        12.3 Scrum 框架 212
        12.3.1 用户故事 213
        12.3.2 任务分解 214
        12.3.3 故事点 214
        12.3.4 消化积压 216
        12.3.5 冲刺计划 216
        12.4 站会 217
        12.5 评审机制 218
        12.6 回顾会 219
        12.7 路线图 220
        12.8 行为准则 221
        12.9 升级加油站 222
        第13 章 与管理者合作 223
        13.1 管理者是做什么的 223
        13.2 沟通、目标与成长 224
        13.2.1 一对一面谈 225
        13.2.2 PPP 227
        13.2.3 OKR 229
        13.2.4 绩效考核 230
        13.3 向上管理 232
        13.3.1 接收反馈 232
        13.3.2 给予反馈 233
        13.3.3 讨论你的目标 235
        13.3.4 事情不顺时要采取行动 236
        13.4 行为准则 238
        13.5 升级加油站 239
        第14 章 职业生涯规划 241
        14.1 迈向资深之路 241
        14.2 职业生涯建议 242
        14.2.1 T 型人才 242
        14.2.2 参加工程师训练营 243
        14.2.3 主导你自己的晋升 244
        14.2.4 换工作需谨慎 246
        14.2.5 自我调节 247
        14.3 结尾寄语 248
     · · · · · ·     (收起)"
35503091,C语言程序设计：现代方法（第2版•修订版）,9.2,(114人评价),[美] K.N.金 / 吕秀锋、黄倩 / 图灵丨人民邮电出版社 / 2021-7 / 129.80元,"◎ 本书特色
近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分
哈佛、麻省理工、斯坦福等诸多名校C语言教材
基于C1X标准全新升级
浙江大...",https://book.douban.com/subject/35503091/,https://img9.doubanio.com/view/subject/s/public/s33927414.jpg,129.80元,9787115565198,"◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超...(展开全部)





◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超过95%的大学用C语言作为入门编程语言，但也因此把C语言当作一种学习编程的教学媒介语言来教，使得学生只学到了其中的基础部分，而对C语言近30年的发展及其在工业中的应用所知甚少。本书是难得的真正讲述C语言的教材，覆盖了C99、C11、C18标准的内容。本书非常适合今后会用C语言来做嵌入式系统、设备驱动和操作系统等产品开发的人士学习。在浙江大学，我们在工程实践课程中使用了本书的上一个版本，收获了良好的教学效果。 ——翁恺，浙江大学计算机学院教授 书如其名，本书以一种崭新的视角和通俗易懂的方式，来向读者介绍C语言的“现代方法”，聚焦程序设计的核心问题和方法，给C语言这门经久不衰、老而弥坚的语言赋予了崭新的面貌。本书介绍了C99和C1X的许多新特性，而且编排方式方便读者查阅。本书用现代的视角来解读C语言，每章后面的“问与答”也很贴心，适时地解答了读者在阅读过程中可能会遇到的很多疑难问题。本书内容特别适合具备一定语言基础，想深入了解C语言精髓的读者，我相信这本书一定会受到读者的欢迎，成为C语言爱好者提升内功的一本武林秘笈。 ——苏小红，哈尔滨工业大学教授、博士生导师，省级教学名师 本书讨论了C语言的所有特性，从C89一直贯穿到C18。内容足够新，也足够全面，这就是它的突出特色。 ——吴咏炜，Boolan首席咨询师 本书是C语言程序设计的经典图书，本次修订版增加了C1X的内容，并就C1X与之前的C89、C99进行了比对，做到了与时俱进。本书更是新增了第28章，重点介绍了C1X的多线程特性，相信对读者会有巨大的帮助。读者通过阅读本书，可深入理解C89、C99和C1X的演进，并进一步思考C语言为什么这么演进，这对提高自身的思维能力以及对软件工程问题的认知都会有帮助。 ——宋宝华，资深Linux专家",作者简介 K. N. 金（K. N. King） 世界知名的计算机程序设计教育家。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院和佐治亚州立大学。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide和Java Programming: From the Beginning。 译者简介 吕秀锋 曾任教于北京理工大学软件学院，讲授过多门计算机课程，包括“计算机基础（双语）”“C语言程序设计（双语）”“数据结构”“程序设计开发与实践”。 黄倩 河海大学计算机科学与技术系主任，兼任中国人工智能学会深度学习专委会委员、中国计算机学会多媒体技术专委会委员。博士毕业于中国科学院计算技术研究所，译有《编程珠玑（第2版）》等。,"第1章 C语言概述
        第2章 C语言基本概念
        第3章 格式化输入/输出
        第4章 表达式
        第5章 选择语句
        第6章 循环
        第7章 基本类型
        第8章 数组
        第9章 函数
        第10章 程序结构
        第11章 指针
        第12章 指针和数组
        第13章 字符串
        第14章 预处理器
        第15章 编写大型程序
        第16章 结构、联合和枚举
        第17章 指针的高级应用
        第18章 声明
        第19章 程序设计
        第20章 底层程序设计
        第21章 标准库
        第22章 输入/输出
        第23章 库对数值和字符数据的支持
        第24章 错误处理
        第25章 国际化特性
        第26章 其他库函数
        第27章 C99对数学计算的新增支持
        第28章 C1X新增的多线程和原子操作支持
        附录A C语言运算符
        附录B C1X与C99的比较
        附录C C99与C89的比较
        附录D C89与经典C的比较
        附录E 标准库函数
        附录F ASCII字符集
        延伸阅读
        索引
     · · · · · ·     (收起)"
1998341,计算机系统要素,9.1,(269人评价),[美] Noam Nisan、[美] Shimon Schocken / 周维、宋磊、陈曦 / 电子工业出版社 / 2007-01-01 / 45.00元,本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，...,https://book.douban.com/subject/1998341/,https://img9.doubanio.com/view/subject/s/public/s2207295.jpg,45.00元,9787121033360,"本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统...(展开全部)





本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统所必需的工具和资料，以及用于12个项目的200个测试程序。 全书内容广泛、涉猎全面，适合计算机及相关专业本科生、研究生、技术开发人员、教师以及技术爱好者参考和学习。","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
    · · · · · ·
    (更多)","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
        1.1.3 实际硬件结构
        1.1.4 硬件描述语言（HDL）
        1.1.5 硬件仿真
        1.2 规范详述
        1.2.1 Nand门
        1.2.2 基本逻辑门
        1.2.3 多位基本门
        1.2.4 多通道逻辑门
        1.3 实现
        1.4 观点
        1.5 项目
        第2章 布尔运算
        2.1 背景知识
        2.2 规范详述
        2.2.1 加法器
        2.2.2 算术逻辑单元（ALU）
        2.3 实现
        2.4 观点
        2.5 项目
        第3章 时序逻辑
        3.1 背景知识
        3.2 规范详述
        3.2.1 D触发器
        3.2.2 寄存器
        3.2.3 存储
        3.2.4 计数器
        3.3 实现
        3.4 观点
        3.5 项目
        第4章 机器语言
        4.1 背景知识
        4.1.1 机器
        4.1.2 语言
        4.1.3 命令
        4.2 Hack机器语言规范详述
        4.2.1 概述
        4.2.2 A-指令
        4.2.3 C-指令
        4.2.4 符号
        4.2.5 输入/输出处理
        4.2.6 语法规约和文件格式
        4.3 观点
        4.4 项目
        第5章 计算机体系结构
        5.1 背景知识
        5.1.1 存储程序概念
        5.1.2 冯?诺依曼结构
        5.1.3 内存
        5.1.4 中央处理器
        5.1.5 寄存器
        5.1.6 输入和输出
        5.2 Hack硬件平台规范详述
        5.2.1 概述
        5.2.2 中央处理器（CPU）
        5.2.3 指令内存
        5.2.4 数据内存
        5.2.5 计算机
        5.3 实现
        5.3.1 中央处理器
        5.3.2 内存
        5.3.3 计算机
        5.4 观点
        5.5 项目
        第6章 汇编编译器
        第7章 虚拟机Ⅰ：堆栈运算
        第8章 虚拟机Ⅱ：程序控制
        第9章 高级语言
        第10章 编译器Ⅰ：语法分析
        第11章 编译器Ⅱ：代码生成
        第12章 操作系统
        第13章 后记：发掘更多乐趣
        附录A： 硬件描述语言（HDL）
        附录B： 测试脚本语言
        索引
     · · · · · ·     (收起)"
35972849,代码大全2（纪念版）,9.3,(62人评价),[美] 史蒂夫·麦康奈尔(Steve McConnell) / 陈玉毅、陈军、杨志昂、洪佳、徐东伟、王国良、徐毅、李虎 / 清华大学出版社 / 2022-7-7 / 256.00,"《软件开发》杂志Jolt大奖
大而全，洞悉软件构建精髓
优而先，兼顾行业实践研究
奠定硬核技术领导力的经典
庸常变身卓越的实用性指导
《代码大全2》是著名科...",https://book.douban.com/subject/35972849/,https://img3.doubanio.com/view/subject/s/public/s34276333.jpg,256.00,9787302583646,"《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序...(展开全部)





《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。无论是什么背景的读者，阅读本书都有助于在更短的时间内、更容易地写出更好、更简洁、更优雅的程序。","史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现...(展开全部)




史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现象级科技类图书缔造者 • 会做（编程）又会教的一线程序员 • 《软件开发》杂志震撼图书大奖（两次） • 《软件开发》杂志生产力大奖（两次） •   西雅图大学杰出校友奖 • 《普吉特海湾商业期刊》40 UNDER 40杰出青年奖 •  波音和微软等公司顾问 •  ACM（计算机学会）金牌核心奖章得主 •  IEEE Software杂志主编 •  惠特曼文理学院优秀毕业生，PBK会员","第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界　003
        第2章　通过隐喻更充分地理解软件开发　009
        第3章　谋定而后动：前期准备　023
        第4章　关键的构建决策　057
        第II部分高质量的代码
        第5章　软件构建的设计　069
        第6章　可以工作的类　121
        第7章　高质量的子程序　157
        第8章　防御式编程　187
        第9章　伪代码编程过程　215
        第Ⅲ部分变量
        第10章　变量使用中的常规问题　239
        第11章　变量名称的威力　263
        第12章　基本数据类型　295
        第13章　不常见的数据类型　323
        第Ⅳ部分语句
        第14章　直线型代码的组织　353
        第15章　使用条件语句　361
        第16章　控制循环　373
        第17章　不常见的控制结构　395
        第18章　表驱动法　417
        第19章　常规控制问题　437
        第Ⅴ部分代码改进
        第20章　软件质量概述　469
        第21章　协同构建　483
        第22章　开发人员测试　503
        第23章　调试　541
        第24章　重构　569
        第25章　代码调优策略　591
        第26章　代码调优技术　613
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响　651
        第28章　管理构建　663
        第29章　集成　693
        第30章　编程工具　715
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格　733
        第32章　自文档代码　781
        第33章　个人性格　821
        第34章　关于软件匠艺　837
        第35章　更多信息来源　853
        详细目录
        第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界	003
        1.1什么是软件构建	003
        1.2软件构建为何如此重要	006
        1.3如何阅读本书	008
        第2章　通过隐喻更充分地
        理解软件开发	009
        2.1隐喻的重要性	009
        2.2如何使用软件隐喻	012
        2.3常见的软件隐喻	013
        第3章　谋定而后动：前期准备	023
        3.1前期准备的重要性	024
        3.2确定要开发什么类型的软件	030
        3.3定义问题的先决条件	034
        3.4需求的先决条件	036
        3.5架构的先决条件	041
        3.6前期准备所花费的时间	052
        第4章　关键的构建决策	057
        4.1编程语言的选择	057
        4.2编程约定	062
        4.3判断个人处于技术浪潮中的哪个阶段	062
        4.4选择重要的构建实践	065
        第II部分高质量的代码
        第5章　软件构建的设计	069
        5.1设计挑战	070
        5.2关键设计概念	073
        5.3设计构建基块：启发式方法	083
        5.4设计实践	107
        5.5点评各种流行的方法论	115
        第6章　可以工作的类	121
        6.1类的基础：抽象数据类型(ADT)	122
        6.2良好的类接口	129
        6.3设计和实现问题	139
        6.4创建类的理由	149
        6.5语言特定问题	153
        6.6超越类：包	153
        第7章　高质量的子程序	157
        7.1创建子程序的正当理由	160
        7.2子程序级别的设计	165
        7.3好的子程序名称	169
        7.4一个子程序应该有多长	171
        7.5如何使用子程序参数	173
        7.6函数使用中的特别注意事项	180
        7.7宏子程序和内联子程序	182
        第8章　防御式编程	187
        8.1保护程序，
        使其免受无效输入的影响	188
        8.2断言	189
        8.3错误处理技术	194
        8.4异常	198
        8.5隔离程序，使之包容
        由错误造成的损害	203
        8.6调试辅助代码	205
        8.7确定在生产代码中
        保留多少防御式代码	209
        8.8对防御式编程采取防御的姿态	211
        第9章　伪代码编程过程	215
        9.1类和子程序构建步骤总结	215
        9.2面向专家的伪代码	218
        9.3使用PPP构建子程序	220
        9.4PPP的替代方案	233
        第Ⅲ部分变量
        第10章　变量使用中的常规问题	239
        10.1数据扫盲	240
        10.2简化变量声明	241
        10.3变量初始化指南	242
        10.4作用域	247
        10.5持久性	254
        10.6绑定时间	255
        10.7数据类型和控制结构之间的关系	257
        10.8每个变量只有一个用途	258
        第11章　变量名称的威力	263
        11.1选择好名称的注意事项	263
        11.2特定数据类型的命名	269
        11.3命名规范的威力	275
        11.4非正式的命名规范	276
        11.5前缀的标准化	283
        11.6创建可读的短名称	286
        11.7变量名称避坑指南	289
        第12章　基本数据类型	295
        12.1一般的数字	296
        12.2整型	297
        12.3浮点型	299
        12.4字符和字符串	302
        12.5布尔变量	305
        12.6枚举类型	307
        12.7具名常量	312
        12.8数组	314
        12.9创建自定义类型(类型别名)	316
        第13章　不常见的数据类型	323
        13.1结构体	323
        13.2指针	327
        13.3全局数据	340
        第Ⅳ部分语句
        第14章　直线型代码的组织	353
        14.1顺序攸关的语句	353
        14.2顺序无关的语句	356
        第15章　使用条件语句	361
        15.1if语句	361
        15.2case语句	367
        第16章　控制循环	373
        16.1选择循环类型	373
        16.2控制循环	379
        16.3轻松创建循环：由内而外 	391
        16.4循环和数组的对应关系	393
        第17章　不常见的控制结构	395
        17.1子程序中的多个返回点	395
        17.2递归	397
        17.3goto语句	402
        17.4众说纷纭，谈谈不常见的控制结构	413
        第18章　表驱动法	417
        18.1表驱动法使用总则	417
        18.2直接访问表	419
        18.3索引访问表	431
        18.4阶梯访问表	433
        18.5表查询的其他示例	436
        第19章　常规控制问题	437
        19.1布尔表达式	437
        19.2复合语句(语句块)	448
        19.3空语句	449
        19.4驾驭深层嵌套	451
        19.5编程基础：结构化编程	460
        19.6控制结构与复杂度	462
        第Ⅴ部分代码改进
        第20章　软件质量概述	469
        20.1软件质量的特性	469
        20.2改进软件质量的技术	472
        20.3质量保证技术的相对效能	475
        20.4何时进行质量保证	479
        20.5软件质量的普遍原理	479
        第21章　协同构建	483
        21.1协同开发实践概述	484
        21.2结对编程	487
        21.3正式审查	489
        21.4其他类型的协同开发实践	496
        第22章　开发人员测试	503
        22.1开发者测试
        对软件质量所起的作用	504
        22.2开发人员测试的推荐方法	507
        22.3一些测试技巧	509
        22.4典型错误 	522
        22.5测试支持工具	528
        22.6改进测试	534
        22.7维护测试记录 	535
        第23章　调试	541
        23.1调试问题概述	541
        23.2发现缺陷	546
        23.3修复缺陷	557
        23.4调试中的心理因素	560
        23.5那些显而易见和
        不太明显的调试工具	563
        第24章　重构	569
        24.1软件演变的类型	570
        24.2重构简介	571
        24.3特定的重构	577
        24.4安全重构	585
        24.5重构策略	587
        第25章　代码调优策略	591
        25.1性能概述	592
        25.2代码调优简介	595
        25.3各式各样的臃肿和蜜糖	601
        25.4度量	607
        25.5迭代	608
        25.6代码调优方法总结	609
        第26章　代码调优技术	613
        26.1逻辑	614
        26.2循环	619
        26.3数据变换	628
        26.4表达式	633
        26.5子程序	642
        26.6用低级语言重新编码	643
        26.7改得越多，越不会有大的改观	646
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响	651
        27.1沟通和规模	651
        27.2项目规模的范围	652
        27.3项目规模对错误的影响	653
        27.4项目规模对生产力的影响	655
        27.5项目规模对开发活动的影响	656
        第28章　管理构建	663
        28.1鼓励良好的编码实践	664
        28.2配置管理	666
        28.3评估构建进度表	673
        28.4度量	679
        28.5以人为本，善待每一位程序员	683
        28.6向上管理	689
        第29章　集成	693
        29.1集成方法的重要性	693
        29.2集成的频率，阶段式还是增量式	695
        29.3增量式集成策略	698
        29.4每日构建和冒烟测试	707
        第30章　编程工具	715
        30.1设计工具	716
        30.2源代码工具	716
        30.3可执行码工具	721
        30.4面向工具的环境	726
        30.5自己动手写编程工具	726
        30.6工具的幻境	728
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格	733
        31.1基本理论	734
        31.2布局技术	741
        31.3布局风格	743
        31.4控制结构的布局	750
        31.5单条语句的布局	757
        31.6注释的布局	768
        31.7子程序的布局	771
        31.8类的布局	772
        第32章　自文档代码	781
        32.1外部文档	781
        32.2编程风格即文档	782
        32.3注释，还是不注释	785
        32.4高效注释的关键	788
        32.5注释的技术	795
        32.6IEEE标准	815
        第33章　个人性格	821
        33.1个人性格与本书主题有关	822
        33.2聪明与谦卑	823
        33.3好奇心	824
        33.4理性诚实	827
        33.5沟通与合作	830
        33.6创造力与规范	830
        33.7懒惰	831
        33.8没有想象中那么重要的性格因素	832
        33.9习惯	833
        第34章　关于软件匠艺	837
        34.1征服复杂性	837
        34.2优选开发过程	839
        34.3编写程序时，先考虑人，
        再考虑机器	840
        34.4深入语言去编程，
        而不是用语言来编程	842
        34.5借助于规范来保持专注	843
        34.6面向问题域编程	844
        34.7 当心落石	846
        34.8迭代，迭代，迭代，
        重要的事情说三遍	848
        34.9警惕编程中的执念	849
        试验	851
        第35章　更多信息来源	853
        35.1与软件构建相关的信息	853
        35.2软件构建之外的话题	854
        35.3出版物	856
        35.4软件开发者的阅读计划	857
        35.5加入专业组织	859
        参考文献	861
     · · · · · ·     (收起)"
35520512,深入浅出Pandas,8.6,(97人评价),李庆辉 / 机械工业出版社 / 2021-7-10 / 99.00,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。
这是一本全面覆盖了Pandas使用者的普遍需求和...",https://book.douban.com/subject/35520512/,https://img9.doubanio.com/view/subject/s/public/s33944495.jpg,99.00,9787111685456,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 ...(展开全部)





如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 第三部分（第6～9章） 数据形式变化 讲解了Pandas的分组聚合操作、合并操作、对比操作、数据透视、转置、归一化、标准化等，以及如何利用多层索引对数据进行升降维。 第四部分（第10～12章） 数据清洗 讲解了缺失值和重复值的识别、删除、填充，数据的替换、格式转换，文本的提取、连接、匹配、切分、替换、格式化、虚拟变量化等，以及分类数据的应用场景和操作方法。 第五部分（第13～14章）时序数据分析 讲解了Pandas中对于各种时间类型数据的处理和分析，以及在时序数据处理中经常使用的窗口计算。 第六部分（第15～16章） 可视化 讲解了Pandas的样式功能如何让数据表格更有表现力，以及Pandas的绘图功能如何让数据自己说话。 第七部分（第17章） 实战案例 介绍了从需求到代码的思考过程，如何利用链式编程思想提高代码编写和数据分析效率，以及数据分析的基本方法与需要掌握的数据分析工具和技术栈，此外还从数据处理和数据分析两个角度给出了大量的应用案例及代码详解。",李庆辉，数据产品专家，某电商公司数据产品团队负责人，擅长通过数据治理、数据分析、数据化运营提升公司的数据应用水平。 精通 Python 数据科学及 Python Web 开发，曾独立开发公司的自动化数据分析平台，参与教育部“1+X”数据分析（Python）职业技能等级标准评审。 中国人工智能学会会员，企业数字化、数据产品和数据分析讲师，在个人网站“盖若”上编写的技术和产品教程广受欢迎。,"前言
        第一部分 Pandas入门
        第1章 Pandas简介及快速入门2
        1.1 Pandas是什么2
        1.1.1 Python简介2
        1.1.2 Python的应用3
        1.1.3 为什么不选择R4
        1.1.4 Pandas简介4
        1.1.5 Pandas的使用人群5
        1.1.6 Pandas的基本功能5
        1.1.7 Pandas的学习方法6
        1.1.8 小结6
        1.2 环境搭建及安装6
        1.2.1 Python环境安装7
        1.2.2 Anaconda简介7
        1.2.3 安装miniconda8
        1.2.4 多Python版本环境9
        1.2.5 安装编辑器10
        1.2.6 Jupyter Notebook10
        1.2.7 用pip安装三方库11
        1.2.8 安装Jupyter Notebook12
        1.2.9 启动Jupyter Notebook12
        1.2.10 使用Jupyter Notebook13
        1.2.11 安装Pandas14
        1.2.12 小结14
        1.3 Pandas快速入门14
        1.3.1 安装导入14
        1.3.2 准备数据集15
        1.3.3 读取数据15
        1.3.4 查看数据16
        1.3.5 验证数据17
        1.3.6 建立索引17
        1.3.7 数据选取18
        1.3.8 排序19
        1.3.9 分组聚合19
        1.3.10 数据转换20
        1.3.11 增加列21
        1.3.12 统计分析21
        1.3.13 绘图21
        1.3.14 导出24
        1.3.15 小结24
        1.4 本章小结24
        第2章 数据结构25
        2.1 数据结构概述25
        2.1.1 什么是数据25
        2.1.2 什么是数据结构26
        2.1.3 小结26
        2.2 Python的数据结构26
        2.2.1 数字27
        2.2.2 字符串27
        2.2.3 布尔型28
        2.2.4 列表29
        2.2.5 元组30
        2.2.6 字典30
        2.2.7 集合31
        2.2.8 小结32
        2.3 NumPy32
        2.3.1 NumPy简介33
        2.3.2 数据结构33
        2.3.3 创建数据34
        2.3.4 数据类型34
        2.3.5 数组信息35
        2.3.6 统计计算35
        2.3.7 小结35
        2.4 Pandas的数据结构35
        2.4.1 Series36
        2.4.2 DataFrame36
        2.4.3 索引37
        2.4.4 小结38
        2.5 Pandas生成数据38
        2.5.1 导入Pandas38
        2.5.2 创建数据38
        2.5.3 生成Series40
        2.5.4 生成DataFrame41
        2.5.5 小结43
        2.6 Pandas的数据类型43
        2.6.1 数据类型查看43
        2.6.2 常见数据类型44
        2.6.3 数据检测44
        2.6.4 小结45
        2.7 本章小结45
        第二部分 Pandas数据分析基础
        第3章 Pandas数据读取与输出48
        3.1 数据读取48
        3.1.1 CSV文件49
        3.1.2 Excel49
        3.1.3 JSON 50
        3.1.4 HTML50
        3.1.5 剪贴板51
        3.1.6 SQL51
        3.1.7 小结52
        3.2 读取CSV52
        3.2.1 语法52
        3.2.2 数据内容53
        3.2.3 分隔符53
        3.2.4 表头54
        3.2.5 列名54
        3.2.6 索引54
        3.2.7 使用部分列54
        3.2.8 返回序列55
        3.2.9 表头前缀55
        3.2.10 处理重复列名55
        3.2.11 数据类型55
        3.2.12 引擎55
        3.2.13 列数据处理56
        3.2.14 真假值转换56
        3.2.15 跳过指定行56
        3.2.16 读取指定行57
        3.2.17 空值替换57
        3.2.18 保留默认空值57
        3.2.19 日期时间解析58
        3.2.20 文件处理59
        3.2.21 符号60
        3.2.22 小结61
        3.3 读取Excel61
        3.3.1 语法61
        3.3.2 文件内容62
        3.3.3 表格62
        3.3.4 表头62
        3.3.5 列名62
        3.3.6 其他62
        3.3.7 小结63
        3.4 数据输出63
        3.4.1 CSV63
        3.4.2 Excel63
        3.4.3 HTML64
        3.4.4 数据库（SQL）64
        3.4.5 Markdown65
        3.4.6 小结65
        3.5 本章小结65
        第4章 Pandas基础操作66
        4.1 索引操作66
        4.1.1 认识索引66
        4.1.2 建立索引67
        4.1.3 重置索引68
        4.1.4 索引类型68
        4.1.5 索引对象69
        4.1.6 索引的属性70
        4.1.7 索引的操作70
        4.1.8 索引重命名72
        4.1.9 修改索引内容72
        4.1.10 小结73
        4.2 数据的信息73
        4.2.1 查看样本73
        4.2.2 数据形状74
        4.2.3 基础信息74
        4.2.4 数据类型74
        4.2.5 行列索引内容75
        4.2.6 其他信息75
        4.2.7 小结75
        4.3 统计计算76
        4.3.1 描述统计76
        4.3.2 数学统计77
        4.3.3 统计函数78
        4.3.4 非统计计算79
        4.3.5 小结80
        4.4 位置计算80
        4.4.1 位置差值diff()80
        4.4.2 位置移动shift()81
        4.4.3 位置序号rank()81
        4.4.4 小结82
        4.5 数据选择82
        4.5.1 选择列83
        4.5.2 切片[]83
        4.5.3 按轴标签.loc84
        4.5.4 按数字索引.iloc86
        4.5.5 取具体值.at/.iat86
        4.5.6 获取数据.get86
        4.5.7 数据截取.truncate87
        4.5.8 索引选择器87
        4.5.9 小结87
        4.6 本章小结88
        第5章 Pandas高级操作89
        5.1 复杂查询89
        5.1.1 逻辑运算89
        5.1.2 逻辑筛选数据91
        5.1.3 函数筛选92
        5.1.4 比较函数92
        5.1.5 查询df.query()93
        5.1.6 筛选df.filter()93
        5.1.7 按数据类型查询93
        5.1.8 小结94
        5.2 数据类型转换94
        5.2.1 推断类型94
        5.2.2 指定类型95
        5.2.3 类型转换astype()95
        5.2.4 转为时间类型96
        5.2.5 小结96
        5.3 数据排序96
        5.3.1 索引排序97
        5.3.2 数值排序98
        5.3.3 混合排序100
        5.3.4 按值大小排序101
        5.3.5 小结101
        5.4 添加修改101
        5.4.1 修改数值101
        5.4.2 替换数据103
        5.4.3 填充空值103
        5.4.4 修改索引名104
        5.4.5 增加列104
        5.4.6 插入列df.insert()105
        5.4.7 指定列df.assign()106
        5.4.8 执行表达式df.eval()108
        5.4.9 增加行109
        5.4.10 追加合并109
        5.4.11 删除110
        5.4.12 删除空值111
        5.4.13 小结111
        5.5 高级过滤111
        5.5.1 df.where()111
        5.5.2 np.where()113
        5.5.3 df.mask()115
        5.5.4 df.lookup()116
        5.5.5 小结116
        5.6 数据迭代116
        5.6.1 迭代Series116
        5.6.2 df.iterrows()117
        5.6.3 df.itertuples()117
        5.6.4 df.items()118
        5.6.5 按列迭代119
        5.6.6 小结119
        5.7 函数应用120
        5.7.1 pipe()120
        5.7.2 apply()121
        5.7.3 applymap()123
        5.7.4 map()124
        5.7.5 agg()124
        5.7.6 transform()125
        5.7.7 copy()126
        5.7.8 小结126
        5.8 本章小结126
        第三部分 数据形式变化
        第6章 Pandas分组聚合128
        6.1 概述128
        6.1.1 原理128
        6.1.2 groupby语法129
        6.1.3 DataFrame应用分组130
        6.1.4 Series应用分组131
        6.1.5 小结131
        6.2 分组131
        6.2.1 分组对象131
        6.2.2 按标签分组132
        6.2.3 表达式132
        6.2.4 函数分组133
        6.2.5 多种方法混合134
        6.2.6 用pipe调用分组方法134
        6.2.7 分组器Grouper135
        6.2.8 索引136
        6.2.9 排序136
        6.2.10 小结136
        6.3 分组对象的操作136
        6.3.1 选择分组137
        6.3.2 迭代分组138
        6.3.3 选择列139
        6.3.4 应用函数apply()139
        6.3.5 管道方法pipe()142
        6.3.6 转换方法transform()142
        6.3.7 筛选方法filter()144
        6.3.8 其他功能145
        6.3.9 小结146
        6.4 聚合统计146
        6.4.1 描述统计146
        6.4.2 统计函数147
        6.4.3 聚合方法agg()147
        6.4.4 时序重采样方法resample()149
        6.4.5 组内头尾值150
        6.4.6 组内分位数150
        6.4.7 组内差值151
        6.4.8 小结151
        6.5 数据分箱151
        6.5.1 定界分箱pd.cut()152
        6.5.2 等宽分箱pd.qcut()152
        6.5.3 小结154
        6.6 分组可视化154
        6.6.1 绘图方法plot()154
        6.6.2 直方图hist()155
        6.6.3 箱线图boxplot()156
        6.6.4 小结157
        6.7 本章小结158
        第7章 Pandas数据合并与对比159
        7.1 数据追加df.append159
        7.1.1 基本语法159
        7.1.2 相同结构160
        7.1.3 不同结构161
        7.1.4 忽略索引161
        7.1.5 重复内容162
        7.1.6 追加序列162
        7.1.7 追加字典163
        7.1.8 小结163
        7.2 数据连接pd.concat163
        7.2.1 基本语法163
        7.2.2 简单连接164
        7.2.3 按列连接164
        7.2.4 合并交集165
        7.2.5 与序列合并165
        7.2.6 指定索引166
        7.2.7 多文件合并166
        7.2.8 目录文件合并167
        7.2.9 小结167
        7.3 数据合并pd.merge167
        7.3.1 基本语法168
        7.3.2 连接键168
        7.3.3 索引连接169
        7.3.4 多连接键169
        7.3.5 连接方法170
        7.3.6 连接指示170
        7.3.7 小结171
        7.4 按元素合并171
        7.4.1 df.combine_first()171
        7.4.2 df.combine()172
        7.4.3 df.update()173
        7.4.4 小结173
        7.5 数据对比df.compare173
        7.5.1 简单对比174
        7.5.2 对齐方式174
        7.5.3 显示相同值174
        7.5.4 保持形状175
        7.5.5 小结175
        7.6 本章小结175
        第8章 Pandas多层索引177
        8.1 概述177
        8.1.1 什么是多层索引177
        8.1.2 通过分组产生多层索引178
        8.1.3 由序列创建多层索引179
        8.1.4 由元组创建多层索引179
        8.1.5 可迭代对象的笛卡儿积180
        8.1.6 将DataFrame转为多层索引对象180
        8.1.7 小结180
        8.2 多层索引操作181
        8.2.1 生成数据181
        8.2.2 索引信息181
        8.2.3 查看层级182
        8.2.4 索引内容182
        8.2.5 排序183
        8.2.6 其他操作183
        8.2.7 小结183
        8.3 数据查询183
        8.3.1 查询行183
        8.3.2 查询列184
        8.3.3 行列查询185
        8.3.4 条件查询185
        8.3.5 用pd.IndexSlice索引数据186
        8.3.6 df.xs()186
        8.3.7 小结186
        8.4 本章小结186
        第9章 Pandas数据重塑与透视187
        9.1 数据透视187
        9.1.1 整理透视187
        9.1.2 整理透视操作188
        9.1.3 聚合透视189
        9.1.4 聚合透视操作190
        9.1.5 聚合透视高级操作191
        9.1.6 小结192
        9.2 数据堆叠192
        9.2.1 理解堆叠193
        9.2.2 堆叠操作df.stack()194
        9.2.3 解堆操作df.unstack()195
        9.2.4 小结195
        9.3 交叉表195
        9.3.1 基本语法196
        9.3.2 生成交叉表196
        9.3.3 归一化197
        9.3.4 指定聚合方法198
        9.3.5 汇总198
        9.3.6 小结199
        9.4 数据转置df.T199
        9.4.1 理解转置199
        9.4.2 转置操作200
        9.4.3 类型变化200
        9.4.4 轴交换df.swapaxes()201
        9.4.5 小结201
        9.5 数据融合201
        9.5.1 基本语法201
        9.5.2 融合操作202
        9.5.3 标识和值203
        9.5.4 指定名称204
        9.5.5 小结204
        9.6 虚拟变量204
        9.6.1 语法结构204
        9.6.2 生成虚拟变量205
        9.6.3 列前缀205
        9.6.4 从DataFrame生成206
        9.6.5 小结207
        9.7 因子化207
        9.7.1 基本方法207
        9.7.2 排序208
        9.7.3 缺失值208
        9.7.4 枚举类型208
        9.7.5 小结208
        9.8 爆炸列表208
        9.8.1 基本功能209
        9.8.2 DataFrame的爆炸209
        9.8.3 非列表格式210
        9.8.4 小结210
        9.9 本章小结210
        第四部分 数据清洗
        第10章 Pandas数据清洗212
        10.1 缺失值的认定212
        10.1.1 缺失值类型212
        10.1.2 缺失值判断213
        10.1.3 缺失值统计214
        10.1.4 缺失值筛选214
        10.1.5 NA标量215
        10.1.6 时间数据中的缺失值216
        10.1.7 整型数据中的缺失值216
        10.1.8 插入缺失值217
        10.1.9 小结217
        10.2 缺失值的操作217
        10.2.1 缺失值填充217
        10.2.2 插值填充219
        10.2.3 缺失值删除220
        10.2.4 缺失值参与计算221
        10.2.5 小结223
        10.3 数据替换223
        10.3.1 指定值替换223
        10.3.2 使用替换方式223
        10.3.3 字符替换223
        10.3.4 缺失值替换224
        10.3.5 数字替换224
        10.3.6 数据修剪225
        10.3.7 小结226
        10.4 重复值及删除数据226
        10.4.1 重复值识别226
        10.4.2 删除重复值228
        10.4.3 删除数据229
        10.4.4 小结229
        10.5 NumPy格式转换230
        10.5.1 转换方法230
        10.5.2 DataFrame转为ndarray230
        10.5.3 Series转为ndarray231
        10.5.4 df.to_records()231
        10.5.5 np.array读取231
        10.5.6 小结232
        10.6 本章小结232
        第11章 Pandas文本处理233
        11.1 数据类型233
        11.1.1 文本数据类型233
        11.1.2 类型转换234
        11.1.3 类型异同234
        11.1.4 小结235
        11.2 字符的操作235
        11.2.1 .str访问器235
        11.2.2 文本格式236
        11.2.3 文本对齐236
        11.2.4 计数和编码236
        11.2.5 格式判定237
        11.2.6 小结237
        11.3 文本高级处理237
        11.3.1 文本分隔237
        11.3.2 字符分隔展开238
        11.3.3 文本切片选择239
        11.3.4 文本划分240
        11.3.5 文本替换241
        11.3.6 指定替换241
        11.3.7 重复替换242
        11.3.8 文本连接243
        11.3.9 文本查询244
        11.3.10 文本包含245
        11.3.11 文本提取246
        11.3.12 提取虚拟变量247
        11.3.13 小结248
        11.4 本章小结248
        第12章 Pandas分类数据249
        12.1 分类数据249
        12.1.1 创建分类数据249
        12.1.2 pd.Categorical()251
        12.1.3 CategoricalDtype对象251
        12.1.4 类型转换252
        12.1.5 小结253
        12.2 分类的操作253
        12.2.1 修改分类253
        12.2.2 追加新分类254
        12.2.3 删除分类254
        12.2.4 顺序255
        12.2.5 小结256
        12.3 本章小结256
        第五部分 时序数据分析
        第13章 Pandas窗口计算258
        13.1 窗口计算258
        13.1.1 理解窗口计算258
        13.1.2 移动窗口259
        13.1.3 扩展窗口259
        13.1.4 指数加权移动260
        13.1.5 小结260
        13.2 窗口操作260
        13.2.1 计算方法260
        13.2.2 基本语法261
        13.2.3 移动窗口使用262
        13.2.4 统计方法263
        13.2.5 agg()264
        13.2.6 apply()264
        13.2.7 扩展窗口265
        13.2.8 小结266
        13.3 本章小结266
        第14章 Pandas时序数据267
        14.1 固定时间267
        14.1.1 时间的表示267
        14.1.2 创建时间点268
        14.1.3 时间的属性269
        14.1.4 时间的方法270
        14.1.5 时间缺失值271
        14.1.6 小结272
        14.2 时长数据272
        14.2.1 创建时间差272
        14.2.2 时长的加减274
        14.2.3 时长的属性275
        14.2.4 时长索引275
        14.2.5 小结275
        14.3 时间序列275
        14.3.1 时序索引275
        14.3.2 创建时序数据276
        14.3.3 数据访问277
        14.3.4 类型转换279
        14.3.5 按格式转换281
        14.3.6 时间访问器.dt282
        14.3.7 时长数据访问器284
        14.3.8 时序数据移动284
        14.3.9 频率转换285
        14.3.10 小结286
        14.4 时间偏移286
        14.4.1 DateOffset对象286
        14.4.2 偏移别名287
        14.4.3 移动偏移289
        14.4.4 应用偏移289
        14.4.5 偏移参数290
        14.4.6 相关查询290
        14.4.7 与时序的计算291
        14.4.8 锚定偏移292
        14.4.9 自定义工作时间294
        14.4.10 小结296
        14.5 时间段297
        14.5.1 Period对象297
        14.5.2 属性方法297
        14.5.3 时间段的计算298
        14.5.4 时间段索引299
        14.5.5 数据查询300
        14.5.6 相关类型转换301
        14.5.7 小结302
        14.6 时间操作302
        14.6.1 时区转换302
        14.6.2 时间的格式化303
        14.6.3 时间重采样304
        14.6.4 上采样306
        14.6.5 重采样聚合307
        14.6.6 时间类型间转换307
        14.6.7 超出时间戳范围时间308
        14.6.8 区间间隔309
        14.6.9 小结311
        14.7 本章小结312
        第六部分 可视化
        第15章 Pandas样式314
        15.1 内置样式314
        15.1.1 样式功能314
        15.1.2 Styler对象315
        15.1.3 空值高亮315
        15.1.4 极值高亮316
        15.1.5 背景渐变317
        15.1.6 条形图318
        15.1.7 小结320
        15.2 显示格式320
        15.2.1 语法结构320
        15.2.2 常用方法320
        15.2.3 综合运用321
        15.2.4 小结321
        15.3 样式高级操作322
        15.3.1 样式配置操作322
        15.3.2 表格CSS样式323
        15.3.3 应用函数324
        15.3.4 样式复用325
        15.3.5 样式清除325
        15.3.6 导出Excel326
        15.3.7 生成HTML326
        15.3.8 小结327
        15.4 本章小结327
        第16章 Pandas可视化328
        16.1 plot()方法328
        16.1.1 plot()概述328
        16.1.2 plot()基础方法329
        16.1.3 图形类型331
        16.1.4 x轴和y轴331
        16.1.5 图形标题332
        16.1.6 字体大小332
        16.1.7 线条样式333
        16.1.8 背景辅助线334
        16.1.9 图例334
        16.1.10 图形大小334
        16.1.11 色系335
        16.1.12 绘图引擎336
        16.1.13 Matplotlib的其他参数337
        16.1.14 图形叠加337
        16.1.15 颜色的表示337
        16.1.16 解决图形中的中文乱码问题338
        16.1.17 小结340
        16.2 常用可视化图形340
        16.2.1 折线图plot.line340
        16.2.2 饼图plot.pie342
        16.2.3 柱状图plot.bar345
        16.2.4 直方图plot.hist348
        16.2.5 箱形图plot.box351
        16.2.6 面积图plot.area353
        16.2.7 散点图plot.scatter354
        16.2.8 六边形分箱图plot.hexbin356
        16.2.9 小结357
        16.3 本章小结357
        第七部分 实战案例
        第17章 Pandas实战案例360
        17.1 实战思想360
        17.1.1 链式方法360
        17.1.2 代码思路362
        17.1.3 分析方法366
        17.1.4 分析流程368
        17.1.5 分析工具368
        17.1.6 小结369
        17.2 数据处理案例370
        17.2.1 剧组表格道具370
        17.2.2 当月最后一个星期三371
        17.2.3 同组数据转为同一行372
        17.2.4 相关性最强的两个变量373
        17.2.5 全表最大值的位置375
        17.2.6 编写年会抽奖程序376
        17.2.7 北京各区无新增新冠肺炎确诊病例天数377
        17.2.8 生成SQL378
        17.2.9 圣诞节的星期分布379
        17.2.10 试验三天中恰有两天下雨的概率381
        17.2.11 计算平均打卡上班时间382
        17.2.12 小结383
        17.3 综合案例383
        17.3.1 中国经济发展分析383
        17.3.2 新冠肺炎疫情分析387
        17.3.3 利用爬虫获取房价390
        17.3.4 全国城市房价分析392
        17.3.5 客服对话文本分析396
        17.3.6 RFM用户分层399
        17.3.7 自动邮件报表404
        17.3.8 鸢尾花品种预测407
        17.3.9 小结410
        17.4 本章小结410
     · · · · · ·     (收起)"
35768338,Vue.js设计与实现,9.6,(197人评价),霍春阳 / 人民邮电出版社 / 2022-2-10 / 119.8,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章...,https://book.douban.com/subject/35768338/,https://img9.doubanio.com/view/subject/s/public/s34120804.jpg,119.8,9787115583864,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章，分为六篇，主要内容包括：框架设计概览、响应系统、渲染器、组件化、编译器和服务端渲染等。通过阅读本书，对Vue.js 2/3具有上手经验的开发人员能够进一步理解Vue.js框架的实现细节，没有Vue.js使用经验但对框架设计感兴趣的前端开发人员，能够快速掌握Vue.js的设计原理。,霍春阳（HcySunYang） Vue.js官方团队成员，专注于Web研发领域，是Vue.js 3的核心贡献者之一，Vue.js文档生成工具Vuese的作者，技术社区活跃者，曾撰写大量颇受好评的技术博客。,"序
        前言
        第　1章 权衡的艺术　2
        1．1　命令式和声明式　2
        1．2　性能与可维护性的权衡　3
        1．3　虚拟DOM的性能到底如何　4
        1．4　运行时和编译时　8
        1．5　总结　11
        第　2章 框架设计的核心要素　12
        2．1　提升用户的开发体验　12
        2．2　控制框架代码的体积　14
        2．3　框架要做到良好的Tree-Shaking　15
        2．4　框架应该输出怎样的构建产物　17
        2．5　特性开关　19
        2．6　错误处理　21
        2．7　良好的TypeScript类型支持　23
        2．8　总结　25
        第3章　Vue．js 3的设计思路　27
        3．1　声明式地描述UI　27
        3．2　初识渲染器　29
        3．3　组件的本质　32
        3．4　模板的工作原理　34
        3．5　Vue．js是各个模块组成的有机整体　36
        3．6　总结　37
        第4章　响应系统的作用与实现　40
        4．1　响应式数据与副作用函数　40
        4．2　响应式数据的基本实现　41
        4．3　设计一个完善的响应系统　43
        4．4　分支切换与cleanup　50
        4．5　嵌套的effect与effect栈　55
        4．6　避免无限递归循环　59
        4．7　调度执行　60
        4．8　计算属性computed与lazy　64
        4．9　watch的实现原理　71
        4．10　立即执行的watch与回调执行时机　75
        4．11　过期的副作用　77
        4．12　总结　82
        第5章　非原始值的响应式方案　84
        5．1　理解Proxy和Reflect　84
        5．2　JavaScript对象及Proxy的工作原理　88
        5．3　如何代理Object　92
        5．4　合理地触发响应　102
        5．5　浅响应与深响应　108
        5．6　只读和浅只读　110
        5．7　代理数组　113
        5．7．1　数组的索引与 length　114
        5．7．2　遍历数组　119
        5．7．3　数组的查找方法　124
        5．7．4　隐式修改数组长度的原型方法　129
        5．8　代理Set和Map　132
        5．8．1　如何代理Set和Map　133
        5．8．2　建立响应联系　137
        5．8．3　避免污染原始数据　140
        5．8．4　处理forEach　143
        5．8．5　迭代器方法　147
        5．8．6　values与keys方法　152
        5．9　总结　155
        第6章　原始值的响应式方案　158
        6．1　引入ref的概念　158
        6．2　响应丢失问题　160
        6．3　自动脱ref　164
        6．4　总结　166
        第7章　渲染器的设计　170
        7．1　渲染器与响应系统的结合　170
        7．2　渲染器的基本概念　172
        7．3　自定义渲染器　175
        7．4　总结　179
        第8章　挂载与更新　180
        8．1　挂载子节点和元素的属性　180
        8．2　HTML Attributes与DOM Properties　182
        8．3　正确地设置元素属性　184
        8．4　class的处理　189
        8．5　卸载操作　192
        8．6　区分vnode的类型　195
        8．7　事件的处理　196
        8．8　事件冒泡与更新时机问题　201
        8．9　更新子节点　204
        8．10　文本节点和注释节点　209
        8．11　Fragment　212
        8．12　总结　215
        第9章　简单Diff算法　218
        9．1　减少DOM操作的性能开销　218
        9．2　DOM复用与key的作用　221
        9．3　找到需要移动的元素　225
        9．4　如何移动元素　228
        9．5　添加新元素　233
        9．6　移除不存在的元素　238
        9．7　总结　241
        第　10章 双端Diff算法　242
        10．1　双端比较的原理　242
        10．2　双端比较的优势　252
        10．3　非理想状况的处理方式　255
        10．4　添加新元素　263
        10．5　移除不存在的元素　268
        10．6　总结　270
        第　11章 快速Diff算法　271
        11．1　相同的前置元素和后置元素　271
        11．2　判断是否需要进行DOM移动操作　279
        11．3　如何移动元素　288
        11．4　总结　296
        第　12章 组件的实现原理　298
        12．1　渲染组件　298
        12．2　组件状态与自更新　301
        12．3　组件实例与组件的生命周期　304
        12．4　props与组件的被动更新　306
        12．5　setup函数的作用与实现　311
        12．6　组件事件与emit的实现　314
        12．7　插槽的工作原理与实现　316
        12．8　注册生命周期　318
        12．9　总结　320
        第　13章 异步组件与函数式组件　322
        13．1　异步组件要解决的问题　322
        13．2　异步组件的实现原理　324
        13．2．1　封装defineAsyncComponent函数　324
        13．2．2　超时与Error组件　325
        13．2．3　延迟与Loading组件　328
        13．2．4　重试机制　331
        13．3　函数式组件　333
        13．4　总结　335
        第　14章 内建组件和模块　337
        14．1　KeepAlive组件的实现原理　337
        14．1．1　组件的激活与失活　337
        14．1．2　include和exclude　342
        14．1．3　缓存管理　343
        14．2　Teleport组件的实现原理　346
        14．2．1　Teleport组件要解决的问题　346
        14．2．2　实现Teleport组件　347
        14．3　Transition组件的实现原理　350
        14．3．1　原生DOM的过渡　351
        14．3．2　实现Transition组件　356
        14．4　总结　360
        第　15章 编译器核心技术概览　364
        15．1　模板DSL的编译器　364
        15．2　parser的实现原理与状态机　368
        15．3　构造AST　374
        15．4　AST的转换与插件化架构　383
        15．4．1　节点的访问　383
        15．4．2　转换上下文与节点操作　387
        15．4．3　进入与退出　392
        15．5　将模板AST转为JavaScript AST　396
        15．6　代码生成　402
        15．7　总结　407
        第　16章 解析器　409
        16．1　文本模式及其对解析器的影响　409
        16．2　递归下降算法构造模板AST　413
        16．3　状态机的开启与停止　419
        16．4　解析标签节点　426
        16．5　解析属性　430
        16．6　解析文本与解码HTML实体　436
        16．6．1　解析文本　436
        16．6．2　解码命名字符引用　438
        16．6．3　解码数字字符引用　445
        16．7　解析插值与注释　449
        16．8　总结　451
        第　17章 编译优化　453
        17．1　动态节点收集与补丁标志　453
        17．1．1　传统Diff算法的问题　453
        17．1．2　Block与PatchFlags　454
        17．1．3　收集动态节点　457
        17．1．4　渲染器的运行时支持　459
        17．2　Block树　461
        17．2．1　带有v-if指令的节点　462
        17．2．2　带有v-for指令的节点　464
        17．2．3　Fragment的稳定性　465
        17．3　静态提升　466
        17．4　预字符串化　468
        17．5　缓存内联事件处理函数　469
        17．6　v-once　470
        17．7　总结　471
        第　18章 同构渲染　474
        18．1　CSR、SSR以及同构渲染　474
        18．2　将虚拟DOM渲染为HTML字符串　478
        18．3　将组件渲染为HTML字符串　484
        18．4　客户端激活的原理　489
        18．5　编写同构的代码　494
        18．5．1　组件的生命周期　494
        18．5．2　使用跨平台的API　496
        18．5．3　只在某一端引入模块　496
        18．5．4　避免交叉请求引起的状态污染　497
        18．5．5　组件　498
        18．6　总结　499
     · · · · · ·     (收起)"
33450010,动手学深度学习,9.3,(552人评价),阿斯顿·张（Aston Zhang）、李沐（Mu Li）、[美] 扎卡里·C. 立顿（Zachary C. Lipton）、[德] 亚历山大·J. 斯莫拉（Alexander J. Smola） / 人民邮电出版社 / 2019-6 / 85.00元,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的...,https://book.douban.com/subject/33450010/,https://img9.doubanio.com/view/subject/s/public/s32322795.jpg,85.00元,9787115490841,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的 Jupyter记事本，它将文字、公式、图像、代码和运行结果结合在了一起。此外，读者还可以访问并参与书中内容的讨论。 全书的内容分为3个部分：第一部分介绍深度学习的背景，提供预备知识，并包括深度学习最基础的概念和技术；第二部分描述深度学习计算的重要组成部分，还解释近年来令深度学习在多个领域大获成功的卷积神经网络和循环神经网络；第三部分评价优化算法，检验影响深度学习计算性能的重要因素，并分别列举深度学习在计算机视觉和自然语言处理中的重要应用。 本书同时覆盖深度学习的方法和实践，主要面向在校大学生、技术人员和研究人员。阅读本书需要读者了解基本的Python编程或附录中描述的线性代数、微分和概率基础。,"阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、Ne...(展开全部)




阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、NeurIPS、AISTATS、CVPR、KDD 、WSDM、OSDI）上发表过论文。 扎卡里·C. 立顿（Zachary C. Lipton） 亚马逊应用科学家，美国卡内基梅隆大学助理教授，美国加州大学圣迭戈分校博士。他专注于机器学习算法及其社会影响的研究，特别是在时序数据与序列决策上的深度学习。这类工作有着广泛的应用场景，包括医疗诊断、对话系统和产品推荐。他创立了博客“Approximately Correct”（approximatelycorrect.com）。 亚历山大·J. 斯莫拉（Alexander J. Smola） 亚马逊副总裁/ 杰出科学家，德国柏林工业大学计算机科学博士。他曾在澳大利亚国立大学、美国加州大学伯克利分校和卡内基梅隆大学任教。他发表了超过200 篇学术论文，并著有5 本书，其论文及书被引用超过10 万次。他的研究兴趣包括深度学习、贝叶斯非参数、核方法、统计建模和可扩展算法。","对本书的赞誉
        前言
        如何使用本书
        资源与支持
        主要符号表
        第1 章　深度学习简介… ………………… 1
        1.1　起源…………………………………………… 2
        1.2　发展…………………………………………… 4
        1.3　成功案例……………………………………… 6
        1.4　特点………………………………………… 7
        小结…………………………………………… 8
        练习…………………………………………… 8
        第2 章　预备知识… ……………………… 9
        2.1　获取和运行本书的代码……………………… 9
        2.1.1　获取代码并安装运行环境 … ……… 9
        2.1.2　更新代码和运行环境 … …………… 11
        2.1.3　使用GPU版的MXNet … ………… 11
        小结……………………………………………12
        练习……………………………………………12
        2.2　数据操作… ……………………………… 12
        2.2.1　创建NDArray ………………………12
        2.2.2　运算 …………………………………14
        2.2.3　广播机制 ……………………………16
        2.2.4　索引 …………………………………17
        2.2.5　运算的内存开销 ……………………17
        2.2.6　NDArray和NumPy相互变换………18
        小结……………………………………………19
        练习……………………………………………19
        2.3　自动求梯度… …………………………… 19
        2.3.1　简单例子 … …………………………19
        2.3.2　训练模式和预测模式 …………… 20
        2.3.3　对Python控制流求梯度 … …… 20
        小结……………………………………………21
        练习……………………………………………21
        2.4　查阅文档… ……………………………… 21
        2.4.1　查找模块里的所有函数和类 … ……21
        2.4.2　查找特定函数和类的使用 ……… 22
        2.4.3　在MXNet网站上查阅 …………… 23
        小结………………………………………… 24
        练习………………………………………… 24
        第3 章　深度学习基础… ……………… 25
        3.1　线性回归…………………………………… 25
        3.1.1　线性回归的基本要素 … ………… 25
        3.1.2　线性回归的表示方法 … ………… 28
        小结………………………………………… 30
        练习………………………………………… 30
        3.2　线性回归的从零开始实现… …………… 30
        3.2.1　生成数据集 … …………………… 30
        3.2.2　读取数据集 ……………………… 32
        3.2.3　初始化模型参数 ………………… 32
        3.2.4　定义模型 ………………………… 33
        3.2.5　定义损失函数 …………………… 33
        3.2.6　定义优化算法 …………………… 33
        3.2.7　训练模型 ………………………… 33
        小结………………………………………… 34
        练习………………………………………… 34
        3.3　线性回归的简洁实现… ………………… 35
        3.3.1　生成数据集 … …………………… 35
        3.3.2　读取数据集 ……………………… 35
        3.3.3　定义模型 ………………………… 36
        3.3.4　初始化模型参数 ………………… 36
        3.3.5　定义损失函数 …………………… 37
        3.3.6　定义优化算法 …………………… 37
        3.3.7　训练模型 ………………………… 37
        小结………………………………………… 38
        练习………………………………………… 38
        3.4　softmax回归… ………………………… 38
        3.4.1　分类问题 … ……………………… 38
        3.4.2　softmax回归模型… …………… 39
        3.4.3　单样本分类的矢量计算表达式…… 40
        3.4.4　小批量样本分类的矢量计算表达式 …………………………… 40
        3.4.5　交叉熵损失函数 ……………………41
        3.4.6　模型预测及评价 ………………… 42
        小结………………………………………… 42
        练习………………………………………… 42
        3.5　图像分类数据集（Fashion-MNIST）… ……………… 42
        3.5.1　获取数据集 … …………………… 42
        3.5.2　读取小批量 ……………………… 44
        小结………………………………………… 45
        练习………………………………………… 45
        3.6　softmax回归的从零开始实现… ……… 45
        3.6.1　读取数据集 … …………………… 45
        3.6.2　初始化模型参数 ………………… 45
        3.6.3　实现softmax运算 … …………… 46
        3.6.4　定义模型 ………………………… 46
        3.6.5　定义损失函数 …………………… 47
        3.6.6　计算分类准确率 ………………… 47
        3.6.7　训练模型 ………………………… 48
        3.6.8　预测… …………………………… 48
        小结………………………………………… 49
        练习………………………………………… 49
        3.7　softmax回归的简洁实现… …………… 49
        3.7.1　读取数据集 … …………………… 49
        3.7.2　定义和初始化模型 ……………… 50
        3.7.3　softmax和交叉熵损失函数 … … 50
        3.7.4　定义优化算法 …………………… 50
        3.7.5　训练模型 ………………………… 50
        小结………………………………………… 50
        练习………………………………………… 50
        3.8　多层感知机… …………………………… 51
        3.8.1　隐藏层 … ……………………………51
        3.8.2　激活函数 ………………………… 52
        3.8.3　多层感知机 ……………………… 55
        小结………………………………………… 55
        练习………………………………………… 55
        3.9　多层感知机的从零开始实现… ………… 56
        3.9.1　读取数据集 … …………………… 56
        3.9.2　定义模型参数 …………………… 56
        3.9.3　定义激活函数 …………………… 56
        3.9.4　定义模型 ………………………… 56
        3.9.5　定义损失函数 …………………… 57
        3.9.6　训练模型 ………………………… 57
        小结………………………………………… 57
        练习………………………………………… 57
        3.10　多层感知机的简洁实现………………… 57
        3.10.1　定义模型 ………………………… 58
        3.10.2　训练模型 … …………………… 58
        小结………………………………………… 58
        练习………………………………………… 58
        3.11　模型选择、欠拟合和过拟合… ………… 58
        3.11.1　训练误差和泛化误差 …………… 59
        3.11.2　模型选择 ………………………… 59
        3.11.3　欠拟合和过拟合 ………………… 60
        3.11.4　多项式函数拟合实验 ……………61
        小结………………………………………… 65
        练习………………………………………… 65
        3.12　权重衰减………………………………… 65
        3.12.1　方法 ……………………………… 65
        3.12.2　高维线性回归实验 … ………… 66
        3.12.3　从零开始实现 … ……………… 66
        3.12.4　简洁实现 … …………………… 68
        小结………………………………………… 70
        练习………………………………………… 70
        3.13　丢弃法…………………………………… 70
        3.13.1　方法 ……………………………… 70
        3.13.2　从零开始实现 … …………………71
        3.13.3　简洁实现 … …………………… 73
        小结………………………………………… 74
        练习………………………………………… 74
        3.14　正向传播、反向传播和计算图………… 74
        3.14.1　正向传播 ……………………… 74
        3.14.2　正向传播的计算图 … ………… 75
        3.14.3　反向传播 … …………………… 75
        3.14.4　训练深度学习模型 … ………… 76
        小结………………………………………… 77
        练习………………………………………… 77
        3.15　数值稳定性和模型初始化……………… 77
        3.15.1　衰减和爆炸 ……………………… 77
        3.15.2　随机初始化模型参数 … ……… 78
        小结………………………………………… 78
        练习………………………………………… 79
        3.16　实战Kaggle比赛：房价预测… ……… 79
        3.16.1　Kaggle比赛 … ………………… 79
        3.16.2　读取数据集 … ………………… 80
        3.16.3　预处理数据集 … …………………81
        3.16.4　训练模型 … …………………… 82
        3.16.5　k 折交叉验证 …………………… 82
        3.16.6　模型选择 … …………………… 83
        3.16.7　预测并在Kaggle提交结果… … 84
        小结………………………………………… 85
        练习………………………………………… 85
        第4 章　深度学习计算… ……………… 86
        4.1　模型构造………………………………… 86
        4.1.1　继承Block类来构造模型 … …… 86
        4.1.2　Sequential类继承自Block类…………………………… 87
        4.1.3　构造复杂的模型… ……………… 88
        小结………………………………………… 89
        练习………………………………………… 90
        4.2　模型参数的访问、初始化和共享… …… 90
        4.2.1　访问模型参数 … ………………… 90
        4.2.2　初始化模型参数 ………………… 92
        4.2.3　自定义初始化方法 ……………… 93
        4.2.4　共享模型参数 …………………… 94
        小结………………………………………… 94
        练习………………………………………… 94
        4.3　模型参数的延后初始化… ……………… 95
        4.3.1　延后初始化 … …………………… 95
        4.3.2　避免延后初始化 ………………… 96
        小结………………………………………… 96
        练习………………………………………… 97
        4.4　自定义层… ……………………………… 97
        4.4.1　不含模型参数的自定义层 … …… 97
        4.4.2　含模型参数的自定义层 ………… 98
        小结………………………………………… 99
        练习………………………………………… 99
        4.5　读取和存储… …………………………… 99
        4.5.1　读写NDArray… ………………… 99
        4.5.2　读写Gluon模型的参数… ……… 100
        小结………………………………………… 101
        练习………………………………………… 101
        4.6　GPU计算………………………………… 101
        4.6.1　计算设备 … ……………………… 102
        4.6.2　NDArray的GPU计算…………… 102
        4.6.3　Gluon的GPU计算 ……………… 104
        小结………………………………………… 105
        练习………………………………………… 105
        第5 章　卷积神经网络… ……………… 106
        5.1　二维卷积层………………………………… 106
        5.1.1　二维互相关运算 … ……………… 106
        5.1.2　二维卷积层 … …………………… 107
        5.1.3　图像中物体边缘检测 … ………… 108
        5.1.4　通过数据学习核数组 … ………… 109
        5.1.5　互相关运算和卷积运算 … ……… 109
        5.1.6　特征图和感受野… ……………… 110
        小结………………………………………… 110
        练习………………………………………… 110
        5.2　填充和步幅… …………………………… 111
        5.2.1　填充 … …………………………… 111
        5.2.2　步幅 ……………………………… 112
        小结………………………………………… 113
        练习………………………………………… 113
        5.3　多输入通道和多输出通道… …………… 114
        5.3.1　多输入通道 … …………………… 114
        5.3.2　多输出通道… …………………… 115
        5.3.3　1×1卷积层 ……………………… 116
        小结………………………………………… 117
        练习………………………………………… 117
        5.4　池化层… ………………………………… 117
        5.4.1　二维最大池化层和平均池化层 … ………………………… 117
        5.4.2　填充和步幅 ……………………… 119
        5.4.3　多通道 …………………………… 120
        小结………………………………………… 120
        练习………………………………………… 121
        5.5　卷积神经网络（LeNet）… …………… 121
        5.5.1　LeNet模型 … …………………… 121
        5.5.2　训练模型… ……………………… 122
        小结………………………………………… 124
        练习………………………………………… 124
        5.6　深度卷积神经网络（AlexNet）… …… 124
        5.6.1　学习特征表示 … ………………… 125
        5.6.2　AlexNet… ……………………… 126
        5.6.3　读取数据集 ……………………… 127
        5.6.4　训练模型 ………………………… 128
        小结………………………………………… 128
        练习………………………………………… 129
        5.7　使用重复元素的网络（VGG）………… 129
        5.7.1　VGG块 …………………………… 129
        5.7.2　VGG网络 … …………………… 129
        5.7.3　训练模型… ……………………… 130
        小结………………………………………… 131
        练习………………………………………… 131
        5.8　网络中的网络（NiN）… ……………… 131
        5.8.1　NiN块 … ………………………… 131
        5.8.2　NiN模型 … ……………………… 132
        5.8.3　训练模型… ……………………… 133
        小结………………………………………… 134
        练习………………………………………… 134
        5.9　含并行连结的网络（GoogLeNet）…… 134
        5.9.1　Inception块 ……………………… 134
        5.9.2　GoogLeNet模型 … …………… 135
        5.9.3　训练模型 ………………………… 137
        小结………………………………………… 137
        练习………………………………………… 137
        5.10　批量归一化……………………………… 138
        5.10.1　批量归一化层 ………………… 138
        5.10.2　从零开始实现 … ……………… 139
        5.10.3　使用批量归一化层的LeNet … … 140
        5.10.4　简洁实现 … …………………… 141
        小结………………………………………… 142
        练习………………………………………… 142
        5.11　残差网络（ResNet） ……………… 143
        5.11.1　残差块 …………………………… 143
        5.11.2　ResNet模型… ………………… 145
        5.11.3　训练模型………………………… 146
        小结………………………………………… 146
        练习………………………………………… 146
        5.12　稠密连接网络（DenseNet）………… 147
        5.12.1　稠密块 …………………………… 147
        5.12.2　过渡层 … ……………………… 148
        5.12.3　DenseNet模型 ………………… 148
        5.12.4　训练模型 … …………………… 149
        小结………………………………………… 149
        练习………………………………………… 149
        第6 章　循环神经网络… ……………… 150
        6.1　语言模型………………………………… 150
        6.1.1　语言模型的计算 … ……………… 151
        6.1.2　n 元语法 … ……………………… 151
        小结………………………………………… 152
        练习………………………………………… 152
        6.2　循环神经网络… ………………………… 152
        6.2.1　不含隐藏状态的神经网络 … …… 152
        6.2.2　含隐藏状态的循环神经网络… … 152
        6.2.3　应用：基于字符级循环神经网络的语言模型 … ……………………… 154
        小结………………………………………… 155
        练习………………………………………… 155
        6.3　语言模型数据集（歌词）…… 155
        6.3.1　读取数据集 … …………………… 155
        6.3.2　建立字符索引 …………………… 156
        6.3.3　时序数据的采样 ………………… 156
        小结………………………………………… 158
        练习………………………………………… 159
        6.4　循环神经网络的从零开始实现… ……… 159
        6.4.1　one-hot向量 … ………………… 159
        6.4.2　初始化模型参数 ………………… 160
        6.4.3　定义模型 ………………………… 160
        6.4.4　定义预测函数 …………………… 161
        6.4.5　裁剪梯度 ………………………… 161
        6.4.6　困惑度 …………………………… 162
        6.4.7　定义模型训练函数 ……………… 162
        6.4.8　训练模型并创作歌词 …………… 163
        小结………………………………………… 164
        练习………………………………………… 164
        6.5　循环神经网络的简洁实现… …………… 165
        6.5.1　定义模型 … ……………………… 165
        6.5.2　训练模型 ………………………… 166
        小结………………………………………… 168
        练习………………………………………… 168
        6.6　通过时间反向传播… …………………… 168
        6.6.1　定义模型 … ……………………… 168
        6.6.2　模型计算图 ……………………… 169
        6.6.3　方法 ……………………………… 169
        小结………………………………………… 170
        练习………………………………………… 170
        6.7　门控循环单元（GRU）………………… 170
        6.7.1　门控循环单元 … ………………… 171
        6.7.2　读取数据集 ……………………… 173
        6.7.3　从零开始实现 …………………… 173
        6.7.4　简洁实现 ………………………… 175
        小结………………………………………… 176
        练习………………………………………… 176
        6.8　长短期记忆（LSTM）… ……………… 176
        6.8.1　长短期记忆 … …………………… 176
        6.8.2　读取数据集 ……………………… 179
        6.8.3　从零开始实现 …………………… 179
        6.8.4　简洁实现 ………………………… 181
        小结………………………………………… 181
        练习………………………………………… 182
        6.9　深度循环神经网络… …………………… 182
        小结………………………………………… 183
        练习………………………………………… 183
        6.10　双向循环神经网络……………………… 183
        小结………………………………………… 184
        练习………………………………………… 184
        第7 章　优化算法… …………………… 185
        7.1　优化与深度学习…………………………… 185
        7.1.1　优化与深度学习的关系 … ……… 185
        7.1.2　优化在深度学习中的挑战 … …… 186
        小结………………………………………… 188
        练习………………………………………… 189
        7.2　梯度下降和随机梯度下降… …………… 189
        7.2.1　一维梯度下降 … ………………… 189
        7.2.2　学习率 …………………………… 190
        7.2.3　多维梯度下降 …………………… 191
        7.2.4　随机梯度下降 …………………… 193
        小结………………………………………… 194
        练习………………………………………… 194
        7.3　小批量随机梯度下降… ………………… 194
        7.3.1　读取数据集 … …………………… 195
        7.3.2　从零开始实现 …………………… 196
        7.3.3　简洁实现 ………………………… 198
        小结………………………………………… 199
        练习………………………………………… 199
        7.4　动量法… …………………………………200
        7.4.1　梯度下降的问题 … ……………… 200
        7.4.2　动量法 …………………………… 201
        ·6·　目　　录
        7.4.3　从零开始实现 …………………… 203
        7.4.4　简洁实现 ………………………… 205
        小结………………………………………… 205
        练习………………………………………… 205
        7.5　AdaGrad算法……………………………206
        7.5.1　算法 … …………………………… 206
        7.5.2　特点 ……………………………… 206
        7.5.3　从零开始实现 …………………… 208
        7.5.4　简洁实现 ………………………… 209
        小结………………………………………… 209
        练习………………………………………… 209
        7.6　RMSProp算法… ………………………209
        7.6.1　算法 … …………………………… 210
        7.6.2　从零开始实现 …………………… 211
        7.6.3　简洁实现 ………………………… 212
        小结………………………………………… 212
        练习………………………………………… 212
        7.7　AdaDelta算法… ……………………… 212
        7.7.1　算法… …………………………… 212
        7.7.2　从零开始实现 …………………… 213
        7.7.3　简洁实现 ………………………… 214
        小结………………………………………… 214
        练习………………………………………… 214
        7.8　Adam算法… …………………………… 215
        7.8.1　算法 … …………………………… 215
        7.8.2　从零开始实现 …………………… 216
        7.8.3　简洁实现 ………………………… 216
        小结………………………………………… 217
        练习………………………………………… 217
        第8 章　计算性能… …………………… 218
        8.1　命令式和符号式混合编程… …………… 218
        8.1.1　混合式编程取两者之长 … ……… 220
        8.1.2　使用HybridSequential类构造模型 … …………………………… 220
        8.1.3　使用HybridBlock类构造模型… …………………………… 222
        小结………………………………………… 224
        练习………………………………………… 224
        8.2　异步计算… ………………………………224
        8.2.1　MXNet中的异步计算 …………… 224
        8.2.2　用同步函数让前端等待计算结果 … …………………………… 226
        8.2.3　使用异步计算提升计算性能 …… 226
        8.2.4　异步计算对内存的影响 ………… 227
        小结………………………………………… 229
        练习………………………………………… 229
        8.3　自动并行计算… …………………………229
        8.3.1　CPU和GPU的并行计算 … …… 230
        8.3.2　计算和通信的并行计算 ………… 231
        小结………………………………………… 231
        练习………………………………………… 231
        8.4　多GPU计算……………………………… 232
        8.4.1　数据并行 … ……………………… 232
        8.4.2　定义模型 ………………………… 233
        8.4.3　多GPU之间同步数据 … ……… 234
        8.4.4　单个小批量上的多GPU训练 … …………………………… 236
        8.4.5　定义训练函数 …………………… 236
        8.4.6　多GPU训练实验 … …………… 237
        小结………………………………………… 237
        练习………………………………………… 237
        8.5　多GPU计算的简洁实现………………… 237
        8.5.1　多GPU上初始化模型参数……… 238
        8.5.2　多GPU训练模型 … …………… 239
        小结………………………………………… 241
        练习………………………………………… 241
        第9 章　计算机视觉… ………………… 242
        9.1　图像增广…………………………………242
        9.1.1　常用的图像增广方法 … ………… 243
        9.1.2　使用图像增广训练模型 … ……… 246
        小结………………………………………… 250
        练习………………………………………… 250
        9.2　微调… ……………………………………250
        热狗识别 … ……………………………… 251
        小结………………………………………… 255
        练习………………………………………… 255
        目　　录　·7·
        9.3　目标检测和边界框… ……………………255
        边界框 … ………………………………… 256
        小结………………………………………… 257
        练习………………………………………… 257
        9.4　锚框… …………………………………… 257
        9.4.1　生成多个锚框… ………………… 257
        9.4.2　交并比 …………………………… 259
        9.4.3　标注训练集的锚框 ……………… 260
        9.4.4　输出预测边界框… ……………… 263
        小结………………………………………… 265
        练习………………………………………… 265
        9.5　多尺度目标检测… ………………………265
        小结………………………………………… 268
        练习………………………………………… 268
        9.6　目标检测数据集（皮卡丘）… …………268
        9.6.1　获取数据集 … …………………… 269
        9.6.2　读取数据集… …………………… 269
        9.6.3　图示数据 ………………………… 270
        小结………………………………………… 270
        练习………………………………………… 271
        9.7　单发多框检测（SSD）… ……………… 271
        9.7.1　定义模型… ……………………… 271
        9.7.2　训练模型 ………………………… 275
        9.7.3　预测目标 ………………………… 277
        小结………………………………………… 278
        练习………………………………………… 278
        9.8　区域卷积神经网络（R-CNN）系列……280
        9.8.1　R-CNN … ……………………… 280
        9.8.2　Fast R-CNN …………………… 281
        9.8.3　Faster R-CNN ………………… 283
        9.8.4　Mask R-CNN … ……………… 284
        小结………………………………………… 285
        练习………………………………………… 285
        9.9　语义分割和数据集… ……………………285
        9.9.1　图像分割和实例分割 … ………… 285
        9.9.2　Pascal VOC2012语义分割数据集 … ………………………… 286
        小结………………………………………… 290
        练习………………………………………… 290
        9.10　全卷积网络（FCN）… ………………290
        9.10.1　转置卷积层 …………………… 291
        9.10.2　构造模型 … …………………… 292
        9.10.3　初始化转置卷积层……………… 294
        9.10.4　读取数据集 … ………………… 295
        9.10.5　训练模型………………………… 296
        9.10.6　预测像素类别…………………… 296
        小结………………………………………… 297
        练习………………………………………… 297
        9.11　样式迁移… ………………………………298
        9.11.1　方法 ……………………………… 298
        9.11.2　读取内容图像和样式图像……… 299
        9.11.3　预处理和后处理图像 ………… 300
        9.11.4　抽取特征 ……………………… 301
        9.11.5　定义损失函数 ………………… 302
        9.11.6　创建和初始化合成图像 ……… 303
        9.11.7　训练模型………………………… 304
        小结………………………………………… 306
        练习………………………………………… 306
        9.12　实战Kaggle比赛：图像
        分类（CIFAR-10）……………………306
        9.12.1　获取和整理数据集 ……………… 307
        9.12.2　图像增广 … …………………… 310
        9.12.3　读取数据集 … ………………… 310
        9.12.4　定义模型………………………… 311
        9.12.5　定义训练函数 … ……………… 312
        9.12.6　训练模型 … …………………… 312
        9.12.7　对测试集分类并在Kaggle
        提交结果 … …………………… 313
        小结………………………………………… 313
        练习………………………………………… 313
        9.13　实战Kaggle比赛：狗的品种
        识别（ImageNet Dogs）…………… 314
        9.13.1　获取和整理数据集 …………… 315
        9.13.2　图像增广 … …………………… 316
        9.13.3　读取数据集 … ………………… 317
        9.13.4　定义模型 … …………………… 318
        9.13.5　定义训练函数 … ……………… 318
        9.13.6　训练模型 … …………………… 319
        ·8·　目　　录
        9.13.7　对测试集分类并在Kaggle提交结果 … …………………… 319
        小结………………………………………… 320
        练习………………………………………… 320
        第10 章　自然语言处理………………… 321
        10.1　词嵌入（word2vec）………………… 321
        10.1.1　为何不采用one-hot向量… …… 321
        10.1.2　跳字模型 ………………………… 322
        10.1.3　连续词袋模型 …………………… 323
        小结………………………………………… 325
        练习………………………………………… 325
        10.2　近似训练…………………………………325
        10.2.1　负采样 …………………………… 325
        10.2.2　层序softmax …………………… 326
        小结………………………………………… 327
        练习………………………………………… 328
        10.3　word2vec的实现………………………328
        10.3.1　预处理数据集 …………………… 328
        10.3.2　负采样 … ……………………… 331
        10.3.3　读取数据集 … ………………… 331
        10.3.4　跳字模型 … …………………… 332
        10.3.5　训练模型 … …………………… 333
        10.3.6　应用词嵌入模型 … …………… 335
        小结………………………………………… 336
        练习………………………………………… 336
        10.4　子词嵌入（fastText）… ……………336
        小结………………………………………… 337
        练习………………………………………… 337
        10.5　全局向量的词嵌入（GloVe）…………337
        10.5.1　GloVe模型 …………………… 338
        10.5.2　从条件概率比值理解GloVe模型……………………… 339
        小结………………………………………… 340
        练习………………………………………… 340
        10.6　求近义词和类比词………………………340
        10.6.1　使用预训练的词向量 ………… 340
        10.6.2　应用预训练词向量 … ………… 341
        小结………………………………………… 343
        练习………………………………………… 343
        10.7　文本情感分类：使用循环神经网络…… 343
        10.7.1　文本情感分类数据集 ………… 343
        10.7.2　使用循环神经网络的模型……… 345
        小结………………………………………… 347
        练习………………………………………… 347
        10.8　文本情感分类：使用卷积神经网络（textCNN）… …………………347
        10.8.1　一维卷积层 … ………………… 348
        10.8.2　时序最大池化层 … …………… 349
        10.8.3　读取和预处理IMDb数据集 … ……………………… 350
        10.8.4　textCNN模型 … ……………… 350
        小结………………………………………… 353
        练习………………………………………… 353
        10.9　编码器-解码器（seq2seq）…………353
        10.9.1　编码器 ………………………… 354
        10.9.2　解码器 … ……………………… 354
        10.9.3　训练模型………………………… 355
        小结………………………………………… 355
        练习………………………………………… 355
        10.10　 束搜索… ………………………………355
        10.10.1　贪婪搜索 … …………………… 356
        10.10.2　穷举搜索 ……………………… 357
        10.10.3　束搜索 ………………………… 357
        小结………………………………………… 358
        练习………………………………………… 358
        10.11　注意力机制… …………………………358
        10.11.1　计算背景变量 … ……………… 359
        10.11.2　更新隐藏状态 … ……………… 360
        10.11.3　发展… ………………………… 361
        小结………………………………………… 361
        练习………………………………………… 361
        10.12　机器翻译… …………………………… 361
        10.12.1　读取和预处理数据集… ……… 361
        10.12.2　含注意力机制的编码器-解码器 … …………… 363
        10.12.3　训练模型 ……………………… 365
        10.12.4　预测不定长的序列… ………… 367
        10.12.5　评价翻译结果 ………………… 367
        小结………………………………………… 369
        练习………………………………………… 369
        附录A　数学基础… …………………… 370
        附录B　使用 Jupyter 记事本… ……… 376
        附录C　使用 AWS 运行代码…………… 381
        附录D　GPU 购买指南………………… 388
        附录E　如何为本书做贡献… ………… 391
        附录F　d2lzh 包索引…………………… 395
        附录G　中英文术语对照表… ………… 397
        参考文献………………………………… 402
        索引……………………………………… 407
     · · · · · ·     (收起)"
26349607,MATLAB之父:编程实践(中译本),9.3,(20人评价),[ MEI ] Cleve Moler / 薛定宇 / 北京航空航天大学出版社 / 2014-3-1 / 39.9,《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Compu...,https://book.douban.com/subject/26349607/,https://img9.doubanio.com/view/subject/s/public/s28031915.jpg,39.9,9787512414655,"《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求...(展开全部)





《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求式的好奇精神。强烈的好奇心，是克利夫给人留下的最深印象，大到人文历史风土人情，小到会议讲座礼尚往来，他都保持着一种童真般的好奇。这种强烈的好奇心也可以从这本书涉猎广泛的内容中得到体会―― 矩阵、历法、谷歌网页排名、音乐、天体运行、分形图、生命进化、数独等等包罗万象。 这些精彩的内容连同生动文笔都在薛定宇老师的译本中得到了很好的体现。薛老师自己的书在读者中享有很高声誉，我最早拜读的就是他写的自动控制领域经典的教材《控制系统计算机辅助设计―― MATLAB 语言与应用》，结构严谨，思维缜密，内容翔实。这种风格在此书中文版的翻译中与原文达到了奇妙融合，使读者在领略克利夫的独特思路时逻辑清晰，而且兴趣盎然，一定是一次非常愉快的阅读体验。 《MATLAB 之父：编程实践》是北京航空航天大学出版社与迈斯沃克公司在图书合作方面的一个杰作，是迈斯沃克公司近两年中国图书计划中最重要的一个项目。《MATLAB之父：编程实践》一书也获得国内最大的MATLAB/Simulink技术交流平台——MATLAB中文论坛的鼎力推荐,MATLAB中文论坛的“MATLAB读书频道”为本书提供了专门版块供读者交流，以期共同进步。","作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国...(展开全部)




作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国家工程院院士，并获多项荣誉，包括瑞典林学平大学荣誉学位，加拿大滑铁卢大学荣誉数学博士学位，丹麦科技大学荣誉博士等。Cleve还获得IEEE计算机学会的2012年计算机先驱奖。","写在前面
        译者的话
        前言
        第1章迭代（Iteration）1
        第2章斐波那契数（FibonacciNumbers）15
        第3章日历与时钟（CalendarsandClocks）29
        第4章矩阵（Matrices）39
        第5章线性方程组（LinearEquations）53
        第6章蕨型叶分形（FractalFern）63
        第7章谷歌的网页排名值（GooglePageRank）71
        第8章指数函数（ExponentialFunction）85
        第9章T形积木（TPuzzle）99
        第10章幻方问题（MagicSquares）107
        第11章井字棋的魅力（TicTacToeMagic）123
        第12章生命游戏（GameofLife）131
        第13章曼德勃罗集（MandelbrotSet）141
        第14章数独（Sudoku）159
        第15章常微分方程（OrdinaryDifferentialEquations）173
        第16章捕食者与猎物模型（Predator-PreyModel）185
        第17章轨道（Orbits）191
        第18章浅水方程（ShallowWaterEquations）207
        第19章摩尔斯电码（MorseCode）211
        第20章音乐（Music）227
     · · · · · ·     (收起)"
35602582,现代C++语言核心特性解析,8.9,(46人评价),谢丙堃 / 人民邮电出版社 / 2021-10,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还...,https://book.douban.com/subject/35602582/,https://img3.doubanio.com/view/subject/s/public/s33999027.jpg,,9787115564177,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理，让读者能够知其然也知其所以然。本书适合出于工作需要而学习 C++ 新特性的 C++ 从业者，也适合对 C++ 新特性有浓烈兴趣的 C++ 爱好者。而对 C++ 入门者来说，也有必要在有一定的 C++ 基础后阅读本书，通过本书来进一步学习 C++ 的核心特性。本书的多媒体版本已由“盛格塾”以微信小程序方式推出，包含作者的语音讲解、插图、PPT 和示例代码。读者可以在手机上学习，也可以在线提问，与老师和其他同学互动。,谢丙堃，从事 C++ 开发工作十余年，先后在数家知名互联网公司担任 C++ 高级开发工程师、技术专家和技术经理。他也是 C++ 语言的爱好者，热衷于研究 C++ 语言的新特性以及 C++ 模板元编程技术。,"第1章　新基础类型（C++11～C++20） 1
        1.1 整数类型long long 1
        1.2 新字符类型char16_t和char32_t 4
        1.2.1 字符集和编码方法 4
        1.2.2 使用新字符类型char16_t和char32_t 5
        1.2.3 wchar_t存在的问题 6
        1.2.4 新字符串连接 7
        1.2.5 库对新字符类型的支持 7
        1.3 char8_t字符类型 8
        1.4 总结 8
        第2章　内联和嵌套命名空间（C++11～C++20） 9
        2.1 内联命名空间的定义和使用 9
        2.2 嵌套命名空间的简化语法 11
        2.3 总结 13
        第3章　auto占位符（C++11～C++17） 14
        3.1 重新定义的auto关键字 14
        3.2 推导规则 16
        3.3 什么时候使用auto 18
        3.4 返回类型推导 20
        3.5 lambda表达式中使用auto类型推导 20
        3.6 非类型模板形参占位符 21
        3.7 总结 22
        第4章　decltype说明符（C++11～C++17） 23
        4.1 回顾typeof和typeid 23
        4.2 使用decltype说明符 24
        4.3 推导规则 27
        4.4 cv限定符的推导 29
        4.5 decltype(auto) 30
        4.6 decltype(auto)作为非类型模板形参占位符 31
        4.7 总结 32
        第5章　函数返回类型后置（C++11） 33
        5.1 使用函数返回类型后置声明函数 33
        5.2 推导函数模板返回类型 34
        5.3 总结 36
        第6章　右值引用（C++11 C++17 C++20） 37
        6.1 左值和右值 37
        6.2 左值引用 39
        6.3 右值引用 40
        6.4 右值的性能优化空间 42
        6.5 移动语义 43
        6.6 值类别 47
        6.7 将左值转换为右值 48
        6.8 万能引用和引用折叠 50
        6.9 完美转发 52
        6.10 针对局部变量和右值引用的隐式移动操作 55
        6.11 总结 57
        第7章　lambda表达式（C++11～C++20） 58
        7.1 lambda表达式语法 58
        7.2 捕获列表 60
        7.2.1 作用域 60
        7.2.2 捕获值和捕获引用 61
        7.2.3 特殊的捕获方法 64
        7.3 lambda表达式的实现原理 65
        7.4 无状态lambda表达式 68
        7.5 在STL中使用lambda表达式 68
        7.6 广义捕获 69
        7.7 泛型lambda表达式 72
        7.8 常量lambda表达式和捕获*this 72
        7.9 捕获[=, this] 73
        7.10 模板语法的泛型lambda表达式 74
        7.11 可构造和可赋值的无状态lambda表达式 76
        7.12 总结 77
        第8章　非静态数据成员默认初始化（C++11 C++20） 78
        8.1 使用默认初始化 78
        8.2 位域的默认初始化 79
        8.3 总结 80
        第9章　列表初始化（C++11 C++20） 81
        9.1 回顾变量初始化 81
        9.2 使用列表初始化 82
        9.3 std::initializer_list详解 84
        9.4 使用列表初始化的注意事项 86
        9.4.1 隐式缩窄转换问题 86
        9.4.2 列表初始化的优先级问题 87
        9.5 指定初始化 88
        9.6 总结 90
        第10章　默认和删除函数（C++11） 91
        10.1 类的特殊成员函数 91
        10.2 显式默认和显式删除 95
        10.3 显式删除的其他用法 98
        10.4 explicit和=delete 99
        10.5 总结 100
        第11章　非受限联合类型（C++11） 101
        11.1 联合类型在C++中的局限性 101
        11.2 使用非受限联合类型 102
        11.3 总结 106
        第12章　委托构造函数（C++11） 107
        12.1 冗余的构造函数 107
        12.2 委托构造函数 110
        12.3 委托模板构造函数 114
        12.4 捕获委托构造函数的异常 115
        12.5 委托参数较少的构造函数 116
        12.6 总结 117
        第13章　继承构造函数（C++11） 118
        13.1 继承关系中构造函数的困局 118
        13.2 使用继承构造函数 119
        13.3 总结 123
        第14章　强枚举类型（C++11 C++17 C++20） 124
        14.1 枚举类型的弊端 124
        14.2 使用强枚举类型 129
        14.3 列表初始化有底层类型枚举对象 131
        14.4 使用using打开强枚举类型 133
        14.5 总结 135
        第15章　扩展的聚合类型（C++17 C++20） 136
        15.1 聚合类型的新定义 136
        15.2 聚合类型的初始化 137
        15.3 扩展聚合类型的兼容问题 139
        15.4 禁止聚合类型使用用户声明的构造函数 140
        15.5 使用带小括号的列表初始化聚合类型对象 142
        15.6 总结 143
        第16章　override和final说明符（C++11） 144
        16.1 重写、重载和隐藏 144
        16.2 重写引发的问题 145
        16.3 使用override说明符 145
        16.4 使用final说明符 146
        16.5 override和final说明符的特别之处 148
        16.6 总结 148
        第17章　基于范围的for循环（C++11 C++17 C++20） 149
        17.1 烦琐的容器遍历 149
        17.2 基于范围的for循环语法 150
        17.3 begin和end函数不必返回相同类型 151
        17.4 临时范围表达式的陷阱 152
        17.5 实现一个支持基于范围的for循环的类 153
        17.6 总结 155
        第18章　支持初始化语句的if和switch（C++17） 156
        18.1 支持初始化语句的if 156
        18.2 支持初始化语句的switch 159
        18.3 总结 160
        第19章　static_assert声明 161
        19.1 运行时断言 161
        19.2 静态断言的需求 162
        19.3 静态断言 163
        19.4 单参数static_assert 164
        19.5 总结 165
        第20章　结构化绑定（C++17 C++20） 166
        20.1 使用结构化绑定 166
        20.2 深入理解结构化绑定 169
        20.3 结构化绑定的3种类型 171
        20.3.1 绑定到原生数组 171
        20.3.2 绑定到结构体和类对象 172
        20.3.3 绑定到元组和类元组的对象 173
        20.4 实现一个类元组类型 175
        20.5 绑定的访问权限问题 178
        20.6 总结 179
        第21章　noexcept关键字（C++11 C++17 C++20） 180
        21.1 使用noexcept代替throw 180
        21.2 用noexcept来解决移动构造问题 183
        21.3 noexcept和throw() 185
        21.4 默认使用noexcept的函数 186
        21.5 使用noexcept的时机 189
        21.6 将异常规范作为类型的一部分 190
        21.7 总结 192
        第22章　类型别名和别名模板（C++11 C++14） 193
        22.1 类型别名 193
        22.2 别名模板 194
        22.3 总结 196
        第23章　指针字面量nullptr（C++11） 197
        23.1 零值整数字面量 197
        23.2 nullptr关键字 198
        23.3 总结 201
        第24章　三向比较（C++20） 202
        24.1 “太空飞船”（spaceship）运算符 202
        24.2 三向比较的返回类型 202
        24.2.1 std::strong_ordering 203
        24.2.2 std::weak_ordering 204
        24.2.3 std::partial_ordering 205
        24.3 对基础类型的支持 206
        24.4 自动生成的比较运算符函数 207
        24.5 兼容旧代码 210
        24.6 总结 211
        第25章　线程局部存储（C++11） 212
        25.1 操作系统和编译器对线程局部存储的支持 212
        25.2 thread_local说明符 213
        25.3 总结 217
        第26章　扩展的inline说明符（C++17） 218
        26.1 定义非常量静态成员变量的问题 218
        26.2 使用inline说明符 219
        26.3 总结 220
        第27章　常量表达式（C++11～C++20） 221
        27.1 常量的不确定性 221
        27.2 constexpr值 224
        27.3 constexpr函数 225
        27.4 constexpr构造函数 228
        27.5 对浮点的支持 230
        27.6 C++14标准对常量表达式函数的增强 230
        27.7 constexpr lambdas表达式 233
        27.8 constexpr的内联属性 235
        27.9 if constexpr 236
        27.10 允许constexpr虚函数 240
        27.11 允许在constexpr函数中出现Try-catch 244
        27.12 允许在constexpr中进行平凡的默认初始化 244
        27.13 允许在constexpr中更改联合类型的有效成员 245
        27.14 使用consteval声明立即函数 246
        27.15 使用constinit检查常量初始化 247
        27.16 判断常量求值环境 248
        27.17 总结 252
        第28章　确定的表达式求值顺序（C++17） 253
        28.1 表达式求值顺序的不确定性 253
        28.2 表达式求值顺序详解 254
        28.3 总结 255
        第29章　字面量优化（C++11～C++17） 257
        29.1 十六进制浮点字面量 257
        29.2 二进制整数字面量 258
        29.3 单引号作为整数分隔符 258
        29.4 原生字符串字面量 259
        29.5 用户自定义字面量 261
        29.6 总结 267
        第30章　alignas和alignof（C++11 C++17） 268
        30.1 不可忽视的数据对齐问题 268
        30.2 C++11标准之前控制数据对齐的方法 270
        30.3 使用alignof运算符 272
        30.4 使用alignas说明符 273
        30.5 其他关于对齐字节长度的支持 276
        30.6 C++17中使用new分配指定对齐字节长度的对象 278
        30.7 总结 279
        第31章　属性说明符和标准属性（C++11～C++20） 280
        31.1 GCC的属性语法 280
        31.2 MSVC的属性语法 281
        31.3 标准属性说明符语法 282
        31.4 使用using打开属性的命名空间 283
        31.5 标准属性 283
        31.5.1 noreturn 284
        31.5.2 carries_dependency 286
        31.5.3 deprecated 286
        31.5.4 fallthrough 287
        31.5.5 nodiscard 288
        31.5.6 maybe_unused 290
        31.5.7 likely和unlikely 290
        31.5.8 no_unique_address 291
        31.6 总结 293
        第32章　新增预处理器和宏（C++17 C++20） 294
        32.1 预处理器__has_include 294
        32.2 特性测试宏 295
        32.2.1 属性特性测试宏 295
        32.2.2 语言功能特性测试宏 295
        32.2.3 标准库功能特性测试宏 297
        32.3 新增宏__VA_OPT__ 301
        32.4 总结 302
        第33章　协程（C++20） 303
        33.1 协程的使用方法 303
        33.2 协程的实现原理 308
        33.2.1 co_await运算符原理 308
        33.2.2 co_yield运算符原理 313
        33.2.3 co_return运算符原理 317
        33.2.4 promise_type的其他功能 319
        33.3 总结 320
        第34章　基础特性的其他优化（C++11～C++20） 321
        34.1 显式自定义类型转换运算符（C++11） 321
        34.2 关于std::launder()（C++17） 325
        34.3 返回值优化（C++11～C++17） 326
        34.4 允许按值进行默认比较（C++20） 333
        34.5 支持new表达式推导数组长度（C++20） 334
        34.6 允许数组转换为未知范围的数组（C++20） 335
        34.7 在delete运算符函数中析构对象（C++20） 336
        34.8 调用伪析构函数结束对象声明周期（C++20） 337
        34.9 修复const和默认复制构造函数不匹配造成无法编译的问题（C++20） 338
        34.10 不推荐使用volatile的情况（C++20） 339
        34.11 不推荐在下标表达式中使用逗号运算符（C++20） 340
        34.12 模块（C++20） 340
        34.13 总结 341
        第35章　可变参数模板（C++11 C++17 C++20） 342
        35.1 可变参数模板的概念和语法 342
        35.2 形参包展开 344
        35.3 sizeof...运算符 352
        35.4 可变参数模板的递归计算 353
        35.5 折叠表达式 354
        35.6 一元折叠表达式中空参数包的特殊处理 357
        35.7 using声明中的包展开 358
        35.8 lambda表达式初始化捕获的包展开 359
        35.9 总结 361
        第36章　typename优化（C++17 C++20） 362
        36.1 允许使用typename声明模板形参 362
        36.2 减少typename使用的必要性 363
        36.3 总结 365
        第37章　模板参数优化（C++11 C++17 C++20） 366
        37.1 允许常量求值作为所有非类型模板的实参 366
        37.2 允许局部和匿名类型作为模板实参 368
        37.3 允许函数模板的默认模板参数 369
        37.4 函数模板添加到ADL查找规则 370
        37.5 允许非类型模板形参中的字面量类类型 371
        37.6 扩展的模板参数匹配规则 373
        37.7 总结 374
        第38章　类模板的模板实参推导（C++17 C++20） 375
        38.1 通过初始化构造推导类模板的模板实参 375
        38.2 拷贝初始化优先 377
        38.3 lambda类型的用途 378
        38.4 别名模板的类模板实参推导 380
        38.5 聚合类型的类模板实参推导 380
        38.6 总结 382
        第39章　用户自定义推导指引（C++17） 383
        39.1 使用自定义推导指引推导模板实例 383
        39.2 聚合类型类模板的推导指引 386
        39.3 总结 387
        第40章　SFINAE（C++11） 388
        40.1 替换失败和编译错误 388
        40.2 SFINAE规则详解 389
        40.3 总结 394
        第41章　概念和约束（C++20） 395
        41.1 使用std::enable_if约束模板 395
        41.2 概念的背景介绍 396
        41.3 使用concept和约束表达式定义概念 397
        41.4 requires子句和约束检查顺序 398
        41.5 原子约束 401
        41.6 requires表达式 403
        41.6.1 简单要求 404
        41.6.2 类型要求 405
        41.6.3 复合要求 405
        41.6.4 嵌套要求 406
        41.7 约束可变参数模板 407
        41.8 约束类模板特化 408
        41.9 约束auto 409
        41.10 总结 410
        第42章　模板特性的其他优化（C++11 C++14） 411
        42.1 外部模板（C++11） 411
        42.2 连续右尖括号的解析优化（C++11） 413
        42.3 friend声明模板形参（C++11） 415
        42.4 变量模板（C++14） 417
        42.5 explicit(bool) 419
        42.6 总结 423
        附录   特性章节对照表 424
     · · · · · ·     (收起)"
36303408,深度学习入门2,9.7,(32人评价),[日]斋藤康毅 / 郑明智 / 人民邮电出版社 / 2023-3 / 129.80元,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。
手把手带你创建深度学习框架，直击现代深度学习框架本质！
◎ 编辑推荐
• 简明易懂，讲...",https://book.douban.com/subject/36303408/,https://img3.doubanio.com/view/subject/s/public/s34476102.jpg,129.80元,9787115607515,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，...(展开全部)





“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，本书旨在揭开这些技术和机制的神秘面纱，帮助读者正确理解技术，体会它们的有趣之处。为此，本书会带领读者从零开始创建一个深度学习框架——DeZero。 DeZero 是本书原创的框架，它用最少的代码实现了现代深度学习框架的功能。本书分60 个步骤来完成这个框架，在此过程中，读者会加深对PyTorch、TensorFlow 和Chainer 等现代深度学习框架的理解，看清深度学习框架的本质。 本书沿袭《深度学习入门：基于Python 的理论与实现》的风格，语言通俗，代码简洁，讲解详细。在自制框架的过程中，读者还能进一步巩固Python 编程和软件开发相关的知识。 本书适合对深度学习框架感兴趣的读者阅读。",斋藤康毅 1984年生于日本长崎县，东京工业大学毕业，并完成东京大学研究生院课程。目前在某企业从事人工智能相关的研究和开发工作。著有《深度学习入门：基于Python的理论与实现》，同时也是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。,"前言
        第1阶段 自动微分 1
        步骤1 作为“箱子”的变量  3
        1.1 什么是变量  3
        1.2 实现Variable类  4
        1.3 （补充）NumPy的多维数组    6
        步骤2 创建变量的函数     8
        2.1 什么是函数      8
        2.2 Function类的实现   9
        2.3 使用Function类     10
        步骤3 函数的连续调用       13
        3.1 Exp函数的实现     13
        3.2 函数的连续调用     14
        步骤4 数值微分       16
        4.1 什么是导数       16
        4.2 数值微分的实现     17
        4.3 复合函数的导数     20
        4.4 数值微分存在的问题      21
        步骤5 反向传播的理论知识       22
        5.1 链式法则        22
        5.2 反向传播的推导      23
        5.3 用计算图表示       25
        步骤6 手动进行反向传播        27
        6.1 Variable类的功能扩展       27
        6.2 Function类的功能扩展       28
        6.3 Square类和Exp类的功能扩展      28
        6.4 反向传播的实现      29
        步骤7 反向传播的自动化        32
        7.1 为反向传播的自动化创造条件      33
        7.2 尝试反向传播       36
        7.3 增加backward方法       38
        步骤8 从递归到循环        40
        8.1 现在的Variable类       40
        8.2 使用循环实现       41
        8.3 代码验证        42
        步骤9 让函数更易用        43
        9.1 作为Python函数使用       43
        9.2 简化backward方法       45
        9.3 只支持ndarray       46
        步骤10 测试         50
        10.1 Python的单元测试       50
        10.2 square函数反向传播的测试      52
        10.3 通过梯度检验来自动测试      53
        10.4 测试小结       54
        第2阶段 用自然的代码表达       59
        步骤11 可变长参数（正向传播篇)       61
        11.1 修改Function类       62
        11.2 Add类的实现      64
        步骤12 可变长参数（改进篇)        65
        12.1 第1项改进：使函数更容易使用      65
        12.2 第2项改进：使函数更容易实现      67
        12.3 add函数的实现       69
        步骤13 可变长参数（反向传播篇)       70
        13.1 支持可变长参数的Add类的反向传播     70
        13.2 修改Variable类       71
        13.3 Square类的实现      73
        步骤14 重复使用同一个变量        75
        14.1 问题的原因 76
        14.2 解决方案       77
        14.3 重置导数       79
        步骤15 复杂的计算图（理论篇）81
        15.1 反向传播的正确顺序       82
        15.2 当前的DeZero        84
        15.3 函数的优先级      87
        步骤16 复杂的计算图（实现篇）88
        16.1 增加“辈分”变量      88
        16.2 按照“辈分”顺序取出元素     90
        16.3 Variable类的backward       92
        16.4 代码验证       93
        步骤17 内存管理和循环引用        97
        17.1 内存管理       97
        17.2 引用计数方式的内存管理      98
        17.3 循环引用      100
        17.4 weakref模块      102
        17.5 代码验证      104
        步骤18 减少内存使用量的模式      106
        18.1 不保留不必要的导数      106
        18.2 回顾Function类      109
        18.3 使用Confifig类进行切换      110
        18.4 模式的切换      111
        18.5 使用with语句切换    112
        步骤19 让变量更易用       116
        19.1 命名变量      116
        19.2 实例变量ndarray      117
        19.3 len函数和print函数      119
        步骤20 运算符重载（1）122
        20.1 Mul类的实现      122
        20.2 运算符重载      125
        步骤21 运算符重载（2）128
        21.1 与ndarray一起使用     128
        21.2 与flfloat和int一起使用    130
        21.3 问题1：左项为flfloat或int的情况    131
        21.4 问题2：左项为ndarray实例的情况   133
        步骤22 运算符重载（3）134
        22.1 负数       135
        22.2 减法       136
        22.3 除法       138
        22.4 幂运算       139
        步骤23 打包         141
        23.1 文件结构      142
        23.2 将代码移到核心类     142
        23.3 运算符重载      144
        23.4 实际的_ _init_ _.py文件     146
        23.5 导入dezero       147
        步骤24 复杂函数的求导        149
        24.1 Sphere函数       150
        24.2 matyas函数       151
        24.3 GoldsteinPrice函数      152
        第3阶段 实现高阶导数         161
        步骤25 计算图的可视化（1） 163
        25.1 安装Graphviz       163
        25.2 使用DOT语言描述图形     165
        25.3 指定节点属性     165
        25.4 连接节点      167
        步骤26 计算图的可视化（2）169
        26.1 可视化代码的使用示例      169
        26.2 从计算图转换为DOT语言    171
        26.3 从DOT语言转换为图像     174
        26.4 代码验证      176
        步骤27 泰勒展开的导数        178
        27.1 sin函数的实现       178
        27.2 泰勒展开的理论知识      179
        27.3 泰勒展开的实现     180
        27.4 计算图的可视化     182
        步骤28 函数优化        184
        28.1 Rosenbrock函数      184
        28.2 求导       185
        28.3 梯度下降法的实现     186
        步骤29 使用牛顿法进行优化（手动计算）190
        29.1 使用牛顿法进行优化的理论知识    191
        29.2 使用牛顿法实现优化      195
        步骤30 高阶导数（准备篇） 197
        30.1 确认工作①：Variable实例变量    197
        30.2 确认工作②：Function类     199
        30.3 确认工作③：Variable类的反向传播    201
        步骤31 高阶导数（理论篇） 204
        31.1 在反向传播时进行的计算     204
        31.2 创建反向传播的计算图的方法    206
        步骤32 高阶导数（实现篇） 209
        32.1 新的DeZero       209
        32.2 函数类的反向传播     210
        32.3 实现更有效的反向传播（增加模式控制代码）211
        32.4 修改_ _init_ _.py      213
        步骤33 使用牛顿法进行优化（自动计算） 215
        33.1 求二阶导数      215
        33.2 使用牛顿法进行优化      217
        步骤34 sin函数的高阶导数        219
        34.1 sin函数的实现       219
        34.2 cos函数的实现      220
        34.3 sin函数的高阶导数      221
        步骤35 高阶导数的计算图       225
        35.1 tanh函数的导数     226
        35.2 tanh函数的实现     226
        35.3 高阶导数的计算图可视化     227
        步骤36 DeZero的其他用途        234
        36.1 double backprop的用途     234
        36.2 深度学习研究中的应用示例     236
        第4阶段 创建神经网络         243
        步骤37 处理张量        245
        37.1 对各元素进行计算     245
        37.2 使用张量时的反向传播      247
        37.3 使用张量时的反向传播（补充内容）249
        步骤38 改变形状的函数        254
        38.1 reshape函数的实现      254
        38.2 从Variable对象调用reshape    258
        38.3 矩阵的转置      259
        38.4 实际的transpose函数（补充内容）262
        步骤39 求和的函数        264
        39.1 sum函数的反向传播      264
        39.2 sum函数的实现      266
        39.3 axis和keepdims      268
        步骤40 进行广播的函数        272
        40.1 broadcast_to函数和sum_to函数    272
        40.2 DeZero的broadcast_to函数和sum_to函数  275
        40.3 支持广播      277
        步骤41 矩阵的乘积        280
        41.1 向量的内积和矩阵的乘积     280
        41.2 检查矩阵的形状     282
        41.3 矩阵乘积的反向传播      282
        步骤42 线性回归        288
        42.1 玩具数据集      288
        42.2 线性回归的理论知识      289
        42.3 线性回归的实现     291
        42.4 DeZero的mean_squared_error函数（补充内容）  295
        步骤43 神经网络        298
        43.1 DeZero中的linear函数      298
        43.2 非线性数据集     301
        43.3 激活函数和神经网络      302
        43.4 神经网络的实现     303
        步骤44 汇总参数的层       307
        44.1 Parameter类的实现     307
        44.2 Layer类的实现      309
        44.3 Linear类的实现      312
        44.4 使用Layer实现神经网络    314
        步骤45 汇总层的层        316
        45.1 扩展Layer类      316
        45.2 Model类      319
        45.3 使用Model来解决问题      321
        45.4 MLP类      323
        步骤46 通过Optimizer更新参数      325
        46.1 Optimizer类      325
        46.2 SGD类的实现       326
        46.3 使用SGD类来解决问题     327
        46.4 SGD以外的优化方法     328
        步骤47 softmax函数和交叉熵误差      331
        47.1 用于切片操作的函数      331
        47.2 softmax函数      334
        47.3 交叉熵误差      337
        步骤48 多分类       340
        48.1 螺旋数据集      340
        48.2 用于训练的代码     341
        步骤49 Dataset类和预处理        346
        49.1 Dataset类的实现     346
        49.2 大型数据集的情况     348
        49.3 数据的连接      349
        49.4 用于训练的代码     350
        49.5 数据集的预处理     351
        步骤50 用于取出小批量数据的DataLoader     354
        50.1 什么是迭代器     354
        50.2 使用DataLoader      358
        50.3 accuracy函数的实现      359
        50.4 螺旋数据集的训练代码      360
        步骤51 MINST的训练       363
        51.1 MNIST数据集       364
        51.2 训练MNIST       366
        51.3 改进模型      368
        第5阶段 DeZero高级挑战      377
        步骤52 支持GPU        379
        52.1 CuPy的安装和使用方法     379
        52.2 cuda模块      382
        52.3 向Variable / Layer / DataLoader类添加代码   383
        52.4 函数的相应修改     386
        52.5 在GPU上训练MNIST      388
        步骤53 模型的保存和加载       391
        53.1 NumPy的save函数和load函数     391
        53.2 Layer类参数的扁平化    394
        53.3 Layer类的save函数和load函数     395
        步骤54 Dropout和测试模式       398
        54.1 什么是Dropout      398
        54.2 Inverted Dropout     401
        54.3 增加测试模式     401
        54.4 Dropout的实现      402
        步骤55 CNN的机制（1） 404
        55.1 CNN的网络结构      404
        55.2 卷积运算      405
        55.3 填充       407
        55.4 步幅       408
        55.5 输出大小的计算方法      409
        步骤56 CNN的机制（2）411
        56.1 三阶张量      411
        56.2 结合方块进行思考     412
        56.3 小批量处理      414
        56.4 池化层       415
        步骤57 conv2d函数和pooling函数     418
        57.1 使用im2col展开     418
        57.2 conv2d函数的实现      420
        57.3 Conv2d层的实现      425
        57.4 pooling函数的实现      426
        步骤58 具有代表性的CNN（VGG16）429
        58.1 VGG16的实现      429
        58.2 已训练的权重数据     431
        58.3 使用已训练的VGG16     435
        步骤59 使用RNN处理时间序列数据      438
        59.1 RNN层的实现       438
        59.2 RNN模型的实现      442
        59.3 切断连接的方法     445
        59.4 正弦波的预测     446
        步骤60 LSTM与数据加载器       451
        60.1 用于时间序列数据的数据加载器    451
        60.2 LSTM层的实现      453
        附录A inplace运算（步骤14的补充内容）463
        A.1 问题确认        463
        A.2 关于复制和覆盖        464
        A.3 DeZero的反向传播        465
        附录B 实现get_item函数（步骤47的补充内容）466
        附录C 在Google Colaboratory上运行      469
        后 记         473
        参考文献          477
     · · · · · ·     (收起)"
35863224,C++20高级编程(第5版),8.4,(195人评价),[比]马克·格雷戈勒（Marc Gregoire） / 程序喵大人、惠惠、墨梵 / 清华大学出版社 / 2022-4 / 228,"拥抱C++的深度和复杂性，挖掘更多可能
众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉...",https://book.douban.com/subject/35863224/,https://img3.doubanio.com/view/subject/s/public/s34341252.jpg,228,9787302602132,"拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函...(展开全部)





拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函数等 ● 深入讨论新的C++20标准库功能，例如文本格式化、范围、原子智能指针、同步原语、日期、时区等","Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Win...(展开全部)




Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Windows和Linux平台上开发24×7运行的C++程序，例如KNX/EIB家庭自动化监控软件。除了C/C++之外，Marc还喜欢C#。 2007年4月，他凭借Visual C++方面的专业技能，获得了微软年度MVP称号。 Marc还是比利时C++用户组(www.becpp.org)的创始人，是C++ Standard Library Quick Reference 第1版和第2版(Apress)的共同作者，以及多家出版社出版的多种书籍的技术编辑，是C++大会CppCon的活跃演讲者。","第I部分  专业的C++简介
        第1章  C++和标准库速成   3
        1.1  C++速成   3
        1.1.1  小程序“Hello World”   4
        1.1.2  名称空间   7
        1.1.3  字面量   9
        1.1.4  变量   9
        1.1.5  运算符   12
        1.1.6  枚举类型   14
        1.1.7  结构体   16
        1.1.8  条件语句   17
        1.1.9  条件运算符   19
        1.1.10  逻辑比较运算符   20
        1.1.11  三向比较运算符   21
        1.1.12  函数   22
        1.1.13  属性   23
        1.1.14  C风格的数组   26
        1.1.15  std::array   27
        1.1.16  std::vector   28
        1.1.17  std::pair   28
        1.1.18  std::optional   29
        1.1.19  结构化绑定   30
        1.1.20  循环   30
        1.1.21  初始化列表   31
        1.1.22  C++中的字符串   32
        1.1.23  作为面向对象语言的C++   32
        1.1.24  作用域解析   35
        1.1.25  统一初始化   36
        1.1.26  指针和动态内存   39
        1.1.27  const的用法   43
        1.1.28  constexpr关键字   45
        1.1.29  consteval关键字   46
        1.1.30  引用   47
        1.1.31  const_cast()   55
        1.1.32  异常   56
        1.1.33  类型别名   56
        1.1.34  类型定义   57
        1.1.35  类型推断   58
        1.1.36  标准库   60
        1.2  第一个大型的C++程序   61
        1.2.1  雇员记录系统   61
        1.2.2  Employee类   61
        1.2.3  Database类   64
        1.2.4  用户界面   67
        1.2.5  评估程序   69
        1.3  本章小结   69
        1.4  练习   69
        第2章  使用string和string_view   71
        2.1  动态字符串   71
        2.1.1  C风格字符串   71
        2.1.2  字符串字面量   73
        2.1.3  C++ std::string类   75
        2.1.4  数值转换   78
        2.1.5  std::string_view类   81
        2.1.6  非标准字符串   84
        2.2  字符串格式化   84
        2.2.1  格式说明符   85
        2.2.2  格式说明符错误   87
        2.2.3  支持自定义类型   87
        2.3  本章小结   90
        2.4  练习   90
        第3章  编码风格   91
        3.1  良好外观的重要性   91
        3.1.1  事先考虑   91
        3.1.2  良好风格的元素   92
        3.2  为代码编写文档   92
        3.2.1  使用注释的原因   92
        3.2.2  注释的风格   96
        3.3  分解   99
        3.3.1  通过重构分解   100
        3.3.2  通过设计分解   101
        3.3.3  本书中的分解   101
        3.4  命名   101
        3.4.1  选择恰当的名称   101
        3.4.2  命名约定   102
        3.5  使用具有风格的语言特性   103
        3.5.1  使用常量   104
        3.5.2  使用引用代替指针   104
        3.5.3  使用自定义异常   104
        3.6  格式   105
        3.6.1  关于大括号对齐的争论   105
        3.6.2  关于空格和圆括号的争论   106
        3.6.3  空格、制表符、换行符   106
        3.7  风格的挑战   107
        3.8  本章小结   107
        3.9  练习   107
        第II部分  专业的C++软件设计
        第4章  设计专业的C++程序   113
        4.1  程序设计概述   113
        4.2  程序设计的重要性   114
        4.3  C++设计   116
        4.4  C++设计的两个原则   116
        4.4.1  抽象   116
        4.4.2  重用   118
        4.5  重用现有代码   119
        4.5.1  关于术语的说明   119
        4.5.2  决定是否重用代码   120
        4.5.3  重用代码的指导原则   121
        4.6  设计一个国际象棋程序   127
        4.6.1  需求   127
        4.6.2  设计步骤   127
        4.7  本章小结   132
        4.8  练习   133
        第5章  面向对象设计   135
        5.1  过程化的思考方式   135
        5.2  面向对象思想   136
        5.2.1  类   136
        5.2.2  组件   136
        5.2.3  属性   136
        5.2.4  行为   137
        5.2.5  综合考虑   137
        5.3  生活在类的世界里   138
        5.3.1  过度使用类   138
        5.3.2  过于通用的类   139
        5.4  类之间的关系   139
        5.4.1  “有一个”关系   139
        5.4.2  “是一个”关系(继承)   140
        5.4.3  “有一个”与“是一个”的
        区别   142
        5.4.4  not-a关系   144
        5.4.5  层次结构   145
        5.4.6  多重继承   146
        5.4.7  混入类   147
        5.5  本章小结   147
        5.6  练习   148
        第6章  设计可重用代码   149
        6.1  重用哲学   149
        6.2  如何设计可重用代码   150
        6.2.1  使用抽象   150
        6.2.2  构建理想的重用代码   151
        6.2.3  设计有用的接口   157
        6.2.4  设计成功的抽象   162
        6.2.5  SOLID原则   162
        6.3  本章小结   163
        6.4  练习   163
        第III部分  C++编码方法
        第7章  内存管理   167
        7.1  使用动态内存   167
        7.1.1  如何描绘内存   168
        7.1.2  分配和释放   169
        7.1.3  数组   170
        7.1.4  使用指针   177
        7.2  数组-指针的对偶性   178
        7.2.1  数组就是指针   178
        7.2.2  并非所有指针都是数组   180
        7.3  底层内存操作   180
        7.3.1  指针运算   180
        7.3.2  自定义内存管理   181
        7.3.3  垃圾回收   181
        7.3.4  对象池   182
        7.4  常见的内存陷阱   182
        7.4.1  数据缓冲区分配不足以及
        内存访问越界   182
        7.4.2  内存泄漏   183
        7.4.3  双重释放和无效指针   186
        7.5  智能指针   186
        7.5.1  unique_ptr   187
        7.5.2  shared_ptr   190
        7.5.3  weak_ptr   193
        7.5.4  向函数传递参数   193
        7.5.5  从函数中返回   194
        7.5.6  enable_shared_from_this   194
        7.5.7  过时的、移除的auto_ptr   195
        7.6  本章小结   195
        7.7  练习   195
        第8章  类和对象   197
        8.1  电子表格示例介绍   197
        8.2  编写类   198
        8.2.1  类定义   198
        8.2.2  定义方法   200
        8.2.3  使用对象   203
        8.3  对象的生命周期   205
        8.3.1  创建对象   205
        8.3.2  销毁对象   219
        8.3.3  对象赋值   220
        8.3.4  编译器生成的拷贝构造函数和
        拷贝赋值运算符   223
        8.3.5  复制和赋值的区别   223
        8.4  本章小结   224
        8.5  练习   225
        第9章  精通类和对象   227
        9.1  友元   227
        9.2  对象中的动态内存分配   228
        9.2.1  Spreadsheet类   228
        9.2.2  使用析构函数释放内存   231
        9.2.3  处理复制和赋值   231
        9.2.4  使用移动语义处理移动   237
        9.2.5  零规则   246
        9.3  与方法有关的更多内容   246
        9.3.1  static方法   246
        9.3.2  const方法   247
        9.3.3  方法重载   248
        9.3.4  内联方法   251
        9.3.5  默认参数   252
        9.4  不同的数据成员类型   252
        9.4.1  静态数据成员   253
        9.4.2  const static数据成员   254
        9.4.3  引用数据成员   255
        9.5  嵌套类   256
        9.6  类内的枚举类型   257
        9.7  运算符重载   258
        9.7.1  示例：为SpreadsheetCell
        实现加法   258
        9.7.2  重载算术运算符   261
        9.7.3  重载比较运算符   262
        9.7.4  创建具有运算符重载的类型   266
        9.8  创建稳定的接口   266
        9.9  本章小结   270
        9.10  练习   270
        第10章  揭秘继承技术   271
        10.1  使用继承构建类   271
        10.1.1  扩展类   272
        10.1.2  重写方法   275
        10.2  使用继承重用代码   282
        10.2.1  WeatherPrediction类   282
        10.2.2  在派生类中添加功能   283
        10.2.3  在派生类中替换功能   284
        10.3  利用父类   285
        10.3.1  父类构造函数   285
        10.3.2  父类的析构函数   286
        10.3.3  使用父类方法   287
        10.3.4  向上转型和向下转型   289
        10.4  继承与多态性   290
        10.4.1  回到电子表格   290
        10.4.2  设计多态性的电子表格
        单元格   291
        10.4.3  SpreadsheetCell基类   291
        10.4.4  独立的派生类   293
        10.4.5  利用多态性   294
        10.4.6  考虑将来   295
        10.5  多重继承   296
        10.5.1  从多个类继承   296
        10.5.2  名称冲突和歧义基类   297
        10.6  有趣而晦涩的继承问题   300
        10.6.1  修改重写方法的返回类型   300
        10.6.2  派生类中添加虚基类方法的
        重载   301
        10.6.3  继承的构造函数   302
        10.6.4  重写方法时的特殊情况   306
        10.6.5  派生类中的复制构造函数和
        赋值运算符   312
        10.6.6  运行期类型工具   313
        10.6.7  非public继承   314
        10.6.8  虚基类   315
        10.7  类型转换   316
        10.7.1  static_cast()   316
        10.7.2  reinterpret_cast()   317
        10.7.3  std::bit_cast()   318
        10.7.4  dynamic_cast()   318
        10.7.5  类型转换小结   319
        10.8  本章小结   319
        10.9  练习   320
        第11章  零碎的工作   321
        11.1  模块   321
        11.1.1  模块接口文件   322
        11.1.2  模块实现文件   324
        11.1.3  从实现中分离接口   325
        11.1.4  可见性和可访问性   326
        11.1.5  子模块   326
        11.1.6  模块划分   327
        11.1.7  头文件单元   329
        11.2  头文件   330
        11.2.1  重复定义   330
        11.2.2  循环依赖   330
        11.2.3  查询头文件是否存在   331
        11.3  核心语言特性的特性测试宏   331
        11.4  STATIC关键字   332
        11.4.1  静态数据成员和方法   332
        11.4.2  静态链接   332
        11.4.3  函数中的静态变量   334
        11.4.4  非局部变量的初始化顺序   335
        11.4.5  非局部变量的销毁顺序   335
        11.5  C的实用工具   335
        11.5.1  变长参数列表   336
        11.5.2  预处理器宏   337
        11.6  本章小结   338
        11.7  练习   338
        第12章  利用模板编写泛型代码   341
        12.1  模板概述   341
        12.2  类模板   342
        12.2.1  编写类模板   342
        12.2.2  编译器处理模板的原理   349
        12.2.3  将模板代码分布到多个
        文件中   350
        12.2.4  模板参数   351
        12.2.5  方法模板   355
        12.2.6  类模板的特化   359
        12.2.7  从类模板派生   361
        12.2.8  继承还是特化   362
        12.2.9  模板别名   362
        12.3  函数模板   363
        12.3.1  函数模板的重载   364
        12.3.2  类模板的友元函数模板   365
        12.3.3  对模板参数推导的更多介绍   366
        12.3.4  函数模板的返回类型   367
        12.4  简化函数模板的语法   368
        12.5  变量模板   369
        12.6  概念   369
        12.6.1  语法   369
        12.6.2  约束表达式   370
        12.6.3  预定义的标准概念   372
        12.6.4  类型约束的auto   372
        12.6.5  类型约束和函数模板   373
        12.6.6  类型约束和类模板   375
        12.6.7  类型约束和类方法   375
        12.6.8  类型约束和模板特化   376
        12.7  本章小结   376
        12.8  练习   377
        第13章  C++ I/O揭秘   379
        13.1  使用流   379
        13.1.1  流的含义   380
        13.1.2  流的来源和目的地   381
        13.1.3  流式输出   381
        13.1.4  流式输入   386
        13.1.5  对象的输入输出   392
        13.1.6  自定义的操作算子   393
        13.2  字符串流   393
        13.3  文件流   394
        13.3.1  文本模式与二进制模式   395
        13.3.2  通过seek()和tell()在文件中
        转移   395
        13.3.3  将流链接在一起   397
        13.4  双向I/O   398
        13.5  文件系统支持库   399
        13.5.1  路径   399
        13.5.2  目录条目   401
        13.5.3  辅助函数   401
        13.5.4  目录遍历   401
        13.6  本章小结   402
        13.7  练习   403
        第14章  错误处理   405
        14.1  错误与异常   405
        14.1.1  异常的含义   405
        14.1.2  C++中异常的优点   406
        14.1.3  建议   407
        14.2  异常机制   407
        14.2.1  抛出和捕获异常   408
        14.2.2  异常类型   410
        14.2.3  按const引用捕获异常对象   411
        14.2.4  抛出并捕获多个异常   411
        14.2.5  未捕获的异常   414
        14.2.6  noexcept说明符   415
        14.2.7  noexcept(expression)说明符   415
        14.2.8  noexcept(expression)运算符   415
        14.2.9  抛出列表   416
        14.3  异常与多态性   416
        14.3.1  标准异常层次结构   416
        14.3.2  在类层次结构中捕获异常   418
        14.3.3  编写自己的异常类   419
        14.3.4  源码位置   421
        14.3.5  日志记录的源码位置   422
        14.3.6  异常的源码位置   422
        14.3.7  嵌套异常   423
        14.4 重新抛出异常   425
        14.5  堆栈的释放与清理   426
        14.5.1  使用智能指针   427
        14.5.2  捕获、清理并重新抛出   428
        14.6  常见的错误处理问题   428
        14.6.1  内存分配错误   428
        14.6.2  构造函数中的错误   430
        14.6.3  构造函数的function-try-blocks   432
        14.6.4  析构函数中的错误   435
        14.7  本章小结   435
        14.8  练习   435
        第15章  C++运算符重载   437
        15.1  运算符重载概述   437
        15.1.1  重载运算符的原因   438
        15.1.2  运算符重载的限制   438
        15.1.3  运算符重载的选择   438
        15.1.4  不应重载的运算符   440
        15.1.5  可重载运算符小结   440
        15.1.6  右值引用   443
        15.1.7  优先级和结合性   444
        15.1.8  关系运算符   444
        15.2  重载算术运算符   445
        15.2.1  重载一元负号和一元正号
        运算符   445
        15.2.2  重载递增和递减运算符   446
        15.3  重载按位运算符和二元逻辑
        运算符   446
        15.4  重载插入运算符和提取运算符   447
        15.5  重载下标运算符   448
        15.5.1  通过operator[]提供只读访问   451
        15.5.2  非整数数组索引   452
        15.6  重载函数调用运算符   452
        15.7  重载解除引用运算符   453
        15.7.1  实现operator*   454
        15.7.2  实现operator->   455
        15.7.3  operator.*和operator ->*的
        含义   455
        15.8  编写转换运算符   456
        15.8.1  auto运算符   456
        15.8.2  使用显式转换运算符解决
        多义性问题   457
        15.8.3  用于布尔表达式的转换   457
        15.9  重载内存分配和内存释放
        运算符   459
        15.9.1  new和delete的工作原理   459
        15.9.2  重载operator new和
        operator delete   461
        15.9.3  显式地删除/默认化operator new
        和operator delete   463
        15.9.4  重载带有额外参数的operator new
        和operator delete   463
        15.9.5  重载带有内存大小参数的
        operator delete   464
        15.9.6  重载用户定义的字面量
        运算符   464
        15.9.7  cooked模式字面量运算符   465
        15.9.8  raw模式字面量运算符   465
        15.9.9  标准用户定义的字面量   466
        15.10  本章小结   466
        15.11  练习   466
        第16章  C++标准库概述   469
        16.1  编码原则   470
        16.1.1  使用模板   470
        16.1.2  使用运算符重载   470
        16.2  C++标准库概述   470
        16.2.1  字符串   470
        16.2.2  正则表达式   471
        16.2.3  I/O流   471
        16.2.4  智能指针   471
        16.2.5  异常   471
        16.2.6  数学工具   472
        16.2.7  时间和日期工具   473
        16.2.8  随机数   473
        16.2.9  初始化列表   474
        16.2.10  Pair和Tuple   474
        16.2.11  词汇类型   474
        16.2.12  函数对象   474
        16.2.13  文件系统   474
        16.2.14  多线程   475
        16.2.15  类型萃取   475
        16.2.16  标准整数类型   475
        16.2.17  标准库特性测试宏   475
        16.2.18  <version>   476
        16.2.19  源位置   476
        16.2.20  容器   476
        16.2.21  算法   482
        16.2.22  范围库   488
        16.2.23  标准库中还缺什么   488
        16.3  本章小结   489
        16.4  练习   489
        第17章  理解迭代器与范围库   491
        17.1  迭代器   491
        17.1.1  获取容器的迭代器   494
        17.1.2  迭代器萃取   495
        17.1.3  示例   495
        17.2  流迭代器   496
        17.2.1  输出流迭代器   497
        17.2.2  输入流迭代器   497
        17.3  迭代器适配器   498
        17.3.1  插入迭代器   498
        17.3.2  逆向迭代器   499
        17.3.3  移动迭代器   500
        17.4  范围   502
        17.4.1  基于范围的算法   502
        17.4.2  视图   504
        17.4.3  范围工厂   508
        17.5  本章小结   509
        17.6  练习   509
        第18章  标准库容器   511
        18.1  容器概述   511
        18.1.1  对元素的要求   512
        18.1.2  异常和错误检查   513
        18.2  顺序容器   514
        18.2.1  vector   514
        18.2.2  vector<bool>特化   531
        18.2.3  deque   532
        18.2.4  list   532
        18.2.5  forward_list   535
        18.2.6  array   537
        18.2.7  span   538
        18.3  容器适配器   540
        18.3.1  queue   540
        18.3.2  priority_queue   542
        18.3.3  stack   545
        18.4  有序关联容器   545
        18.4.1  pair工具类   545
        18.4.2  map   546
        18.4.3  multimap   554
        18.4.4  set   556
        18.4.5  multiset   558
        18.5  无序关联容器/哈希表   558
        18.5.1  哈希函数   559
        18.5.2  unordered_map   560
        18.5.3  unordered_multimap   563
        18.5.4  unordered_set/
        unordered_multiset   564
        18.6  其他容器   564
        18.6.1  标准C风格数组   564
        18.6.2  string   565
        18.6.3  流   566
        18.6.4  bitset   566
        18.7  本章小结   570
        18.8  练习   570
        第19章  函数指针，函数对象，lambda
        表达式   571
        19.1  函数指针   571
        19.2  指向方法(和数据成员)的指针   573
        19.3  函数对象   576
        19.3.1  编写第一个函数对象   576
        19.3.2  标准库中的函数对象   576
        19.4  lambda表达式   582
        19.4.1  语法   583
        19.4.2  lambda表达式作为参数   587
        19.4.3  泛型lambda表达式   587
        19.4.4  lambda捕获表达式   587
        19.4.5  模板化lambda表达式   588
        19.4.6  lambda表达式作为返回类型   589
        19.4.7  未计算上下文中的lambda
        表达式   589
        19.4.8  默认构造、拷贝和赋值   589
        19.5  调用   590
        19.6  本章小结   590
        19.7  练习   590
        第20章  掌握标准库算法   593
        20.1  算法概述   593
        20.1.1  find()和find_if()算法   594
        20.1.2  accumulate()算法   596
        20.1.3  在算法中使用移动语义   597
        20.1.4  算法回调   597
        20.2  算法详解   598
        20.2.1  非修改序列算法   598
        20.2.2  修改序列算法   603
        20.2.3  操作算法   611
        20.2.4  分区算法   613
        20.2.5  排序算法   614
        20.2.6  二分查找算法   615
        20.2.7  集合算法   616
        20.2.8  最小/最大算法   618
        20.2.9  并行算法   619
        20.2.10  约束算法   620
        20.2.11  数值处理算法   621
        20.3  本章小结   622
        20.4  练习   622
        第21章  字符串的本地化与正则表达式   625
        21.1  本地化   625
        21.1.1  宽字符   625
        21.1.2  本地化字符串字面量   626
        21.1.3  非西方字符集   626
        21.1.4  locale和facet   628
        21.1.5  转换   631
        21.2  正则表达式   632
        21.2.1  ECMAScript语法   632
        21.2.2  regex库   637
        21.2.3  regex_match()   638
        21.2.4  regex_search()   640
        21.2.5  regex_iterator   641
        21.2.6  regex_token_iterator   642
        21.2.7  regex_replace()   644
        21.3  本章小结   646
        21.4  练习   646
        第22章  日期和时间工具   647
        22.1  编译期有理数   647
        22.2  持续时间   649
        22.3  时钟   653
        22.4  时间点   655
        22.5  日期   656
        22.6  时区   658
        22.7  本章小结   659
        22.8  练习   659
        第23章  随机数工具   661
        23.1  C风格随机数生成器   661
        23.1.1  随机数引擎   662
        23.1.2  随机数引擎适配器   663
        23.1.3  预定义的随机数引擎和
        引擎适配器   664
        23.1.4  生成随机数   664
        23.1.5  随机数分布   666
        23.2  本章小结   668
        23.3  练习   669
        第24章  其他库工具   671
        24.1  variant   671
        24.2  any   673
        24.3  元组   674
        24.3.1  分解元组   676
        24.3.2  串联   677
        24.3.3  比较   677
        24.3.4  make_from_tuple()   678
        24.3.5  apply()   678
        24.4  本章小结   678
        24.5  练习   678
        第IV部分  掌握C++的高级特性
        第25章  自定义和扩展标准库   683
        25.1  分配器   683
        25.2  扩展标准库   684
        25.2.1  扩展标准库的原因   685
        25.2.2  编写标准库算法   685
        25.2.3  编写标准库容器   686
        25.2.4  将directed_graph实现为
        标准库容器   696
        25.2.5  添加分配器支持   712
        25.2.6  改善graph_node   716
        25.2.7  附加的标准库类似功能   717
        25.2.8  进一步改善   719
        25.2.9  其他容器类型   719
        25.3  本章小结   720
        25.4  练习   720
        第26章  高级模板   721
        26.1  深入了解模板参数   721
        26.1.1  深入了解模板类型参数   721
        26.1.2  template template参数介绍   724
        26.1.3  深入了解非类型模板参数   725
        26.2  类模板部分特例化   727
        26.3  通过重载模拟函数部分特例化   730
        26.4  模板递归   731
        26.4.1  N维网格：初次尝试   731
        26.4.2  真正的N维网格   732
        26.5  可变参数模板   734
        26.5.1  类型安全的变长参数列表   734
        26.5.2  可变数目的混入类   736
        26.5.3  折叠表达式   737
        26.6  模板元编程   739
        26.6.1  编译时阶乘   739
        26.6.2  循环展开   740
        26.6.3  打印元组   741
        26.6.4  类型trait   744
        26.6.5  模板元编程结论   752
        26.7  本章小结   752
        26.8  练习   752
        第27章  C++多线程编程   753
        27.1  多线程编程概述   754
        27.1.1  争用条件   755
        27.1.2  撕裂   756
        27.1.3  死锁   756
        27.1.4  伪共享   757
        27.2  线程   757
        27.2.1  通过函数指针创建线程   758
        27.2.2  通过函数对象创建线程   759
        27.2.3  通过lambda创建线程   760
        27.2.4  通过成员函数创建线程   760
        27.2.5  线程本地存储   761
        27.2.6  取消线程   761
        27.2.7  自动join线程   761
        27.2.8  从线程获得结果   762
        27.2.9  复制和重新抛出异常   762
        27.3  原子操作库   764
        27.3.1  原子操作   766
        27.3.2  原子智能指针   767
        27.3.3  原子引用   767
        27.3.4  使用原子类型   767
        27.3.5  等待原子变量   769
        27.4  互斥   770
        27.4.1  互斥体类   770
        27.4.2  锁   772
        27.4.3  std::call_once   774
        27.4.4  互斥体对象的用法示例   776
        27.5  条件变量   779
        27.5.1  虚假唤醒   780
        27.5.2  使用条件变量   780
        27.6  latch   781
        27.7  barrier   782
        27.8  semaphore   782
        27.9  future   783
        27.9.1  std::promise和std::future   784
        27.9.2  std::packaged_task   784
        27.9.3  std::async   785
        27.9.4  异常处理   786
        27.9.5  std::shared_future   786
        27.10  示例：多线程的Logger类   787
        27.11  线程池   791
        27.12  协程   792
        27.13  线程设计和最佳实践   793
        27.14  本章小结   794
        27.15  练习   794
        第V部分  C++软件工程
        第28章  充分利用软件工程方法   799
        28.1  过程的必要性   799
        28.2  软件生命周期模型   800
        28.2.1  瀑布模型   800
        28.2.2  生鱼片模型   802
        28.2.3  螺旋类模型   802
        28.2.4  敏捷   804
        28.3  软件工程方法论   805
        28.3.1  UP   805
        28.3.2  RUP   806
        28.3.3  Scrum   806
        28.3.4  极限编程   808
        28.3.5  软件分流   812
        28.4  构建自己的过程和方法   812
        28.4.1  对新思想采取开放态度   812
        28.4.2  提出新想法   812
        28.4.3  知道什么行得通、什么行不通   812
        28.4.4  不要逃避   813
        28.5  源代码控制   813
        28.6  本章小结   814
        28.7  练习   814
        第29章  编写高效的C++程序   817
        29.1  性能和效率概述   817
        29.1.1  提升效率的两种方式   818
        29.1.2  两种程序   818
        29.1.3  C++是不是低效的语言   818
        29.2  语言层次的效率   818
        29.2.1  高效地操纵对象   819
        29.2.2  预分配内存   823
        29.2.3  使用内联方法和函数   823
        29.3  设计层次的效率   823
        29.3.1  尽可能多地缓存   823
        29.3.2  使用对象池   824
        29.4  剖析   829
        29.4.1  使用gprof的剖析示例   829
        29.4.2  使用Visual C++ 2019的剖析示例   836
        29.5  本章小结   838
        29.6  练习   838
        第30章  熟练掌握测试技术   841
        30.1  质量控制   841
        30.1.1  谁负责测试   842
        30.1.2  bug的生命周期   842
        30.1.3  bug跟踪工具   843
        30.2  单元测试   844
        30.2.1  单元测试方法   844
        30.2.2  单元测试过程   845
        30.2.3  实际中的单元测试   848
        30.3  模糊测试   855
        30.4  高级测试   855
        30.4.1  集成测试   855
        30.4.2  系统测试   856
        30.4.3  回归测试   857
        30.5  用于成功测试的建议   857
        30.6  本章小结   858
        30.7  练习   858
        第31章  熟练掌握调试技术   859
        31.1  调试的基本定律   859
        31.2  bug分类学   860
        31.3  避免bug   860
        31.4  为bug做好规划   861
        31.4.1  错误日志   861
        31.4.2  调试跟踪   862
        31.4.3  断言   869
        31.4.4  崩溃转储   870
        31.5  调试技术   870
        31.5.1  重现bug   870
        31.5.2  调试可重复的bug   871
        31.5.3  调试不可重现的bug   871
        31.5.4  调试退化   872
        31.5.5  调试内存问题   872
        31.5.6  调试多线程程序   876
        31.5.7  调试示例：文章引用   876
        31.5.8  从ArticleCitations示例中总结出的教训   887
        31.6  本章小结   887
        31.7  练习   887
        第32章  使用设计技术和框架   889
        32.1  容易忘记的语法   890
        32.1.1  编写类   890
        32.1.2  派生类   891
        32.1.3  编写lambda表达式   892
        32.1.4  使用“复制和交换”惯用语法   892
        32.1.5  抛出和捕捉异常   893
        32.1.6  写入文件   894
        32.1.7  读取文件   894
        32.1.8  写入类模板   895
        32.1.9  约束模板参数   895
        32.2  始终存在更好的方法   896
        32.2.1  RAII   896
        32.2.2  双分派   898
        32.2.3  混入类   902
        32.3  面向对象的框架   904
        32.3.1  使用框架   904
        32.3.2  MVC范型   905
        32.4  本章小结   906
        32.5  练习   906
        第33章  应用设计模式   907
        33.1  依赖注入   908
        33.1.1  示例：日志机制   908
        33.1.2  依赖注入logger的实现   908
        33.1.3  使用依赖注入   909
        33.2  抽象工厂模式   910
        33.2.1  示例：模拟汽车工厂   910
        33.2.2  实现抽象工厂   911
        33.2.3  使用抽象工厂   912
        33.3  工厂方法模式   913
        33.3.1  示例：模拟第二个汽车工厂   913
        33.3.2  实现工厂   914
        33.3.3  使用工厂   915
        33.3.4  工厂的其他类型   917
        33.3.5  工厂的其他用法   917
        33.4  适配器模式   918
        33.4.1  示例：适配Logger类   918
        33.4.2  实现适配器   919
        33.4.3  使用适配器   920
        33.5  代理模式   920
        33.5.1  示例：隐藏网络连接问题   920
        33.5.2  实现代理   921
        33.5.3  使用代理   922
        33.6  迭代器模式   922
        33.7  观察者模式   923
        33.7.1  示例：从主题中暴露事件   923
        33.7.2  实现观察者   923
        33.7.3  使用观察者   924
        33.8  装饰器模式   925
        33.8.1  示例：在网页中定义样式   926
        33.8.2  装饰器的实现   926
        33.8.3  使用装饰器   927
        33.9  责任链模式   928
        33.9.1  示例：事件处理   928
        33.9.2  实现责任链   928
        33.9.3  使用责任链   929
        33.10  单例模式   930
        33.10.1  日志记录机制   931
        33.10.2  实现单例   931
        33.10.3  使用单例   933
        33.11  本章小结   933
        33.12  练习   933
        第34章  开发跨平台和跨语言的应用程序   935
        34.1  跨平台开发   935
        34.1.1  架构问题   935
        34.1.2  实现问题   938
        34.1.3  平台专用功能   940
        34.2  跨语言开发   940
        34.2.1  混用C和C++   941
        34.2.2  改变范型   941
        34.2.3  链接C代码   944
        34.2.4  从C#调用C++代码   946
        34.2.5  C++/CLI在C++中使用C#代码和在C#中使用C++代码   947
        34.2.6  在Java中使用JNI调用C++代码   948
        34.2.7  从C++代码调用脚本   950
        34.2.8  从脚本调用C++代码   950
        34.2.9  从C++调用汇编代码   952
        34.3  本章小结   953
        34.4  练习   953
        第VI部分  附录
        附录A  C++面试   957
        在线资源(扫描封底二维码下载)
        附录B  标准库头文件   977
        附录C  UML简介   983
        附录D  带注解的参考文献   989
     · · · · · ·     (收起)"
30329536,数据密集型应用系统设计,9.7,(1709人评价),Martin Kleppmann / 赵军平、李三平、吕云松、耿煜 / 中国电力出版社 / 2018-9-1 / 128,"全书分为三大部分：
第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以...",https://book.douban.com/subject/30329536/,https://img1.doubanio.com/view/subject/s/public/s34186559.jpg,128,9787519821968,"全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方...(展开全部)





全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方式就是集成多个不同的数据库、缓存模块以及索引模块等。首先第10章以批处理开始来处理派生数据，紧接着第11章采用流式处理。第12章总结之前介绍的多种技术，并分析讨论未来构建可靠、可扩展和可维护应用系统可能的新方向或方法。","作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, ...(展开全部)




作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, Nvidia GPU Tech Conf等做技术分享，持续关注数据密集和计算密集相关技术的演进、融合与赋能推广。 吕云松，北京大学计算机硕士，硕士及DELL EMC中国研究院实习期间专注于大数据实时流式处理相关的研究。现就职于华为2012中软院黎曼实验室，主要从事深度学习的研发。 耿煜，DELL EMC架构师兼GTM负责人，致力于推广企业级数字化转型方案。深耕分布式架构以及云计算12年，先后任职于ChinaCache，Sun Microsystems以及EMC等公司。 李三平，美国麻省大学计算机工程专业博士，DELL EMC中国研究院首席科学家，研究方向为机器学习、深度学习、智能运维、遥感影像等。已在IEEE Transactions期刊和会议上发表论文数十篇，申请美国专利20余项。推崇简约，热衷机器学习。","前言 .....................................................1
        第一部分 数据系统基础
        第1章 可靠、可扩展与可维护的应用系统 ................... 11
        认识数据系统 ...........................................12
        可靠性 ..................................................14
        可扩展性 ................................................18
        可维护性 ................................................25
        小结 .....................................................28
        第2章 数据模型与查询语言 ............................... 33
        关系模型与文档模型 .......................................34
        数据查询语言 ...........................................46
        图状数据模型 ......................................52
        小结 ...................................................65
        第3章 数据存储与检索 .................................. 71
        数据库核心：数据结构 ...................................72
        事务处理与分析处理 ...................................89
        列式存储 .........................................94
        小结 ..............................................101
        第4章 数据编码与演化 .............................. 109
        数据编码格式 .................................... 110
        数据流模式 ......................................124
        小结 .............................................134
        第二部分 分布式数据系统
        第5章 数据复制 ................................. 145
        主节点与从节点 ..................................146
        复制滞后问题 ......................................154
        多主节点复制 .......................................160
        无主节点复制 .....................................168
        小结 ..............................................181
        第6章 数据分区 ............................... 189
        数据分区与数据复制 .................................190
        键-值数据的分区 ...................................190
        分区与二级索引 ...................................195
        分区再平衡 ....................................198
        请求路由 ..................................202
        小结 .................................204
        第7章 事务 .............................. 211
        深入理解事务 ......................................212
        弱隔离级别 .................................221
        串行化 ...........................................237
        小结 ...........................................250
        第8章 分布式系统的挑战 ...................... 259
        故障与部分失效 ...............................260
        不可靠的网络 ..................................262
        不可靠的时钟 ..................................271
        知识，真相与谎言 ...............................282
        小结 ..........................................292
        第9章 一致性与共识 ..................... 303
        一致性保证 ....................................304
        可线性化 ........................................305
        顺序保证 ........................................319
        分布式事务与共识 .................................330
        小结 ...............................................349
        第三部分 派生数据
        第10章 批处理系统 ................................ 367
        使用UNIX工具进行批处理 .............................368
        MapReduce与分布式文件系统 .........................375
        超越MapReduce ....................................394
        小结 ............................................403
        第11章 流处理系统 .............................. 413
        发送事件流 .......................................414
        数据库与流 .......................................424
        流处理 .........................................435
        小结 ............................................449
        第12章 数据系统的未来 ............................ 461
        数据集成 .........................................461
        分拆数据库 .......................................469
        端到端的正确性 ....................................484
        做正确的事情 .......................................500
        小结 ..............................................509
        术语表 ............................................ 521
     · · · · · ·     (收起)"
35144587,Go专家编程,9.1,(128人评价),任洪彩 / 电子工业出版社 / 2020-7 / 108.00元,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松...,https://book.douban.com/subject/35144587/,https://img3.doubanio.com/view/subject/s/public/s33699643.jpg,108.00元,9787121365577,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松地了解Go语言的内部运作机制。 本书首先介绍Go语言常见的数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者可以借此测验自身对该知识点的掌握程度。接着介绍了Go语言最基础的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了一些标准库、异常处理和依赖管理等非语法相关但非常重要的内容。最后结合作者的见闻，整理了一些发生在真实项目中的编程陷阱。,任洪彩，华为云原生团队核心成员，开源爱好者，深度参与CNCF（云原生计算基金会）旗下Kubernetes、Prometheus等项目贡献，Kubernetes资深成员，担任Kubernetes SIG-Instrumentation Approver，敏捷软件思想深度实践者，在Nokia、华为等公司参与过多个大型项目的研发与重构，对Go、C/C++、Python、Swift等语言均有深入的研究与实践。,"第1章　常见数据结构的实现原理
        1.1　管道
        1.1.1　热身测验
        1.1.2　特性速览
        1.1.3　实现原理
        1.2　slice
        1.2.1　热身测验
        1.2.2　特性速览
        1.2.3　实现原理
        1.2.4　切片表达式
        1.3　map
        1.3.1　热身测验
        1.3.2　特性速览
        1.3.3　实现原理
        1.4　struct
        1.4.1　热身测验
        1.4.2　内嵌字段
        1.4.3　方法受体
        1.4.4　字段标签
        1.5　iota
        1.5.1　热身测验
        1.5.2　特性速览
        1.5.3　实现原理
        1.6　string
        1.6.1　热身测验
        1.6.2　特性速览
        1.6.3　实现原理
        第2章　控制结构
        2.1　select
        2.1.1　热身测验
        2.1.2　特性速览
        2.1.3　实现原理
        2.2　for-range
        2.2.1　热身测验
        2.2.2　特性速览
        2.2.3　实现原理
        第3章　协程
        3.1　协程的概念
        3.2　调度模型
        3.3　调度策略
        第4章　内存管理
        4.1　内存分配
        4.2　垃圾回收
        4.3　逃逸分析
        第5章　并发控制
        5.1　channel
        5.2　WaitGroup
        5.3　context
        5.4　Mutex
        5.5　RWMutex
        5.5.1　读写锁的数据结构
        5.5.2　场景分析
        第6章　反射
        6.1　热身测验
        6.2　接口
        6.3　反射定律
        第7章　测试
        7.1　快速开始
        7.1.1　单元测试
        7.1.2　基准测试
        7.1.3　示例测试
        7.2　进阶测试
        7.2.1　子测试
        7.2.2　Main测试
        7.3　实现原理
        7.3.1　testing.common
        7.3.2　testing.TB接口
        7.3.3　单元测试的实现原理
        7.3.4　性能测试的实现原理
        7.3.5　示例测试的实现原理
        7.3.6　Main测试的实现原理
        7.3.7　go test的工作机制
        7.4　扩展阅读
        7.4.1　测试参数
        7.4.2　benchstat
        第8章　异常处理
        8.1　error
        8.1.1　热身测验
        8.1.2　基础error
        8.1.3　链式error
        8.1.4　工程迁移
        8.2　defer
        8.2.1　热身测验
        8.2.2　约法三章
        8.2.3　实现原理
        8.2.4　性能优化
        8.3　panic
        8.3.1　热身测验
        8.3.2　工作机制
        8.3.3　源码剖析
        8.4　recover
        8.4.1　热身测验
        8.4.2　工作机制
        8.4.3　源码剖析
        第9章　定时器
        9.1　一次性定时器（Timer）
        9.1.1　快速开始
        9.1.2　实现原理
        9.2　周期性定时器（Ticker）
        9.2.1　快速开始
        9.2.2　实现原理
        9.3　runtimeTimer
        9.3.1　实现原理
        9.3.2　性能优化
        9.4　案例分享
        第10章　语法糖
        10.1　简短变量声明符
        10.1.1　热身测验
        10.1.2　规则
        10.2　可变参函数
        第11章　版本管理
        11.1　安装Go
        11.2　删除Go
        11.3　升级Go
        11.4　Go版本管理器
        11.4.1　快速开始
        11.4.2　工作机制
        11.4.3　小结
        11.5　源码编译
        11.5.1　源码下载
        11.5.2　源码编译过程
        第12章　Go语言依赖管理
        12.1　GOPATH
        12.1.1　GOROOT是什么
        12.1.2　GOPATH是什么
        12.1.3　依赖查找
        12.1.4　GOPATH的缺点
        12.2　vendor
        12.2.1　vendor目录位置
        12.2.2　搜索顺序
        12.2.3　vendor的不足
        12.3　Go Module
        12.3.1　Go Module基础
        12.3.2　快速实践
        12.3.3　replace指令
        12.3.4　exclude指令
        12.3.5　indirect指令
        12.3.6　版本选择机制
        12.3.7　incompatible
        12.3.8　伪版本
        12.3.9　依赖包存储
        12.3.10　go.sum
        12.3.11　模块代理
        12.3.12　GOSUMDB的工作机制
        12.3.13　GOSUMDB的实现原理
        12.3.14　第三方代理
        12.3.15　私有模块
        12.3.16　Go Module的演进
        第13章　编程陷阱
        13.1　切片扩容
        13.2　空切片
        13.3　append的本质
        13.4　循环变量引用
        13.5　协程引用循环变量
        13.6　recover失效
     · · · · · ·     (收起)"
25844633,实现领域驱动设计,8.4,(416人评价),Vaughn Vernon / 滕云 / 电子工业出版社 / 2014-3 / 99.00元,领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如...,https://book.douban.com/subject/25844633/,https://img1.doubanio.com/view/subject/s/public/s29544670.jpg,99.00元,9787121224485,"领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为...(展开全部)





领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为一本DDD 参考书。",作者：Vaughn Vernon是一个经验丰富的软件工匠，在软件设计、开发和架构方面拥有超过25年的从业经验。他提倡通过创新来简化软件的设计和实现。从20世纪80年代开始，他便开始使用面向对象语言进行编程；在 20世纪 90年代早期，他便在领域建模中应用了领域驱动设计，那时他使用的是Smalltalk语言。他在很多业务领域都有从业经验，包括航空、环境、地理、保险、医学和电信等领域。同时，Vaughn在技术上也取得了很大的成功，包括开发可重用的框架和类库等。他在全球范围之内提供软件咨询和演讲，此外，他还在许多国家教授《实现领域驱动设计》的课程。你可以通过www.VaughnVernon.co访问到他的最新研究成果。他的Twitter：@VaughnVernon。,"序............... xix
        前言............. xxi
        致谢............ xxxi
        关于作者................... xxxv
        如何使用本书.........xxxvii
        第1章 DDD入门...............1
        我能DDD吗？..................2
        为什么我们需要DDD.............5
        如何DDD...................... 17
        使用DDD的业务价值..............22
        1.你获得了一个非常有用的领域模型................22
        2.你的业务得到了更准确的定义和理解............23
        3.领域专家可以为软件设计做出贡献...........23
        4.更好的用户体验....................23
        5.清晰的模型边界.....................24
        6.更好的企业架构..............24
        7.敏捷、迭代式和持续建模....................24
        8.使用战略和战术新工具........................24
        实施DDD所面临的挑战.....................25
        虚构的案例，真实的实践................... 33
        本章小结.........................36
        第2章 领域、子域和限界上下文.....................37
        总览....................... 37
        工作中的子域和限界上下文............................. 38
        将关注点放在核心域上............................. 42
        战略设计为什么重要.................... 45
        现实世界中领域和子域...................48
        理解限界上下文..................... 53
        限界上下文不仅仅只包含模型..................... 57
        限界上下文的大小...................... 59
        与技术组件保持一致................... 61
        示例上下文........................ 62
        协作上下文..................63
        身份与访问上下文..................69
        敏捷项目管理上下文................. 71
        本章小结....................................73
        第3章 上下文映射图............................75
        上下文映射图为什么重要........................ 75
        绘制上下文映射图......................77
        产品和组织关系........................79
        映射3个示例限界上下文........................82
        本章小结............................97
        第4章 架构.......................99
        采访一个成功的CIO.................... 100
        分层................................. 104
        依赖倒置原则.................... 107
        六边形架构（端口与适配器）..................... 110
        面向服务架构.......................114
        REST................................117
        REST作为一种架构风格...........................117
        RESTful HTTP服务器的关键方面 ........................................ 118
        RESTful HTTP客户端的关键方面 ........................................ 119
        REST和DDD..................... 120
        为什么是REST？......................... 121
        命令和查询职责分离——CQRS................. 121
        CQRS的各个方面........................ 123
        处理具有最终一致性的查询模型.................. 128
        事件驱动架构................... 129
        管道和过滤器..................... 131
        长时处理过程（也叫Saga）................... 134
        事件源...................... 140
        数据网织和基于网格的分布式计算....................... 143
        数据复制..................... 144
        事件驱动网织和领域事件.................. 145
        持续查询................... 145
        分布式处理...................... 146
        本章小结............................ 148
        第5章 实体......................... 149
        为什么使用实体......................... 149
        唯一标识............................ 151
        用户提供唯一标识......................... 152
        应用程序生成唯一标识........................... 153
        持久化机制生成唯一标识............................ 156
        另一个限界上下文提供唯一标识..................... 160
        标识生成时间..................... 161
        委派标识......................... 163
        标识稳定性.......................... 165
        发现实体及其本质特征............................. 167
        揭开实体及其本质特征的神秘面纱................. 168
        挖掘实体的关键行为.......................... 172
        角色和职责......................... 176
        创建实体......................... 181
        验证................................... 183
        跟踪变化............................ 192
        本章小结................................ 192
        第6章 值对象..................... 193
        值对象的特征.......................... 194
        度量或描述.......................... 195
        不变性........................... 195
        概念整体................................ 196
        可替换性.......................... 199
        值对象相等性..........................200
        无副作用行为............................. 201
        最小化集成..................204
        用值对象表示标准类型........................206
        测试值对象........................ 210
        实现.............................. 214
        持久化值对象................. 219
        拒绝由数据建模泄漏带来的不利影响..................220
        ORM与单个值对象................................ 221
        多个值对象序列化到单个列中.....................224
        使用数据库实体保存多个值对象....................225
        使用联合表保存多个值对象..........................229
        ORM与枚举状态对象........................................230
        本章小结....................... 233
        第7章 领域服务.................................235
        什么是领域服务（首先，什么不是领域服务）.................. 237
        请确定你是否需要一个领域服务................................ 238
        建模领域服务.................. 241
        独立接口有必要吗.............................244
        一个计算过程..........................246
        转换服务........................249
        为领域服务创建一个迷你层.........................250
        测试领域服务............................250
        本章小结.................. 253
        第8章 领域事件...............................255
        何时/为什么使用领域事件.......................... 255
        建模领域事件.................... 258
        创建具有聚合特征的领域事件................... 263
        身份标识............................264
        从领域模型中发布领域事件.............................. 265
        发送方................... 265
        订阅方.....................269
        向远程限界上下文发布领域事件............................. 271
        消息设施的一致性........................... 271
        自治服务和系统............................. 272
        容许时延.................. 273
        事件存储.................. 274
        转发存储事件的架构风格........................... 279
        以REST资源的方式发布事件通知....................... 279
        通过消息中间件发布事件通知.................. 283
        实现............................284
        发布NotificationLog............... 285
        发布基于消息的事件通知..............................290
        本章小结........................297
        第9章 模块................................299
        通过模块完成设计..................................299
        模块的基本命名规范..........................302
        领域模型的命名规范...........................302
        敏捷项目管理上下文中的模块..............................305
        其他层中的模块..................308
        先考虑模块，再是限界上下文...............................309
        本章小结......................... 310
        第10章 聚合...................... 311
        在Scrum核心领域中使用聚合........................ 312
        第一次尝试：臃肿的聚合....................... 313
        第二次尝试：多个聚合........................... 314
        原则：在一致性边界之内建模真正的不变条件................317
        原则：设计小聚合............................. 319
        不要相信每一个用例............................ 321
        原则：通过唯一标识引用其他聚合......................... 322
        通过标识引用使多个聚合协同工作 ...................................... 324
        建模对象导航性............................ 325
        可伸缩性和分布式............................. 326
        原则：在边界之外使用最终一致性............................. 327
        谁的任务？............................ 328
        打破原则的理由......................... 329
        理由之一：方便用户界面................................. 329
        理由之二：缺乏技术机制............................. 330
        理由之三：全局事务.......................................... 331
        理由之四：查询性能.................................. 331
        遵循原则.................... 332
        通过发现，深入理解............................... 332
        重新思考设计............................... 332
        估算聚合成本............................. 334
        常见用例场景........................ 335
        内存消耗............................ 336
        探索另外的设计................................... 337
        实现最终一致性.............................. 338
        这是Scrum团队成员的任务吗？......................... 339
        决定的时候到了.............................. 341
        实现........................................ 341
        创建具有唯一标识的根实体........................ 342
        优先使用值对象...................... 343
        使用迪米特法则和“告诉而非询问”原则 ...............344
        乐观并发...............346
        避免依赖注入................348
        本章小结................................ 349
        第11章 工厂................. 351
        领域模型中的工厂................. 351
        聚合根中的工厂方法............................. 352
        创建CalendarEntry实例................... 353
        创建Discussion实例............................ 357
        领域服务中的工厂.......................... 358
        本章小结.......................... 361
        第12章 资源库...........................363
        面向集合资源库...........................364
        Hibernate实现...................... 369
        TopLink实现.................... 377
        面向持久化资源库........................ 379
        Coherence实现............................ 381
        MongoDB实现......................... 386
        额外的行为...................................... 391
        管理事务................................. 393
        警告................................. 397
        类型层级............................... 397
        资源库 vs 数据访问对象（DAO）..............................400
        测试资源库.......................................... 401
        以内存实现进行测试...................404
        本章小结................................407
        第13章 集成限界上下文...............................409
        集成基础知识....................................409
        分布式系统之间存在根本性区别.......................411
        跨系统边界交换信息...............................411
        通过REST资源集成限界上下文......................... 417
        实现REST资源.......................... 418
        使用防腐层实现REST客户端........... 421
        通过消息集成限界上下文................ 428
        从Scrum的产品负责人和团队成员处得到持续通知 .................... 428
        你能处理这样的职责吗？..................... 434
        长时处理过程，以及避免职责............. 439
        长时处理过程的状态机和超时跟踪器 .................................. 450
        设计一个更复杂的长时处理过程 ..........................................460
        当消息机制或你的系统不可用时 ...........................................464
        本章小结.................................465
        第14章 应用程序..................467
        用户界面...................................469
        渲染领域对象............. 470
        渲染数据传输对象................... 471
        使用调停者发布聚合的内部状态 .......................................... 471
        通过领域负载对象渲染聚合实例 .......................................... 472
        聚合实例的状态展现............................. 473
        用例优化资源库查询...................... 474
        处理不同类型的客户端................... 474
        渲染适配器以及处理用户编辑............. 475
        应用服务 ............................................ 478
        示例应用服务 ................................ 478
        解耦服务输出 .....................485
        组合多个限界上下文 .....................487
        基础设施 ...............................489
        企业组件容器 ....................490
        本章小结 ....................494
        附录A 聚合与事件源：A+ES ..........................495
        应用服务内部 ....................... 496
        命令处理器 .....................505
        Lambda语法...................508
        并发控制 ....................... 510
        A+ES所带来的结构自由性 .............. 513
        性能 ............................ 513
        实现事件存储 ..................... 516
        关系型持久化 .................. 520
        BLOB持久化 ...................... 522
        专注的聚合 ............................ 523
        读模型投射 ........................... 524
        与聚合设计一道使用 ................ 527
        增强事件 ........................... 527
        工具和模式 ................... 529
        事件序列器 .......... 530
        事件不变性 ................ 531
        值对象 ..................... 531
        协议生成 .................... 534
        单元测试和需求规范 .............. 535
        事件源和函数式语言 .......... 536
        参考文献 ..................539
     · · · · · ·     (收起)"
30333919,架构整洁之道,8.7,(858人评价),【美】Robert C. Martin（罗伯特 C. 马丁） / 电子工业出版社 / 2018-9 / 99.00元,《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过...,https://book.douban.com/subject/30333919/,https://img9.doubanio.com/view/subject/s/public/s29943454.jpg,99.00元,9787121347962,"《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构...(展开全部)





《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构设计，还是软件研发管理，《架构整洁之道》都是不可或缺的。","Robert C·Martin
作者","第1部分  概述
        第1章  设计与架构究竟是什么  3
        目标是什么  4
        案例分析  5
        本章小结  11
        第2章  两个价值维度  12
        行为价值  13
        架构价值  13
        哪个价值维度更重要  14
        艾森豪威尔矩阵  15
        为好的软件架构而持续斗争  16
        第2部分  从基础构件开始：编程范式
        第3章  编程范式总览  21
        结构化编程  22
        面向对象编程  22
        函数式编程  23
        仅供思考  23
        本章小结  24
        第4章  结构化编程  25
        可推导性  26
        goto是有害的  28
        功能性降解拆分  29
        形式化证明没有发生  29
        科学来救场  29
        测试  30
        本章小结  31
        第5章  面向对象编程  32
        封装  33
        继承  36
        多态  38
        本章小结  44
        第6章  函数式编程  45
        整数平方  46
        不可变性与软件架构  47
        可变性的隔离  48
        事件溯源  49
        本章小结  51
        第3部分  设计原则
        第7章  SRP：单一职责原则  56
        反面案例2：代码合并  59
        解决方案  60
        本章小结  61
        第8章  OCP：开闭原则  62
        思想实验  63
        依赖方向的控制  67
        信息隐藏  67
        本章小结  67
        第9章  LSP：里氏替换原则  68
        继承的使用指导  69
        正方形/长方形问题  70
        LSP与软件架构  70
        违反LSP的案例  71
        本章小结  73
        第10章 ISP：接口隔离原则  74
        ISP与编程语言  76
        ISP与软件架构  76
        本章小结  77
        第11章 DIP：依赖反转原则  78
        稳定的抽象层  79
        工厂模式  80
        具体实现组件  82
        本章小结  82
        第4部分  组件构建原则
        第12章 组件  84
        组件发展史  85
        重定位技术  88
        链接器  88
        本章小结  90
        第13章 组件聚合  91
        复用/发布等同原则  92
        共同闭包原则  93
        共同复用原则  94
        组件聚合张力图  95
        本章小结  97
        第14章 组件耦合  98
        无依赖环原则  99
        自上而下的设计  105
        稳定依赖原则  106
        稳定抽象原则  112
        本章小结  117
        第5部分  软件架构
        第15章 什么是软件架构  120
        开发（Development）  122
        部署（Deployment）  123
        运行（Operation）  123
        维护（Maintenance）  124
        保持可选项  124
        设备无关性  126
        垃圾邮件  128
        物理地址寻址  129
        本章小结  130
        第16章 独立性  131
        用例  132
        运行  133
        开发  133
        部署  134
        保留可选项  134
        按层解耦  135
        用例的解耦  136
        解耦的模式  136
        开发的独立性  137
        部署的独立性  137
        重复  138
        再谈解耦模式  139
        本章小结  141
        第17章 划分边界  142
        几个悲伤的故事  143
        FitNesse  146
        应在何时、何处画这些线  148
        输入和输出怎么办  151
        插件式架构  152
        插件式架构的好处  153
        本章小结  154
        第18章 边界剖析  155
        跨边界调用  156
        令人生畏的单体结构  156
        部署层次的组件  158
        线程  159
        本地进程  159
        服务  160
        本章小结  161
        第19章 策略与层次  162
        层次（Level）  163
        本章小结  166
        第20章 业务逻辑  167
        业务实体  168
        用例  169
        请求和响应模型  171
        本章小结  172
        第21章 尖叫的软件架构  173
        架构设计的主题  174
        架构设计的核心目标  175
        那Web呢  175
        框架是工具而不是生活信条  175
        可测试的架构设计  176
        本章小结  176
        第22章 整洁架构  177
        依赖关系规则  179
        一个常见的应用场景  183
        本章小结  184
        第23章 展示器和谦卑对象  185
        谦卑对象模式  186
        展示器与视图  186
        测试与架构  187
        数据库网关  188
        数据映射器  188
        服务监听器  189
        本章小结  189
        第24章 不完全边界  190
        省掉最后一步  191
        单向边界  192
        门户模式  193
        本章小结  193
        第25章 层次与边界  194
        基于文本的冒险游戏：Hunt The Wumpus  195
        可否采用整洁架构  196
        交汇数据流  199
        数据流的分割  199
        本章小结  201
        第26章 Main组件  203
        最细节化的部分  204
        本章小结  208
        第27章 服务：宏观与微观  209
        面向服务的架构  210
        服务所带来的好处  210
        运送猫咪的难题  212
        对象化是救星  213
        基于组件的服务  215
        横跨型变更  216
        本章小结  216
        第28章 测试边界  217
        测试也是一种系统组件  218
        可测试性设计  219
        测试专用API  220
        本章小结  221
        第29章 整洁的嵌入式架构  222
        “程序适用测试”测试  225
        目标硬件瓶颈  228
        本章小结  238
        第6部分  实现细节
        第30章 数据库只是实现细节  240
        关系型数据库  241
        为什么数据库系统如此流行  242
        假设磁盘不存在会怎样  243
        实现细节  243
        但性能怎么办呢  244
        一段轶事  244
        本章小结  246
        第31章 Web是实现细节  247
        无尽的钟摆  248
        总结一下  250
        本章小结  251
        第32章 应用程序框架是实现细节  252
        框架作者  253
        单向婚姻  253
        风险  254
        解决方案  255
        不得不接受的依赖  255
        本章小结  256
        第33章 案例分析：视频销售网站  257
        产品  258
        用例分析  258
        组件架构  260
        依赖关系管理  261
        本章小结  262
        第34章 拾遗  263
        按层封装  264
        按功能封装  266
        端口和适配器  268
        按组件封装  270
        具体实现细节中的陷阱  274
        组织形式与封装的区别  275
        其他的解耦合模式  277
        本章小结：本书拾遗  279
        后序  280
        附录A  架构设计考古  283
     · · · · · ·     (收起)"
5387403,Effective C++,9.5,(1104人评价),[美] Scott Meyers / 侯捷 / 电子工业出版社 / 2011-1-1 / 65.00元,"在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。
作者高超的技术把握力、独特...",https://book.douban.com/subject/5387403/,https://img2.doubanio.com/view/subject/s/public/s4647091.jpg,65.00元,9787121123320,在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。 作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和仿效。 这本书不是读完一遍就可以束之高阁的快餐读物，也不是用以解决手边问题的参考手册，而是需要你去反复阅读体会的，C++是真正程序员的语言，背后有着精深的思想与无以伦比的表达能力，这使得它具有类似宗教般的魅力。,"侯捷
译者","译序
        中英简繁术语对照
        目录
        序言
        致谢
        导读
        1. 让自己习惯c++
        2. 构造/析构/赋值运算
        3. 资源管理
        4. 设计与声明
        5. 实现
        6. 继承与面向对象设计
        7. 模板与泛型编程
        8. 定制new和delete
        9. 杂项讨论
        a 本书之外
        b 新旧版条款对照
        索引
     · · · · · ·     (收起)"
36654266,高级算法和数据结构,9.7,(28人评价),马塞洛·拉·罗卡（Marcello La Rocca） / 肖鉴明 / 人民邮电出版社 / 2023-12 / 149.80元,这是一本关于“高级/进阶”算法和数据结构的图书，主要介绍了用于Web应用程序、系统编程和数据处理领域的各种算法，旨在让读者了解如何用这些算法应对各种棘手的编...,https://book.douban.com/subject/36654266/,https://img9.doubanio.com/view/subject/s/public/s34704215.jpg,149.80元,9787115614575,这是一本关于“高级/进阶”算法和数据结构的图书，主要介绍了用于Web应用程序、系统编程和数据处理领域的各种算法，旨在让读者了解如何用这些算法应对各种棘手的编码挑战，以及如何将其应用于具体问题，以应对新技术浪潮下的“棘手”问题。 本书对一些广为人知的基本算法进行了扩展，还介绍了用于改善优先队列、有效缓存、对数据进行集群等的技术，以期读者能针对不同编程问题选出更好的解决方案。书中示例大多辅以图解，并以不囿于特定语言的伪代码以及多种语言的代码样本加以闸释。 学完本书，读者可以了解高级算法和数据结构的相关内容，并能运用这些知识让代码具备更优性能，甚至能够独立设计数据结构，应对需要自定义解决方案的情况。 本书可作为高等院校计算机相关专业本科高年级学生以及研究生的学习用书，也可供从事与算法相关工作的开发者参考。,Marcello La Rocca现为一家电商公司的高级软件工程师，曾参与开发Twitter、微软和苹果等公司的大型Web应用程序和数据基础设施，并发明了NeatSort这一自适应排序算法。他的主要研究领域为图、算法优化、机器学习和量子计算。,"第1章　初识数据结构　1
        1.1　数据结构　2
        1.1.1　定义数据结构　2
        1.1.2　描述数据结构　3
        1.1.3　算法与数据结构有区别吗　4
        1.2　设定目标：阅读本书后的期望　4
        1.3　打包背包：数据结构与现实世界的结合　5
        1.3.1　抽象化问题　5
        1.3.2　寻找解决方案　6
        1.3.3　拯救大家的算法　7
        1.3.4　打破常规来思考问题　8
        1.3.5　完美的结局　9
        1.4　小结　9
        第一部分　改进基本数据结构
        第2章　改进优先队列：d叉堆　12
        2.1　本章结构　13
        2.2　问题：处理优先级　13
        2.3　已知解决方案：让列表保持有序　15
        2.4　描述数据结构API：优先队列　15
        2.4.1　使用优先队列　16
        2.4.2　优先级为何非常重要　17
        2.5　具体数据结构　17
        2.5.1　性能比较　18
        2.5.2　正确的具体数据结构是什么　18
        2.5.3　堆　18
        2.5.4　优先级、最小堆和最大堆　20
        2.5.5　高级变体：d叉堆　21
        2.6　如何实现堆　22
        2.6.1　向上冒泡　22
        2.6.2　向下推动　25
        2.6.3　插入　27
        2.6.4　移除顶部元素　28
        2.6.5　修改　30
        2.6.6　处理重复优先级　31
        2.6.7　堆化　32
        2.6.8　API之外的方法：包含　34
        2.6.9　性能回顾　34
        2.6.10　从伪代码到实现　35
        2.7　用例：找到最大的k个元素　35
        2.7.1　选择正确的数据结构　36
        2.7.2　正确地使用数据结构　36
        2.7.3　代码写起来　36
        2.8　更多的用例　37
        2.8.1　图中的最小距离：Dijkstra算法　37
        2.8.2　更多的图算法：Prim算法　37
        2.8.3　数据压缩：霍夫曼编码　38
        2.9　对分支因子进行分析　41
        2.9.1　是否需要d叉堆　41
        2.9.2　运行时间　42
        2.9.3　寻找最佳分支因子　42
        2.9.4　分支因子与内存的关系　43
        2.10　性能分析：寻找最佳分支因子　43
        2.10.1　剖析　44
        2.10.2　解释结果　45
        2.10.3　堆化的谜团　49
        2.10.4　选择最佳分支因子　49
        2.11　小结　50
        第3章　树堆：使用随机化来平衡二叉搜索树　52
        3.1　问题：多索引　53
        3.2　解决方案：描述与API　53
        3.3　树堆　54
        3.3.1　旋转　57
        3.3.2　一些设计问题　60
        3.3.3　实现搜索方法　61
        3.3.4　插入　61
        3.3.5　删除　64
        3.3.6　去顶、看顶以及修改　66
        3.3.7　返回最小键和最大键　67
        3.3.8　性能回顾　67
        3.4　应用：随机树堆　68
        3.4.1　平衡树　68
        3.4.2　引入随机化　70
        3.4.3　随机树堆的应用　71
        3.5　性能分析和剖析　72
        3.5.1　理论：期望高度　72
        3.5.2　剖析高度　74
        3.5.3　剖析运行时间　76
        3.5.4　剖析内存使用情况　78
        3.5.5　结论　78
        3.6　小结　80
        第4章　布隆过滤器：减少跟踪内容所需的内存　81
        4.1　字典问题：跟踪事物　82
        4.2　实现字典的其他方法　83
        4.3　描述数据结构API：关联数组　83
        4.4　具体数据结构　84
        4.4.1　无序数组：快速插入，慢速搜索　84
        4.4.2　有序数组和二分查找：慢插入，稍微快一些的搜索　85
        4.4.3　哈希表：在不需要有序的情况下，具有平均常数时间的性能　86
        4.4.4　二叉搜索树：所有操作都是对数阶的　86
        4.4.5　布隆过滤器：与哈希表一样快，但（由于一个缺陷而）更节省内存　88
        4.5　表面之下：布隆过滤器是如何工作的　88
        4.6　实现　89
        4.6.1　使用布隆过滤器　90
        4.6.2　位的读取和写入　91
        4.6.3　找到键存储的位置　92
        4.6.4　生成哈希函数　93
        4.6.5　构造函数　93
        4.6.6　查找键　94
        4.6.7　存储键　95
        4.6.8　估计准确率　96
        4.7　应用场景　97
        4.7.1　缓存　97
        4.7.2　路由　98
        4.7.3　爬虫　98
        4.7.4　I/O提取器　98
        4.7.5　拼写检查器　98
        4.7.6　分布式数据库和文件系统　99
        4.8　为什么布隆过滤器是可行的　99
        4.8.1　为什么没有假阴性　100
        4.8.2　为什么有假阳性　100
        4.8.3　作为随机算法的布隆过滤器　101
        4.9　性能分析　101
        4.9.1　运行时间　101
        4.9.2　构造函数　102
        4.9.3　存储元素　102
        4.9.4　查找元素　102
        4.10　估计布隆过滤器的精确度　102
        4.11　改进的变体　106
        4.11.1　布隆表过滤器　106
        4.11.2　组合布隆过滤器　106
        4.11.3　分层布隆过滤器　106
        4.11.4　压缩布隆过滤器　107
        4.11.5　可扩展布隆过滤器　107
        4.12　小结　108
        第5章　不交集：次线性时间的处理过程　109
        5.1　不同子集问题　110
        5.2　解决方案的论证　111
        5.3　描述数据结构API：不交集　112
        5.4　简单解决方案　113
        5.5　使用树状结构　117
        5.5.1　从链表转移到树　117
        5.5.2　实现使用树的版本　118
        5.6　改进运行时间的启发式算法　120
        5.6.1　路径压缩　121
        5.6.2　实现平衡性与路径压缩　122
        5.7　应用程序　124
        5.7.1　图：连通分量　124
        5.7.2　图：最小生成树的Kruskal算法　124
        5.7.3　聚类　125
        5.7.4　合一　126
        5.8　小结　126
        第6章　trie与基数树：高效的字符串搜索　127
        6.1　拼写检查　128
        6.1.1　拼写检查器的设计　128
        6.1.2　压缩是关键　129
        6.1.3　描述与API　129
        6.2　trie　130
        6.2.1　为什么trie更好　132
        6.2.2　搜索　134
        6.2.3　插入　137
        6.2.4　删除　139
        6.2.5　搜索最长前缀词　140
        6.2.6　返回匹配特定前缀的所有键　141
        6.2.7　什么时候应该使用trie　143
        6.3　基数树　144
        6.3.1　节点和边　146
        6.3.2　搜索　148
        6.3.3　插入　149
        6.3.4　删除　151
        6.3.5　搜索最长前缀词　153
        6.3.6　返回匹配特定前缀的所有键　153
        6.4　应用程序　154
        6.4.1　拼写检查器　154
        6.4.2　字符串相似度　156
        6.4.3　字符串排序　157
        6.4.4　T9　157
        6.4.5　自动完成　158
        6.5　小结　158
        第7章　用例：LRU缓存　160
        7.1　不要重复计算　160
        7.2　第一次尝试：记住数据　163
        7.2.1　描述与API　164
        7.2.2　请保存新数据　164
        7.2.3　处理异步调用　165
        7.2.4　将缓存的值标记为“正在加载”　166
        7.3　内存（真的）不够　167
        7.4　清除陈旧数据：LRU缓存　168
        7.4.1　有时必须要重复解决问题　169
        7.4.2　时间排序　170
        7.4.3　性能　174
        7.5　当新数据更有价值时：LFU　175
        7.5.1　如何选择缓存的清除策略　176
        7.5.2　LFU缓存有什么不同　176
        7.5.3　性能　178
        7.5.4　LFU缓存的不足　178
        7.6　如何使用缓存也同样重要　179
        7.7　同步简介　180
        7.7.1　（在Java中）解决并发问题　182
        7.7.2　锁简介　183
        7.7.3　获取锁　183
        7.7.4　重入锁　184
        7.7.5　读锁　185
        7.7.6　解决并发的其他方法　186
        7.8　缓存应用程序　186
        7.9　小结　187
        第二部分　多维查询
        第8章　最近邻搜索　190
        8.1　最近邻搜索问题　190
        8.2　解决方案　191
        8.2.1　第一次尝试　191
        8.2.2　有时缓存并不是答案　191
        8.2.3　简化事情以获得灵感　192
        8.2.4　谨慎选择数据结构　193
        8.3　描述与API　194
        8.4　迁移到k维空间　195
        8.4.1　一维二分查找　196
        8.4.2　迁移到更高维度　196
        8.4.3　用数据结构对二维空间进行建模　197
        8.5　小结　198
        第9章　k-d树：索引多维数据　199
        9.1　从结束的地方继续　199
        9.2　迁移到k维空间：循环遍历
        维度　199
        9.2.1　构造BST　201
        9.2.2　不变量　204
        9.2.3　保持平衡的重要性　204
        9.3　方法　205
        9.3.1　搜索　206
        9.3.2　插入　208
        9.3.3　平衡树　209
        9.3.4　删除　212
        9.3.5　最近邻搜索　218
        9.3.6　区域搜索　224
        9.3.7　所有方法的回顾　227
        9.4　限制与可能的改进　228
        9.5　小结　229
        第10章　相似性搜索树：图像检索的近似
        最近邻搜索　230
        10.1　从结束的地方继续　230
        10.1.1　一个新的（更复杂的）例子　231
        10.1.2　克服k-d树的缺陷　232
        10.2　R树　232
        10.2.1　先退一步：B树简介　232
        10.2.2　由B树到R树　233
        10.2.3　在R树中插入点　236
        10.2.4　搜索　237
        10.3　SS树　238
        10.3.1　搜索　241
        10.3.2　插入　244
        10.3.3　插入：方差、均值与投影　249
        10.3.4　插入：分裂节点　252
        10.3.5　删除　255
        10.4　相似性搜索　259
        10.4.1　最近邻搜索　260
        10.4.2　区域搜索　262
        10.4.3　近似相似性搜索　263
        10.5　SS+树　265
        10.5.1　SS树会更好吗　266
        10.5.2　缓解超球体的限制　267
        10.5.3　改进拆分启发式算法　267
        10.5.4　减少重叠　268
        10.6　小结　270
        第11章　最近邻搜索的应用　271
        11.1　应用程序：查找最近的枢纽　271
        11.1.1　解决方案的初稿　272
        11.1.2　天堂里的麻烦　273
        11.2　中心化应用程序　274
        11.2.1　过滤点　274
        11.2.2　复杂的决定　276
        11.3　迁移到分布式应用程序　278
        11.3.1　处理HTTP通信的问题　279
        11.3.2　保持库存同步　281
        11.3.3　经验教训　281
        11.4　其他应用程序　282
        11.4.1　色彩还原　282
        11.4.2　粒子的相互作用　283
        11.4.3　多维数据库查询的优化　285
        11.4.4　聚类　287
        11.5　小结　287
        第12章　聚类　288
        12.1　聚类简介　289
        12.1.1　机器学习的类型　289
        12.1.2　聚类的类型　290
        12.2　k均值算法　291
        12.2.1　k均值算法的问题　295
        12.2.2　维度诅咒再次来袭　296
        12.2.3　k均值算法的性能分析　297
        12.2.4　用k-d树来加快k均值算法　297
        12.2.5　关于k均值算法的最后一些提示　300
        12.3　DBSCAN算法　300
        12.3.1　直接可达与密度可达　301
        12.3.2　从定义到算法　302
        12.3.3　实现　304
        12.3.4　DBSCAN算法的优缺点　305
        12.4　OPTICS算法　307
        12.4.1　定义　308
        12.4.2　OPTICS算法的核心思想　308
        12.4.3　从可达距离到聚类　311
        12.4.4　分层聚类　314
        12.4.5　性能分析和最终的考虑　318
        12.5　评估聚类结果：评估指标　318
        12.6　小结　322
        第13章　并行聚类：MapReduce与树冠聚类　323
        13.1　并行化　323
        13.1.1　并行计算与分布式计算　324
        13.1.2　并行化k均值算法　325
        13.1.3　树冠聚类　325
        13.1.4　应用树冠聚类　327
        13.2　MapReduce　328
        13.2.1　MapReduce是如何工作的　328
        13.2.2　先映射，后归约　331
        13.2.3　表面之下，还有更多　334
        13.3　MapReduce版本的k均值算法　334
        13.3.1　并行化树冠聚类　337
        13.3.2　使用树冠聚类来进行质心的初始化　339
        13.3.3　MapReduce版本的树冠聚类　340
        13.4　MapReduce版本的DBSCAN 算法　343
        13.5　小结　348
        第三部分　平面图与最小交叉数
        第14章　图简介：寻找距离最短的
        路径　350
        14.1　定义　351
        14.1.1　图的实现　351
        14.1.2　作为代数类型的图　353
        14.1.3　伪代码　354
        14.2　图的属性　354
        14.2.1　无向　355
        14.2.2　连通　355
        14.2.3　无环　356
        14.3　图的遍历：BFS与DFS　357
        14.3.1　优化配送路线　357
        14.3.2　广度优先搜索　359
        14.3.3　重建到目标的路径　361
        14.3.4　深度优先搜索　362
        14.3.5　再次比较队列与堆栈　364
        14.3.6　投递包裹的最佳路线　365
        14.4　加权图中的最短路径：迪杰斯特拉 算法　365
        14.4.1　与BFS算法的区别　366
        14.4.2　实现　367
        14.4.3　分析　368
        14.4.4　投递包裹的最佳路线　369
        14.5　超越迪杰斯特拉算法：A*
        算法　370
        14.5.1　A*算法到底有多好　372
        14.5.2　将启发式函数作为平衡实时数据的一种方式　375
        14.6　小结　376
        第15章　图嵌入与平面性：绘制具有最少相交边的图　377
        15.1　图嵌入　378
        15.1.1　一些基础定义　379
        15.1.2　完全图与完全二分图　380
        15.2　平面图　381
        15.2.1　在实践中使用库拉托夫斯基定理　381
        15.2.2　平面性测试　382
        15.2.3　用于平面性测试的朴素算法　383
        15.2.4　提高性能　386
        15.2.5　高效的算法　388
        15.3　非平面图　389
        15.3.1　找到交叉数　391
        15.3.2　直线交叉数　392
        15.4　边的交叉点　393
        15.4.1　直线线段　394
        15.4.2　折线　397
        15.4.3　贝塞尔曲线　397
        15.4.4　二次贝塞尔曲线之间的交点　398
        15.4.5　顶点与顶点相交以及边与顶点相交　401
        15.5　小结　402
        第16章　梯度下降：（不仅是）图的优化问题　403
        16.1　用于交叉数的启发式算法　404
        16.1.1　刚才提到启发式了吗　404
        16.1.2　扩展到曲线边　408
        16.2　优化的工作原理　409
        16.2.1　成本函数　410
        16.2.2　阶跃函数与局部最小值　412
        16.2.3　优化随机抽样算法　412
        16.3　梯度下降　414
        16.3.1　梯度下降中的数学描述　415
        16.3.2　几何解释　416
        16.3.3　什么时候可以应用梯度下降　418
        16.3.4　梯度下降的问题　418
        16.4　梯度下降的应用　419
        16.5　使用梯度下降进行图嵌入　422
        16.5.1　另一种标准　423
        16.5.2　实现　425
        16.6　小结　426
        第17章　模拟退火：超越局部最小值的优化　427
        17.1　模拟退火　428
        17.1.1　有时候需要先向上爬才能到达底部　429
        17.1.2　实现　431
        17.1.3　为什么模拟退火是有效的　432
        17.1.4　短程与长程的转换　434
        17.1.5　变体　435
        17.1.6　模拟退火与梯度下降：应该选择哪一个呢　436
        17.2　模拟退火与旅行推销员　436
        17.2.1　精确解与近似解　438
        17.2.2　可视化成本　438
        17.2.3　修剪域　440
        17.2.4　状态转换　440
        17.2.5　相邻交换与随机交换　443
        17.2.6　TSP近似算法的应用　444
        17.3　模拟退火与图嵌入　444
        17.3.1　最小边交叉　445
        17.3.2　力导向绘制　446
        17.4　小结　450
        第18章　遗传算法：受生物学启发的快速收敛优化　451
        18.1　遗传算法简介　451
        18.1.1　来自大自然的灵感　453
        18.1.2　染色体　456
        18.1.3　种群　457
        18.1.4　适应度　458
        18.1.5　自然选择　459
        18.1.6　选择交配的个体　461
        18.1.7　交叉操作　466
        18.1.8　突变操作　468
        18.1.9　遗传算法模板　469
        18.1.10　遗传算法在什么时候效果最好　470
        18.2　TSP　471
        18.2.1　适应度、染色体与初始化　471
        18.2.2　突变操作　472
        18.2.3　交叉操作　472
        18.2.4　结果与参数调整　473
        18.2.5　超越TSP：优化整个车队的路线　476
        18.3　最小顶点覆盖　477
        18.3.1　顶点覆盖的应用　478
        18.3.2　实现遗传算法　478
        18.4　遗传算法的其他应用　480
        18.4.1　最大流问题　480
        18.4.2　蛋白质折叠　481
        18.4.3　超越遗传算法　482
        18.4.4　算法，超越本书　483
        18.5　小结　483
        附录A　伪代码快速指南　485
        附录B　大O符号　494
        附录C　核心数据结构　500
        附录D　类似于优先队列的容器　511
        附录E　递归　514
        附录F　分类问题与随机算法的度量指标　520
     · · · · · ·     (收起)"
35006892,程序员修炼之道（第2版）,9.1,(725人评价),[美] David Thomas、[美] Andrew Hunt / 云风 / 电子工业出版社 / 2020-4-1 / 89.00元,本书之所以在全球范围内广泛传播，被一代代开发者奉为圭臬，盖因它可以创造出真正的价值：或编写出更好的软件，或探究出编程的本质，而所有收获均不依赖于特定语言、框...,https://book.douban.com/subject/35006892/,https://img9.doubanio.com/view/subject/s/public/s33836286.jpg,89.00元,9787121384356,本书之所以在全球范围内广泛传播，被一代代开发者奉为圭臬，盖因它可以创造出真正的价值：或编写出更好的软件，或探究出编程的本质，而所有收获均不依赖于特定语言、框架和方法。时隔20年的新版，经过全面的重新选材、组织和编写，覆盖哲学、方法、工具、设计、解耦、并发、重构、需求、团队等务实话题的最佳实践及重大陷阱，以及易于改造、复用的架构技术。本书极具洞察力与趣味性，适合从初学者到架构师的各阶层读者潜心研读或增广见闻。,"云风
译者","序
        新版前言
        第一版前言
        提示1 关注你的技艺
        提示2 思考！思考你的工作
        第1章 务实的哲学
        1 人生是你的
        提示3 你有权选择
        2 我的源码被猫吃了
        提示4 提供选择，别找借口
        3 软件的熵
        提示5 不要放任破窗
        4 石头做的汤和煮熟的青蛙
        提示6 做推动变革的催化剂
        提示7 牢记全景
        5 够好即可的软件
        提示8 将质量要求视为需求问题
        6 知识组合
        提示9 对知识组合做定期投资
        提示10 批判性地分析你读到和听到的东西
        7 交流！
        提示11 英语就是另一门编程语言
        提示12 说什么和怎么说同样重要
        提示13 把文档嵌进去，而不要栓在表面
        第2章 务实的方法
        8 优秀设计的精髓
        提示14 优秀的设计比糟糕的设计更容易变更
        9 DRY ——邪恶的重复
        提示15 DRY——不要重复自己
        提示16 让复用变得更容易
        10 正交性
        提示17 消除不相关事物之间的影响
        11 可逆性
        提示18 不设最终决定
        提示19 放弃追逐时尚
        12 曳光弹
        提示20 使用曳光弹找到目标
        13 原型与便签
        提示21 用原型学习
        14 领域语言
        提示22 靠近问题域编程
        15 估算
        提示23 通过估算来避免意外
        提示24 根据代码不断迭代进度表
        第3章 基础工具
        16 纯文本的威力
        提示25 将知识用纯文本保存
        17 Shell游戏
        提示26 发挥 Shell 命令的威力
        18 加强编辑能力
        提示27 游刃有余地使用编辑器
        19 版本控制
        提示28 永远使用版本控制
        20 调试
        提示29 去解决问题，而不是责备
        提示30 不要恐慌
        提示31 修代码前先让代码在测试中失败
        提示32 读一下那些该死的出错信息
        提示33 “select”没出问题
        提示34 不要假设，要证明
        21 文本处理
        提示35 学习一门文本处理语言
        22 工程日记
        第4章 务实的偏执
        提示36 你无法写出完美的软件
        23 契约式设计
        提示37 通过契约进行设计
        24 死掉的程序不会说谎
        提示38 尽早崩溃
        25 断言式编程
        提示39 使用断言去预防不可能的事情
        26 如何保持资源的平衡
        提示40 有始有终
        提示41 在局部行动
        27 不要冲出前灯范围
        提示42 小步前进——由始至终
        提示43 避免占卜
        第5章 宁弯不折
        28 解耦
        提示44 解耦代码让改变更容易
        提示45 只管命令不要询问
        提示46 不要链式调用方法
        提示47 避免全局数据
        提示48 如果全局唯一非常重要，那么将它包装到API 中
        29 在现实世界中抛球杂耍
        30 变换式编程
        提示49 编程讲的是代码，而程序谈的是数据
        提示50 不要囤积状态，传递下去
        31 继承税
        提示51 不要付继承税
        提示52 尽量用接口来表达多态
        提示53 用委托提供服务：“有一个”胜过“是一个”
        提示54 利用 mixin 共享功能
        32 配置
        提示55 使用外部配置参数化应用程序
        第6章 并发
        33 打破时域耦合
        提示56 通过分析工作流来提高并发性
        34 共享状态是不正确的状态
        提示57 共享状态是不正确的状态
        提示58 随机故障通常是并发问题
        35 角色与进程
        提示59 用角色实现并发性时不必共享状态
        36 黑板
        提示60 使用黑板来协调工作流
        第7章 当你编码时
        37 听从蜥蜴脑
        提示61 倾听你内心的蜥蜴
        38 巧合式编程
        提示62 不要依赖巧合编程
        39 算法速度
        提示63 评估算法的级别
        提示64 对估算做测试
        40 重构
        提示65 尽早重构，经常重构
        41 为编码测试
        提示66 测试与找 Bug 无关
        提示67 测试是代码的第一个用户
        提示68 既非自上而下，也不自下而上，基于端对端构建
        提示69 为测试做设计
        提示70 要对软件做测试，否则只能留给用户去做
        42 基于特性测试
        提示71 使用基于特性的测试来校验假设
        43 出门在外注意安全
        提示72 保持代码简洁，让攻击面最小
        提示73 尽早打上安全补丁
        44 事物命名
        提示74 好好取名；需要时更名
        第8章 项目启动之前
        45 需求之坑
        提示75 无人确切知道自己想要什么
        提示76 程序员帮助人们理解他们想要什么
        提示77 需求是从反馈循环中学到的
        提示78 和用户一起工作以便从用户角度思考
        提示79 策略即元数据
        提示80 使用项目术语表
        46 处理无法解决的难题
        提示81 不要跳出框框思考——找到框框
        47 携手共建
        提示82 不要一个人埋头钻进代码中
        48 敏捷的本质
        提示83 敏捷不是一个名词；敏捷有关你如何做事
        第9章 务实的项目
        49 务实的团队
        提示84 维持小而稳定的团队
        提示85 排上日程以待其成
        提示86 组织全功能的团队
        50 椰子派不上用场
        提示87 做能起作用的事，别赶时髦
        提示88 在用户需要时交付
        51 务实的入门套件
        提示89 使用版本控制来驱动构建、测试和发布
        提示90 尽早测试，经常测试，自动测试
        提示91 直到所有的测试都已运行，编码才算完成
        提示92 使用破坏者检测你的测试
        提示93 测试状态覆盖率，而非代码覆盖率
        提示94 每个 Bug 只找一次
        提示95 不要使用手动程序
        52 取悦用户
        提示96 取悦用户，而不要只是交付代码
        53 傲慢与偏见
        提示97 在作品上签名
        跋
        提示98 先勿伤害
        提示99 不要助纣为虐
        参考文献
        练习的参考答案
        译者跋
     · · · · · ·     (收起)"
36547630,Rust程序设计（第2版）,9.3,(33人评价),[美]吉姆·布兰迪（Jim Blandy）、[美]贾森 • 奥伦多夫（Jason Orendorff）、[美]莉奥诺拉 • F. S. 廷德尔（Leonora F. S. Tindall） / 汪志成（@雪狼） / 人民邮电出版社 / 2023-9-5 / 179.8元,"本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。
书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的...",https://book.douban.com/subject/36547630/,https://img3.doubanio.com/view/subject/s/public/s34641512.jpg,179.8元,9787115621818,"本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。 书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的高性能，并大大简化了并发程序的编写。第2版对上一版内容进行了重组和完善，新增了对“异步编程”的介绍。借助书中的大量案例，你也能用Rust编写出兼顾安全性与高性能的程序。本书内容包括基本数据类型、所有权、引用、表达式、错误处理、crate与模块、结构、枚举与模式等基础知识，以及特型与泛型、闭包、迭代器、集合、字符串与文本、输入与输出、并发、异步编程、宏等进阶知识。 编辑推荐 1.【内容全面】Rust一本就通，涉及Rust所有关键特性 2.【代码开源】基于Rust 2021大版本，开源示例代码 3.【实战性强】讲解深入浅出，含大量案例，实践性强 4.【作译者资深】Mozilla创始团员编写，雪狼翻译 ...(展开全部)





本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。 书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的高性能，并大大简化了并发程序的编写。第2版对上一版内容进行了重组和完善，新增了对“异步编程”的介绍。借助书中的大量案例，你也能用Rust编写出兼顾安全性与高性能的程序。本书内容包括基本数据类型、所有权、引用、表达式、错误处理、crate与模块、结构、枚举与模式等基础知识，以及特型与泛型、闭包、迭代器、集合、字符串与文本、输入与输出、并发、异步编程、宏等进阶知识。 编辑推荐 1.【内容全面】Rust一本就通，涉及Rust所有关键特性 2.【代码开源】基于Rust 2021大版本，开源示例代码 3.【实战性强】讲解深入浅出，含大量案例，实践性强 4.【作译者资深】Mozilla创始团员编写，雪狼翻译 5.【专家推荐】陈天、唐刚、王旭、张汉东、张炎泼 6.【超强品控】30位一线Rust开发者与爱好者精心审读",吉姆·布兰迪（Jim Blandy），Mozilla Firefox工程师，Subversion版本控制系统最初设计者之一。拥有40多年编程经验，其中包括30多年自由软件开发经验，曾在GNU Emacs、GNU Debugger等项目上工作。 贾森·奥伦多夫（Jason Orendorff），GitHub工程师，专注开发尚未公开的Rust项目，曾在Mozilla参与JavaScript引擎SpiderMonkey的开发。兴趣广泛，包括：语法学、烘焙、时间旅行，以及帮助人们理解复杂主题。 莉奥诺拉·F. S. 廷德尔（Leonora F. S. Tindall），软件工程师、类型系统爱好者。她喜欢使用Rust等先进语言在一些关键领域构建健壮且适应性强的系统软件，特别是在医疗保健和数据所有权管理等领域。,"目录
        专家推荐
        译者序
        前言
        中文版审读致谢
        第 1章　系统程序员也能享受美好 1
        1.1　Rust为你负重前行 2
        1.2　高效并行编程 3
        1.3　性能毫不妥协 3
        1.4　协作无边无界 4
        第 2章　Rust导览 5
        2.1　rustup与Cargo 6
        2.2　Rust函数 8
        2.3　编写与运行单元测试 9
        2.4　处理命令行参数 10
        2.5　搭建Web服务器 13
        2.6　并发 18
        2.6.1　什么是曼德博集 19
        2.6.2　解析并配对命令行参数 22
        2.6.3　从像素到复数的映射 24
        2.6.4　绘制曼德博集 25
        2.6.5　写入图像文件 26
        2.6.6　并发版曼德博程序 27
        2.6.7　运行曼德博绘图器 32
        2.6.8　大“安”无形 33
        2.7　文件系统与命令行工具 33
        2.7.1　命令行界面 34
        2.7.2　读写文件 36
        2.7.3　查找并替换 37
        第3章　基本数据类型 39
        3.1　固定宽度的数值类型 41
        3.1.1　整型 42
        3.1.2　检查算法、回绕算法、饱和算法和溢出算法 45
        3.1.3　浮点类型 46
        3.2　布尔类型 48
        3.3　字符 49
        3.4　元组 50
        3.5　指针类型 51
        3.5.1　引用 52
        3.5.2　Box 52
        3.5.3　裸指针 53
        3.6　数组、向量和切片 53
        3.6.1　数组 53
        3.6.2　向量 54
        3.6.3　切片 57
        3.7　字符串类型 58
        3.7.1　字符串字面量 58
        3.7.2　字节串 59
        3.7.3　内存中的字符串 60
        3.7.4　String 61
        3.7.5　使用字符串 62
        3.7.6　其他类似字符串的类型 62
        3.8　类型别名 63
        3.9　前路展望 63
        第4章　所有权与移动 64
        4.1　所有权 65
        4.2　移动 70
        4.2.1　更多移动类操作 74
        4.2.2　移动与控制流 75
        4.2.3　移动与索引内容 75
        4.3　Copy类型：关于移动的例外情况 77
        4.4　Rc与Arc：共享所有权 80
        第5章　引用 83
        5.1　对值的引用 84
        5.2　使用引用 86
        5.2.1　Rust引用与C++引用 87
        5.2.2　对引用变量赋值 88
        5.2.3　对引用进行引用 88
        5.2.4　比较引用 89
        5.2.5　引用永不为空 89
        5.2.6　借用任意表达式结果值的引用 89
        5.2.7　对切片和特型对象的引用 90
        5.3　引用安全 90
        5.3.1　借用局部变量 91
        5.3.2　将引用作为函数参数 93
        5.3.3　把引用传给函数 95
        5.3.4　返回引用 95
        5.3.5　包含引用的结构体 96
        5.3.6　不同的生命周期参数 98
        5.3.7　省略生命周期参数 100
        5.4　共享与可变 101
        5.5　应对复杂对象关系 107
        第6章　表达式 109
        6.1　表达式语言 109
        6.2　优先级与结合性 110
        6.3　块与分号 112
        6.4　声明 113
        6.5　if与match 115
        6.5.1　if let 117
        6.5.2　循环 117
        6.6　循环中的控制流 119
        6.7　return表达式 120
        6.8　为什么Rust中会有loop 121
        6.9　函数与方法调用 122
        6.10　字段与元素 123
        6.11　引用运算符 124
        6.12　算术运算符、按位运算符、比较运算符和逻辑运算符 125
        6.13　赋值 125
        6.14　类型转换 126
        6.15　闭包 127
        6.16　前路展望 127
        第7章　错误处理 128
        7.1　panic 128
        7.1.1　展开调用栈 129
        7.1.2　中止 130
        7.2　Result 130
        7.2.1　捕获错误 131
        7.2.2　Result类型别名 132
        7.2.3　打印错误 132
        7.2.4　传播错误 134
        7.2.5　处理多种Error类型 135
        7.2.6　处理“不可能发生”的错误 136
        7.2.7　忽略错误 138
        7.2.8　处理main()中的错误 138
        7.2.9　声明自定义错误类型 139
        7.2.10　为什么是Result 140
        第8章　crate与模块 141
        8.1　crate 141
        8.1.1　版本 144
        8.1.2　创建配置文件 145
        8.2　模块 145
        8.2.1　嵌套模块 146
        8.2.2　单独文件中的模块 147
        8.2.3　路径与导入 149
        8.2.4　标准库预导入 152
        8.2.5　公开use声明 152
        8.2.6　公开结构体字段 152
        8.2.7　静态变量与常量 153
        8.3　将程序变成库 153
        8.4　src/bin目录 155
        8.5　属性 156
        8.6　测试与文档 158
        8.6.1　集成测试 161
        8.6.2　文档 161
        8.6.3　文档测试 163
        8.7　指定依赖项 166
        8.7.1　版本 166
        8.7.2　Cargo.lock 167
        8.8　将crate发布到crates.io 168
        8.9　工作空间 170
        8.10　更多好资源 170
        第9章　结构体 172
        9.1　具名字段型结构体 172
        9.2　元组型结构体 175
        9.3　单元型结构体 175
        9.4　结构体布局 176
        9.5　用impl定义方法 177
        9.5.1　以Box、Rc或Arc形式传入self 179
        9.5.2　类型关联函数 179
        9.6　关联常量 180
        9.7　泛型结构体 181
        9.8　带生命周期参数的泛型结构体 183
        9.9　带常量参数的泛型结构体 183
        9.10　让结构体类型派生自某些公共特型 185
        9.11　内部可变性 186
        第 10章　枚举与模式 190
        10.1　枚举 191
        10.1.1　带数据的枚举 193
        10.1.2　内存中的枚举 194
        10.1.3　用枚举表示富数据结构 194
        10.1.4　泛型枚举 196
        10.2　模式 198
        10.2.1　模式中的字面量、变量和通配符 201
        10.2.2　元组型模式与结构体型模式 202
        10.2.3　数组型模式与切片型模式 203
        10.2.4　引用型模式 204
        10.2.5　匹配守卫 206
        10.2.6　匹配多种可能性 206
        10.2.7　使用@模式绑定 207
        10.2.8　模式能用在哪里 207
        10.2.9　填充二叉树 209
        10.3　大局观 210
        第 11章　特型与泛型 211
        11.1　使用特型 213
        11.1.1　特型对象 214
        11.1.2　泛型函数与类型参数 215
        11.1.3　使用哪一个 219
        11.2　定义与实现特型 220
        11.2.1　默认方法 221
        11.2.2　特型与其他人的类型 222
        11.2.3　特型中的Self 224
        11.2.4　子特型 225
        11.2.5　类型关联函数 226
        11.3　完全限定的方法调用 227
        11.4　定义类型之间关系的特型 228
        11.4.1　关联类型（或迭代器的工作原理） 229
        11.4.2　泛型特型（或运算符重载的工作原理） 231
        11.4.3　impl Trait 232
        11.4.4　关联常量 234
        11.5　逆向工程求限界 235
        11.6　以特型为基础 238
        第 12章　运算符重载 239
        12.1　算术运算符与按位运算符 240
        12.1.1　一元运算符 242
        12.1.2　二元运算符 243
        12.1.3　复合赋值运算符 244
        12.2　相等性比较 245
        12.3　有序比较 247
        12.4　Index与IndexMut 250
        12.5　其他运算符 252
        第 13章　实用工具特型 253
        13.1　Drop 254
        13.2　Sized 256
        13.3　Clone 259
        13.4　Copy 260
        13.5　Deref与DerefMut 260
        13.6　Default 263
        13.7　AsRef与AsMut 264
        13.8　Borrow与BorrowMut 266
        13.9　From与Into 267
        13.10　TryFrom与TryInto 270
        13.11　ToOwned 271
        13.12　Borrow与ToOwned的实际运用：谦卑的Cow 271
        第 14章　闭包 273
        14.1　捕获变量 274
        14.1.1　借用值的闭包 275
        14.1.2　“窃取”值的闭包 275
        14.2　函数与闭包的类型 277
        14.3　闭包性能 279
        14.4　闭包与安全 280
        14.4.1　“杀死”闭包 280
        14.4.2　FnOnce 281
        14.4.3　FnMut 282
        14.4.4　对闭包的Copy与Clone 284
        14.5　回调 285
        14.6　高效地使用闭包 288
        第 15章　迭代器 290
        15.1　Iterator特型与IntoIterator特型 291
        15.2　创建迭代器 292
        15.2.1　iter方法与iter_mut方法 293
        15.2.2　IntoIterator的实现 293
        15.2.3　from_fn与successors 295
        15.2.4　drain方法 296
        15.2.5　其他迭代器源 297
        15.3　迭代器适配器 298
        15.3.1　map与filter 298
        15.3.2　filter_map与flat_map 300
        15.3.3　flatten 302
        15.3.4　take与take_while 304
        15.3.5　skip与skip_while 305
        15.3.6　peekable 305
        15.3.7　fuse 306
        15.3.8　可逆迭代器与rev 307
        15.3.9　inspect 308
        15.3.10　chain 309
        15.3.11　enumerate 309
        15.3.12　zip 310
        15.3.13　by_ref 310
        15.3.14　cloned与copied 311
        15.3.15　cycle 312
        15.4　消耗迭代器 313
        15.4.1　简单累加：count、sum和product 313
        15.4.2　min与max 313
        15.4.3　max_by与min_by 314
        15.4.4　max_by_key与min_by_key 314
        15.4.5　对条目序列进行比较 315
        15.4.6　any与all 315
        15.4.7　position、rposition和ExactSizeIterator 316
        15.4.8　fold与rfold 316
        15.4.9　try_fold与try_rfold 317
        15.4.10　nth与nth_back 318
        15.4.11　last 319
        15.4.12　find、rfind和find_map 319
        15.4.13　构建集合：collect与FromIterator 320
        15.4.14　Extend特型 322
        15.4.15　partition 322
        15.4.16　for_each与try_for_each 323
        15.5　实现自己的迭代器 324
        第 16章　集合 328
        16.1　概述 329
        16.2　Vec&lt;T> 330
        16.2.1　访问元素 331
        16.2.2　迭代 332
        16.2.3　扩大向量与收缩向量 332
        16.2.4　联结 336
        16.2.5　拆分 336
        16.2.6　交换 339
        16.2.7　填充 339
        16.2.8　排序与搜索 339
        16.2.9　比较切片 341
        16.2.10　随机元素 341
        16.2.11　Rust中不存在失效型错误 342
        16.3　VecDeque&lt;T> 343
        16.4　BinaryHeap&lt;T> 344
        16.5　HashMap&lt;K, V>与BTreeMap&lt;K, V> 346
        16.5.1　条目 349
        16.5.2　对Map进行迭代 351
        16.6　HashSet&lt;T>与BTreeSet&lt;T> 351
        16.6.1　对Set进行迭代 352
        16.6.2　当相等的值不完全相同时 353
        16.6.3　针对整个Set的运算 353
        16.7　哈希 354
        16.8　使用自定义哈希算法 355
        16.9　在标准集合之外 357
        第 17章　字符串与文本 358
        17.1　一些Unicode背景知识 358
        17.1.1　ASCII、Latin-1和Unicode 359
        17.1.2　UTF-8编码 359
        17.1.3　文本方向性 361
        17.2　字符（char） 361
        17.2.1　字符分类 361
        17.2.2　处理数字 362
        17.2.3　字符大小写转换 363
        17.2.4　与整数之间的转换 364
        17.3　String与str 364
        17.3.1　创建字符串值 365
        17.3.2　简单探查 366
        17.3.3　追加文本与插入文本 366
        17.3.4　移除文本与替换文本 368
        17.3.5　搜索与迭代的约定 368
        17.3.6　搜索文本的模式 369
        17.3.7　搜索与替换 370
        17.3.8　遍历文本 371
        17.3.9　修剪 373
        17.3.10　字符串的大小写转换 374
        17.3.11　从字符串中解析出其他类型 374
        17.3.12　将其他类型转换为字符串 374
        17.3.13　借用其他类似文本的类型 375
        17.3.14　以UTF-8格式访问文本 376
        17.3.15　从UTF-8数据生成文本 376
        17.3.16　推迟分配 377
        17.3.17　把字符串当作泛型集合 379
        17.4　格式化各种值 379
        17.4.1　格式化文本值 380
        17.4.2　格式化数值 381
        17.4.3　格式化其他类型 383
        17.4.4　格式化值以进行调试 383
        17.4.5　格式化指针以进行调试 384
        17.4.6　按索引或名称引用参数 385
        17.4.7　动态宽度与动态精度 386
        17.4.8　格式化自己的类型 386
        17.4.9　在自己的代码中使用格式化语言 388
        17.5　正则表达式 389
        17.5.1　Regex的基本用法 389
        17.5.2　惰性构建正则表达式值 390
        17.6　规范化 391
        17.6.1　规范化形式 392
        17.6.2　unicode-normalization crate 393
        第 18章　输入与输出 395
        18.1　读取器与写入器 396
        18.1.1　读取器 397
        18.1.2　缓冲读取器 398
        18.1.3　读取行 399
        18.1.4　收集行 401
        18.1.5　写入器 402
        18.1.6　文件 403
        18.1.7　寻址 404
        18.1.8　其他读取器与写入器类型 404
        18.1.9　二进制数据、压缩和序列化 406
        18.2　文件与目录 407
        18.2.1　OsStr与Path 408
        18.2.2　Path与PathBuf的方法 409
        18.2.3　访问文件系统的函数 411
        18.2.4　读取目录 412
        18.2.5　特定于平台的特性 413
        18.3　网络 414
        第 19章　并发 417
        19.1　分叉与合并并行 418
        19.1.1　启动与联结 420
        19.1.2　跨线程错误处理 422
        19.1.3　跨线程共享不可变数据 422
        19.1.4　rayon 424
        19.1.5　重温曼德博集 426
        19.2　通道 427
        19.2.1　发送值 429
        19.2.2　接收值 431
        19.2.3　运行管道 432
        19.2.4　通道的特性与性能 434
        19.2.5　线程安全：Send与Sync 435
        19.2.6　绝大多数迭代器能通过管道传给通道 437
        19.2.7　除管道之外的用法 438
        19.3　共享可变状态 439
        19.3.1　什么是互斥锁 439
        19.3.2　Mutex&lt;T> 440
        19.3.3　mut与互斥锁 442
        19.3.4　为什么互斥锁不是“银弹” 443
        19.3.5　死锁 443
        19.3.6　“中毒”的互斥锁 444
        19.3.7　使用互斥锁的多消费者通道 444
        19.3.8　读/写锁（RwLock&lt;T>） 445
        19.3.9　条件变量（Condvar） 446
        19.3.10　原子化类型 447
        19.3.11　全局变量 448
        19.4　在Rust中编写并发代码的一点儿经验 451
        第 20章　异步编程 452
        20.1　从同步到异步 453
        20.1.1　Future 455
        20.1.2　异步函数与await表达式 456
        20.1.3　从同步代码调用异步函数：block_on 458
        20.1.4　启动异步任务 460
        20.1.5　异步块 464
        20.1.6　从异步块构建异步函数 466
        20.1.7　在线程池中启动异步任务 467
        20.1.8　你的Future实现Send了吗 467
        20.1.9　长时间运行的计算：yield_now与spawn_blocking 470
        20.1.10　对几种异步设计进行比较 471
        20.1.11　一个真正的异步HTTP客户端 471
        20.2　异步客户端与服务器 472
        20.2.1　Error类型与Result类型 474
        20.2.2　协议 474
        20.2.3　获取用户输入：异步流 475
        20.2.4　发送数据包 477
        20.2.5　接收数据包：更多异步流 478
        20.2.6　客户端的main函数 480
        20.2.7　服务器的main函数 481
        20.2.8　处理聊天连接：异步互斥锁 482
        20.2.9　群组表：同步互斥锁 484
        20.2.10　聊天组：tokio的广播通道 485
        20.3　原始Future与执行器：Future什么时候值得再次轮询 488
        20.3.1　调用唤醒器：spawn_blocking 489
        20.3.2　实现block_on 491
        20.4　固定（Pin） 493
        20.4.1　Future生命周期的两个阶段 493
        20.4.2　固定指针 496
        20.4.3　Unpin特型 497
        20.5　什么时候要用异步代码 498
        第 21章　宏 500
        21.1　宏基础 501
        21.1.1　宏展开的基础 502
        21.1.2　意外后果 503
        21.1.3　重复 505
        21.2　内置宏 507
        21.3　调试宏 508
        21.4　构建json!宏 509
        21.4.1　片段类型 510
        21.4.2　宏中的递归 513
        21.4.3　将特型与宏一起使用 514
        21.4.4　作用域界定与卫生宏 516
        21.4.5　导入宏和导出宏 518
        21.5　在匹配过程中避免语法错误 519
        21.6　超越macro_rules! 520
        第 22章　不安全代码 522
        22.1　不安全因素来自哪里 523
        22.2　不安全块 524
        22.3　示例：高效的ASCII字符串类型 525
        22.4　不安全函数 527
        22.5　不安全块还是不安全函数 528
        22.6　未定义行为 529
        22.7　不安全特型 531
        22.8　裸指针 532
        22.8.1　安全地解引用裸指针 534
        22.8.2　示例：RefWithFlag 535
        22.8.3　可空指针 537
        22.8.4　类型大小与对齐方式 537
        22.8.5　指针运算 538
        22.8.6　移动入和移动出内存 539
        22.8.7　示例：GapBuffer 542
        22.8.8　不安全代码中的panic安全性 548
        22.9　用联合体重新解释内存 549
        22.10　匹配联合体 551
        22.11　借用联合体 551
        第 23章　外部函数 552
        23.1　寻找共同的数据表示 552
        23.2　声明外部函数与变量 556
        23.3　使用库中的函数 557
        23.4　libgit2的裸接口 560
        23.5　libgit2的安全接口 566
        23.6　结论 575
        作者介绍 576
        封面介绍 576
     · · · · · ·     (收起)"
36457109,程序员的README,8.6,(95人评价),[美] 克里斯·里科米尼（Chris Riccomini）、[美] 德米特里·里亚博伊（Dmitriy Ryaboy） / 付裕 / 人民邮电出版社 / 2023-7-10 / 79.8,对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填...,https://book.douban.com/subject/36457109/,https://img9.doubanio.com/view/subject/s/public/s34570616.jpg,79.8,9787115599438,"对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新...(展开全部)





对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新入行的工程师在开始工作之前都能阅读的书。","付裕
译者","第1 章 前面的旅程 1
        1.1 你的目的地 1
        1.2 你的旅程地图 2
        1.2.1 新手营 3
        1.2.2 试炼之河 5
        1.2.3 贡献者之角 5
        1.2.4 运维之海 6
        1.2.5 胜任之湾 6
        1.3 前进！ 7
        第2 章 步入自觉阶段 8
        2.1 学习如何学习 9
        2.1.1 前置学习 9
        2.1.2 在实践中学习 9
        2.1.3 运行实例代码 11
        2.1.4 阅读 11
        2.1.5 观看讲座 13
        2.1.6 适度地参加会议和聚会 14
        2.1.7 跟班学习并同有经验的工程师结对 15
        2.1.8 用副业项目实践 16
        2.2 提出问题 17
        2.2.1 动手调查一下 17
        2.2.2 设置一个时间限制 17
        2.2.3 写下全过程 18
        2.2.4 别打扰别人 19
        2.2.5 多用“非打扰式”交流 20
        2.2.6 批量处理你的同步请求 20
        2.3 克服成长的障碍 21
        2.3.1 冒充者综合征 21
        2.3.2 邓宁-克鲁格效应 22
        2.4 行为准则 23
        2.5 升级加油站 23
        第3 章 玩转代码 25
        3.1 软件的熵 26
        3.2 技术债 26
        3.3 变更代码 29
        3.3.1 善于利用现有代码 30
        3.3.2 过手的代码要比之前更干净 32
        3.3.3 做渐变式的修改 33
        3.3.4 对重构要务实 33
        3.3.5 善用IDE 34
        3.3.6 请使用VCS 的最佳实践 34
        3.4 避“坑”指南 35
        3.4.1 保守一些的技术选型 36
        3.4.2 不要特立独行 39
        3.4.3 不要只分叉而不向上游提交修改 40
        3.4.4 克制重构的冲动 40
        3.5 行为准则 42
        3.6 升级加油站 42
        第4 章 编写可维护的代码 44
        4.1 防御式编程 45
        4.1.1 避免空值 45
        4.1.2 保持变量不可变 46
        4.1.3 使用类型提示和静态类型检查器 46
        4.1.4 验证输入 47
        4.1.5 善用异常 49
        4.1.6 异常要有精确含义 50
        4.1.7 早抛晚捕 51
        4.1.8 智能重试 52
        4.1.9 构建幂等系统 53
        4.1.10 及时释放资源 53
        4.2 关于日志的使用 54
        4.2.1 给日志分级 55
        4.2.2 日志的原子性 56
        4.2.3 关注日志性能 57
        4.2.4 不要记录敏感数据 59
        4.3 系统监控 59
        4.3.1 使用标准的监控组件 60
        4.3.2 测量一切 63
        4.4 跟踪器 64
        4.5 配置相关注意事项 64
        4.5.1 配置无须新花样 65
        4.5.2 记录并校验所有的配置 66
        4.5.3 提供默认值 67
        4.5.4 给配置分组 67
        4.5.5 将配置视为代码 67
        4.5.6 保持配置文件清爽 68
        4.5.7 不要编辑已经部署的配置 68
        4.6 工具集 68
        4.7 行为准则 70
        4.8 升级加油站 71
        第5 章 依赖管理 72
        5.1 依赖管理基础知识 73
        5.1.1 语义化版本 74
        5.1.2 传递依赖 75
        5.2 相依性地狱 76
        5.3 避免相依性地狱 80
        5.3.1 隔离依赖项 80
        5.3.2 按需添加依赖项 81
        5.3.3 指定依赖项的版本 82
        5.3.4 依赖范围最小化 84
        5.3.5 保护自己免受循环依赖的影响 84
        5.4 行为准则 85
        5.5 升级加油站 85
        第6 章 测试 87
        6.1 测试的多种用途 87
        6.2 测试类型 88
        6.3 测试工具 91
        6.3.1 模拟库 91
        6.3.2 测试框架 92
        6.3.3 代码质量工具 93
        6.4 自己动手编写测试 95
        6.4.1 编写干净的测试 95
        6.4.2 避免过度测试 96
        6.5 测试中的确定性 98
        6.5.1 种子随机数生成器 99
        6.5.2 不要在单元测试中调用远程系统 99
        6.5.3 采用注入式时间戳 99
        6.5.4 避免使用休眠和超时 102
        6.5.5 记得关闭网络套接字和文件句柄 102
        6.5.6 绑定到0 端口 103
        6.5.7 生成唯一的文件路径和数据库位置 103
        6.5.8 隔离并清理剩余的测试状态 103
        6.5.9 不要依赖测试顺序 104
        6.6 行为准则 105
        6.7 升级加油站 105
        第7 章 代码评审 107
        7.1 为什么需要评审代码? 107
        7.2 当你的代码被评审时 109
        7.2.1 准备工作 109
        7.2.2 用评审草案降低风险 110
        7.2.3 提交评审请勿触发测试 111
        7.2.4 预排大体量的代码修改 111
        7.2.5 不要太在意 112
        7.2.6 保持同理心，但不要容忍粗鲁 113
        7.2.7 保持主动 113
        7.3 评审别人的代码时 114
        7.3.1 分流评审请求 114
        7.3.2 给评审预留时间 114
        7.3.3 理解修改的意图 115
        7.3.4 提供全面的反馈 115
        7.3.5 要承认优点 116
        7.3.6 区分问题、建议和挑剔 116
        7.3.7 不要只做橡皮图章 117
        7.3.8 不要只局限于使用网页版的评审工具 118
        7.3.9 不要忘记评审测试代码 118
        7.3.10 推动决断 118
        7.4 行为准则 119
        7.5 升级加油站 120
        第8 章 软件交付 121
        8.1 软件交付流程 121
        8.2 分支策略 122
        8.3 构建环节 125
        8.3.1 打包需要带版本号 126
        8.3.2 将不同的资源单独打包 127
        8.4 发布环节 129
        8.4.1 请勿只想着发布 129
        8.4.2 将包发布到仓库 130
        8.4.3 保持版本不变性 131
        8.4.4 频繁发布 131
        8.4.5 对发布计划保持透明 132
        8.4.6 撰写变更日志和发行说明 132
        8.5 部署环节 133
        8.5.1 自动部署 133
        8.5.2 部署的原子性 134
        8.5.3 独立地部署应用 134
        8.6 展开环节 136
        8.6.1 系统监控 137
        8.6.2 特性开关 137
        8.6.3 熔断器 138
        8.6.4 并行的服务版本梯队 139
        8.6.5 摸黑启动 141
        8.7 行为准则 143
        8.8 升级加油站 144
        第9 章 On-Call 146
        9.1 On-Call 的工作方式 147
        9.2 On-Call 技能包 148
        9.2.1 随时响应 148
        9.2.2 保持专注 148
        9.2.3 确定工作优先级 149
        9.2.4 清晰的沟通 150
        9.2.5 跟踪你的工作 151
        9.3 事故处理 152
        9.3.1 分流 153
        9.3.2 协同 154
        9.3.3 应急方案 155
        9.3.4 解决方案 157
        9.3.5 后续行动 159
        9.4 提供支持 162
        9.5 不要逞英雄 164
        9.6 行为准则 165
        9.7 升级加油站 165
        第10 章 技术设计流程 167
        10.1 技术设计的V 形结构 168
        10.2 关于设计的思考 169
        10.2.1 定义问题 170
        10.2.2 着手调查 171
        10.2.3 进行实验 172
        10.2.4 给些时间 173
        10.3 撰写设计文档 174
        10.3.1 文档持续变更 174
        10.3.2 了解撰写文档的目的 175
        10.3.3 学会写作 176
        10.3.4 保证文档是最新的 176
        10.4 使用设计文档模板 177
        10.4.1 概要 178
        10.4.2 现状与背景 178
        10.4.3 变更的目的 178
        10.4.4 需求 179
        10.4.5 潜在的解决方案 179
        10.4.6 建议的解决方案 180
        10.4.7 设计与架构 180
        10.4.8 测试计划 181
        10.4.9 发布计划 181
        10.4.10 遗留的问题 181
        10.4.11 附录 181
        10.5 协作设计 182
        10.5.1 理解你的团队的设计评审流程 182
        10.5.2 不要让人惊讶 183
        10.5.3 用设计讨论来进行头脑风暴 183
        10.5.4 为设计出力 184
        10.6 行为准则 185
        10.7 升级加油站 185
        第11 章 构建可演进的架构 187
        11.1 理解复杂性 188
        11.2 可演进的设计 189
        11.2.1 你不是真的需要 189
        11.2.2 最小惊讶原则 191
        11.2.3 封装专业领域知识 193
        11.3 可演进的API 193
        11.3.1 保持API 小巧 194
        11.3.2 公开定义良好的服务端API 194
        11.3.3 保持API 变更的兼容性 195
        11.3.4 API 版本化 198
        11.4 可持续的数据管理 199
        11.4.1 数据库隔离 199
        11.4.2 使用schema 201
        11.4.3 schema 自动化迁移 203
        11.4.4 保持schema 的兼容性 206
        11.5 行为准则 207
        11.6 升级加油站 208
        第12 章 敏捷计划 210
        12.1 敏捷宣言 210
        12.2 敏捷计划的框架 211
        12.3 Scrum 框架 212
        12.3.1 用户故事 213
        12.3.2 任务分解 214
        12.3.3 故事点 214
        12.3.4 消化积压 216
        12.3.5 冲刺计划 216
        12.4 站会 217
        12.5 评审机制 218
        12.6 回顾会 219
        12.7 路线图 220
        12.8 行为准则 221
        12.9 升级加油站 222
        第13 章 与管理者合作 223
        13.1 管理者是做什么的 223
        13.2 沟通、目标与成长 224
        13.2.1 一对一面谈 225
        13.2.2 PPP 227
        13.2.3 OKR 229
        13.2.4 绩效考核 230
        13.3 向上管理 232
        13.3.1 接收反馈 232
        13.3.2 给予反馈 233
        13.3.3 讨论你的目标 235
        13.3.4 事情不顺时要采取行动 236
        13.4 行为准则 238
        13.5 升级加油站 239
        第14 章 职业生涯规划 241
        14.1 迈向资深之路 241
        14.2 职业生涯建议 242
        14.2.1 T 型人才 242
        14.2.2 参加工程师训练营 243
        14.2.3 主导你自己的晋升 244
        14.2.4 换工作需谨慎 246
        14.2.5 自我调节 247
        14.3 结尾寄语 248
     · · · · · ·     (收起)"
35503091,C语言程序设计：现代方法（第2版•修订版）,9.2,(114人评价),[美] K.N.金 / 吕秀锋、黄倩 / 图灵丨人民邮电出版社 / 2021-7 / 129.80元,"◎ 本书特色
近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分
哈佛、麻省理工、斯坦福等诸多名校C语言教材
基于C1X标准全新升级
浙江大...",https://book.douban.com/subject/35503091/,https://img9.doubanio.com/view/subject/s/public/s33927414.jpg,129.80元,9787115565198,"◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超...(展开全部)





◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超过95%的大学用C语言作为入门编程语言，但也因此把C语言当作一种学习编程的教学媒介语言来教，使得学生只学到了其中的基础部分，而对C语言近30年的发展及其在工业中的应用所知甚少。本书是难得的真正讲述C语言的教材，覆盖了C99、C11、C18标准的内容。本书非常适合今后会用C语言来做嵌入式系统、设备驱动和操作系统等产品开发的人士学习。在浙江大学，我们在工程实践课程中使用了本书的上一个版本，收获了良好的教学效果。 ——翁恺，浙江大学计算机学院教授 书如其名，本书以一种崭新的视角和通俗易懂的方式，来向读者介绍C语言的“现代方法”，聚焦程序设计的核心问题和方法，给C语言这门经久不衰、老而弥坚的语言赋予了崭新的面貌。本书介绍了C99和C1X的许多新特性，而且编排方式方便读者查阅。本书用现代的视角来解读C语言，每章后面的“问与答”也很贴心，适时地解答了读者在阅读过程中可能会遇到的很多疑难问题。本书内容特别适合具备一定语言基础，想深入了解C语言精髓的读者，我相信这本书一定会受到读者的欢迎，成为C语言爱好者提升内功的一本武林秘笈。 ——苏小红，哈尔滨工业大学教授、博士生导师，省级教学名师 本书讨论了C语言的所有特性，从C89一直贯穿到C18。内容足够新，也足够全面，这就是它的突出特色。 ——吴咏炜，Boolan首席咨询师 本书是C语言程序设计的经典图书，本次修订版增加了C1X的内容，并就C1X与之前的C89、C99进行了比对，做到了与时俱进。本书更是新增了第28章，重点介绍了C1X的多线程特性，相信对读者会有巨大的帮助。读者通过阅读本书，可深入理解C89、C99和C1X的演进，并进一步思考C语言为什么这么演进，这对提高自身的思维能力以及对软件工程问题的认知都会有帮助。 ——宋宝华，资深Linux专家",作者简介 K. N. 金（K. N. King） 世界知名的计算机程序设计教育家。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院和佐治亚州立大学。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide和Java Programming: From the Beginning。 译者简介 吕秀锋 曾任教于北京理工大学软件学院，讲授过多门计算机课程，包括“计算机基础（双语）”“C语言程序设计（双语）”“数据结构”“程序设计开发与实践”。 黄倩 河海大学计算机科学与技术系主任，兼任中国人工智能学会深度学习专委会委员、中国计算机学会多媒体技术专委会委员。博士毕业于中国科学院计算技术研究所，译有《编程珠玑（第2版）》等。,"第1章 C语言概述
        第2章 C语言基本概念
        第3章 格式化输入/输出
        第4章 表达式
        第5章 选择语句
        第6章 循环
        第7章 基本类型
        第8章 数组
        第9章 函数
        第10章 程序结构
        第11章 指针
        第12章 指针和数组
        第13章 字符串
        第14章 预处理器
        第15章 编写大型程序
        第16章 结构、联合和枚举
        第17章 指针的高级应用
        第18章 声明
        第19章 程序设计
        第20章 底层程序设计
        第21章 标准库
        第22章 输入/输出
        第23章 库对数值和字符数据的支持
        第24章 错误处理
        第25章 国际化特性
        第26章 其他库函数
        第27章 C99对数学计算的新增支持
        第28章 C1X新增的多线程和原子操作支持
        附录A C语言运算符
        附录B C1X与C99的比较
        附录C C99与C89的比较
        附录D C89与经典C的比较
        附录E 标准库函数
        附录F ASCII字符集
        延伸阅读
        索引
     · · · · · ·     (收起)"
1998341,计算机系统要素,9.1,(269人评价),[美] Noam Nisan、[美] Shimon Schocken / 周维、宋磊、陈曦 / 电子工业出版社 / 2007-01-01 / 45.00元,本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，...,https://book.douban.com/subject/1998341/,https://img9.doubanio.com/view/subject/s/public/s2207295.jpg,45.00元,9787121033360,"本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统...(展开全部)





本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统所必需的工具和资料，以及用于12个项目的200个测试程序。 全书内容广泛、涉猎全面，适合计算机及相关专业本科生、研究生、技术开发人员、教师以及技术爱好者参考和学习。","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
    · · · · · ·
    (更多)","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
        1.1.3 实际硬件结构
        1.1.4 硬件描述语言（HDL）
        1.1.5 硬件仿真
        1.2 规范详述
        1.2.1 Nand门
        1.2.2 基本逻辑门
        1.2.3 多位基本门
        1.2.4 多通道逻辑门
        1.3 实现
        1.4 观点
        1.5 项目
        第2章 布尔运算
        2.1 背景知识
        2.2 规范详述
        2.2.1 加法器
        2.2.2 算术逻辑单元（ALU）
        2.3 实现
        2.4 观点
        2.5 项目
        第3章 时序逻辑
        3.1 背景知识
        3.2 规范详述
        3.2.1 D触发器
        3.2.2 寄存器
        3.2.3 存储
        3.2.4 计数器
        3.3 实现
        3.4 观点
        3.5 项目
        第4章 机器语言
        4.1 背景知识
        4.1.1 机器
        4.1.2 语言
        4.1.3 命令
        4.2 Hack机器语言规范详述
        4.2.1 概述
        4.2.2 A-指令
        4.2.3 C-指令
        4.2.4 符号
        4.2.5 输入/输出处理
        4.2.6 语法规约和文件格式
        4.3 观点
        4.4 项目
        第5章 计算机体系结构
        5.1 背景知识
        5.1.1 存储程序概念
        5.1.2 冯?诺依曼结构
        5.1.3 内存
        5.1.4 中央处理器
        5.1.5 寄存器
        5.1.6 输入和输出
        5.2 Hack硬件平台规范详述
        5.2.1 概述
        5.2.2 中央处理器（CPU）
        5.2.3 指令内存
        5.2.4 数据内存
        5.2.5 计算机
        5.3 实现
        5.3.1 中央处理器
        5.3.2 内存
        5.3.3 计算机
        5.4 观点
        5.5 项目
        第6章 汇编编译器
        第7章 虚拟机Ⅰ：堆栈运算
        第8章 虚拟机Ⅱ：程序控制
        第9章 高级语言
        第10章 编译器Ⅰ：语法分析
        第11章 编译器Ⅱ：代码生成
        第12章 操作系统
        第13章 后记：发掘更多乐趣
        附录A： 硬件描述语言（HDL）
        附录B： 测试脚本语言
        索引
     · · · · · ·     (收起)"
35972849,代码大全2（纪念版）,9.3,(62人评价),[美] 史蒂夫·麦康奈尔(Steve McConnell) / 陈玉毅、陈军、杨志昂、洪佳、徐东伟、王国良、徐毅、李虎 / 清华大学出版社 / 2022-7-7 / 256.00,"《软件开发》杂志Jolt大奖
大而全，洞悉软件构建精髓
优而先，兼顾行业实践研究
奠定硬核技术领导力的经典
庸常变身卓越的实用性指导
《代码大全2》是著名科...",https://book.douban.com/subject/35972849/,https://img3.doubanio.com/view/subject/s/public/s34276333.jpg,256.00,9787302583646,"《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序...(展开全部)





《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。无论是什么背景的读者，阅读本书都有助于在更短的时间内、更容易地写出更好、更简洁、更优雅的程序。","史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现...(展开全部)




史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现象级科技类图书缔造者 • 会做（编程）又会教的一线程序员 • 《软件开发》杂志震撼图书大奖（两次） • 《软件开发》杂志生产力大奖（两次） •   西雅图大学杰出校友奖 • 《普吉特海湾商业期刊》40 UNDER 40杰出青年奖 •  波音和微软等公司顾问 •  ACM（计算机学会）金牌核心奖章得主 •  IEEE Software杂志主编 •  惠特曼文理学院优秀毕业生，PBK会员","第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界　003
        第2章　通过隐喻更充分地理解软件开发　009
        第3章　谋定而后动：前期准备　023
        第4章　关键的构建决策　057
        第II部分高质量的代码
        第5章　软件构建的设计　069
        第6章　可以工作的类　121
        第7章　高质量的子程序　157
        第8章　防御式编程　187
        第9章　伪代码编程过程　215
        第Ⅲ部分变量
        第10章　变量使用中的常规问题　239
        第11章　变量名称的威力　263
        第12章　基本数据类型　295
        第13章　不常见的数据类型　323
        第Ⅳ部分语句
        第14章　直线型代码的组织　353
        第15章　使用条件语句　361
        第16章　控制循环　373
        第17章　不常见的控制结构　395
        第18章　表驱动法　417
        第19章　常规控制问题　437
        第Ⅴ部分代码改进
        第20章　软件质量概述　469
        第21章　协同构建　483
        第22章　开发人员测试　503
        第23章　调试　541
        第24章　重构　569
        第25章　代码调优策略　591
        第26章　代码调优技术　613
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响　651
        第28章　管理构建　663
        第29章　集成　693
        第30章　编程工具　715
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格　733
        第32章　自文档代码　781
        第33章　个人性格　821
        第34章　关于软件匠艺　837
        第35章　更多信息来源　853
        详细目录
        第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界	003
        1.1什么是软件构建	003
        1.2软件构建为何如此重要	006
        1.3如何阅读本书	008
        第2章　通过隐喻更充分地
        理解软件开发	009
        2.1隐喻的重要性	009
        2.2如何使用软件隐喻	012
        2.3常见的软件隐喻	013
        第3章　谋定而后动：前期准备	023
        3.1前期准备的重要性	024
        3.2确定要开发什么类型的软件	030
        3.3定义问题的先决条件	034
        3.4需求的先决条件	036
        3.5架构的先决条件	041
        3.6前期准备所花费的时间	052
        第4章　关键的构建决策	057
        4.1编程语言的选择	057
        4.2编程约定	062
        4.3判断个人处于技术浪潮中的哪个阶段	062
        4.4选择重要的构建实践	065
        第II部分高质量的代码
        第5章　软件构建的设计	069
        5.1设计挑战	070
        5.2关键设计概念	073
        5.3设计构建基块：启发式方法	083
        5.4设计实践	107
        5.5点评各种流行的方法论	115
        第6章　可以工作的类	121
        6.1类的基础：抽象数据类型(ADT)	122
        6.2良好的类接口	129
        6.3设计和实现问题	139
        6.4创建类的理由	149
        6.5语言特定问题	153
        6.6超越类：包	153
        第7章　高质量的子程序	157
        7.1创建子程序的正当理由	160
        7.2子程序级别的设计	165
        7.3好的子程序名称	169
        7.4一个子程序应该有多长	171
        7.5如何使用子程序参数	173
        7.6函数使用中的特别注意事项	180
        7.7宏子程序和内联子程序	182
        第8章　防御式编程	187
        8.1保护程序，
        使其免受无效输入的影响	188
        8.2断言	189
        8.3错误处理技术	194
        8.4异常	198
        8.5隔离程序，使之包容
        由错误造成的损害	203
        8.6调试辅助代码	205
        8.7确定在生产代码中
        保留多少防御式代码	209
        8.8对防御式编程采取防御的姿态	211
        第9章　伪代码编程过程	215
        9.1类和子程序构建步骤总结	215
        9.2面向专家的伪代码	218
        9.3使用PPP构建子程序	220
        9.4PPP的替代方案	233
        第Ⅲ部分变量
        第10章　变量使用中的常规问题	239
        10.1数据扫盲	240
        10.2简化变量声明	241
        10.3变量初始化指南	242
        10.4作用域	247
        10.5持久性	254
        10.6绑定时间	255
        10.7数据类型和控制结构之间的关系	257
        10.8每个变量只有一个用途	258
        第11章　变量名称的威力	263
        11.1选择好名称的注意事项	263
        11.2特定数据类型的命名	269
        11.3命名规范的威力	275
        11.4非正式的命名规范	276
        11.5前缀的标准化	283
        11.6创建可读的短名称	286
        11.7变量名称避坑指南	289
        第12章　基本数据类型	295
        12.1一般的数字	296
        12.2整型	297
        12.3浮点型	299
        12.4字符和字符串	302
        12.5布尔变量	305
        12.6枚举类型	307
        12.7具名常量	312
        12.8数组	314
        12.9创建自定义类型(类型别名)	316
        第13章　不常见的数据类型	323
        13.1结构体	323
        13.2指针	327
        13.3全局数据	340
        第Ⅳ部分语句
        第14章　直线型代码的组织	353
        14.1顺序攸关的语句	353
        14.2顺序无关的语句	356
        第15章　使用条件语句	361
        15.1if语句	361
        15.2case语句	367
        第16章　控制循环	373
        16.1选择循环类型	373
        16.2控制循环	379
        16.3轻松创建循环：由内而外 	391
        16.4循环和数组的对应关系	393
        第17章　不常见的控制结构	395
        17.1子程序中的多个返回点	395
        17.2递归	397
        17.3goto语句	402
        17.4众说纷纭，谈谈不常见的控制结构	413
        第18章　表驱动法	417
        18.1表驱动法使用总则	417
        18.2直接访问表	419
        18.3索引访问表	431
        18.4阶梯访问表	433
        18.5表查询的其他示例	436
        第19章　常规控制问题	437
        19.1布尔表达式	437
        19.2复合语句(语句块)	448
        19.3空语句	449
        19.4驾驭深层嵌套	451
        19.5编程基础：结构化编程	460
        19.6控制结构与复杂度	462
        第Ⅴ部分代码改进
        第20章　软件质量概述	469
        20.1软件质量的特性	469
        20.2改进软件质量的技术	472
        20.3质量保证技术的相对效能	475
        20.4何时进行质量保证	479
        20.5软件质量的普遍原理	479
        第21章　协同构建	483
        21.1协同开发实践概述	484
        21.2结对编程	487
        21.3正式审查	489
        21.4其他类型的协同开发实践	496
        第22章　开发人员测试	503
        22.1开发者测试
        对软件质量所起的作用	504
        22.2开发人员测试的推荐方法	507
        22.3一些测试技巧	509
        22.4典型错误 	522
        22.5测试支持工具	528
        22.6改进测试	534
        22.7维护测试记录 	535
        第23章　调试	541
        23.1调试问题概述	541
        23.2发现缺陷	546
        23.3修复缺陷	557
        23.4调试中的心理因素	560
        23.5那些显而易见和
        不太明显的调试工具	563
        第24章　重构	569
        24.1软件演变的类型	570
        24.2重构简介	571
        24.3特定的重构	577
        24.4安全重构	585
        24.5重构策略	587
        第25章　代码调优策略	591
        25.1性能概述	592
        25.2代码调优简介	595
        25.3各式各样的臃肿和蜜糖	601
        25.4度量	607
        25.5迭代	608
        25.6代码调优方法总结	609
        第26章　代码调优技术	613
        26.1逻辑	614
        26.2循环	619
        26.3数据变换	628
        26.4表达式	633
        26.5子程序	642
        26.6用低级语言重新编码	643
        26.7改得越多，越不会有大的改观	646
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响	651
        27.1沟通和规模	651
        27.2项目规模的范围	652
        27.3项目规模对错误的影响	653
        27.4项目规模对生产力的影响	655
        27.5项目规模对开发活动的影响	656
        第28章　管理构建	663
        28.1鼓励良好的编码实践	664
        28.2配置管理	666
        28.3评估构建进度表	673
        28.4度量	679
        28.5以人为本，善待每一位程序员	683
        28.6向上管理	689
        第29章　集成	693
        29.1集成方法的重要性	693
        29.2集成的频率，阶段式还是增量式	695
        29.3增量式集成策略	698
        29.4每日构建和冒烟测试	707
        第30章　编程工具	715
        30.1设计工具	716
        30.2源代码工具	716
        30.3可执行码工具	721
        30.4面向工具的环境	726
        30.5自己动手写编程工具	726
        30.6工具的幻境	728
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格	733
        31.1基本理论	734
        31.2布局技术	741
        31.3布局风格	743
        31.4控制结构的布局	750
        31.5单条语句的布局	757
        31.6注释的布局	768
        31.7子程序的布局	771
        31.8类的布局	772
        第32章　自文档代码	781
        32.1外部文档	781
        32.2编程风格即文档	782
        32.3注释，还是不注释	785
        32.4高效注释的关键	788
        32.5注释的技术	795
        32.6IEEE标准	815
        第33章　个人性格	821
        33.1个人性格与本书主题有关	822
        33.2聪明与谦卑	823
        33.3好奇心	824
        33.4理性诚实	827
        33.5沟通与合作	830
        33.6创造力与规范	830
        33.7懒惰	831
        33.8没有想象中那么重要的性格因素	832
        33.9习惯	833
        第34章　关于软件匠艺	837
        34.1征服复杂性	837
        34.2优选开发过程	839
        34.3编写程序时，先考虑人，
        再考虑机器	840
        34.4深入语言去编程，
        而不是用语言来编程	842
        34.5借助于规范来保持专注	843
        34.6面向问题域编程	844
        34.7 当心落石	846
        34.8迭代，迭代，迭代，
        重要的事情说三遍	848
        34.9警惕编程中的执念	849
        试验	851
        第35章　更多信息来源	853
        35.1与软件构建相关的信息	853
        35.2软件构建之外的话题	854
        35.3出版物	856
        35.4软件开发者的阅读计划	857
        35.5加入专业组织	859
        参考文献	861
     · · · · · ·     (收起)"
35520512,深入浅出Pandas,8.6,(97人评价),李庆辉 / 机械工业出版社 / 2021-7-10 / 99.00,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。
这是一本全面覆盖了Pandas使用者的普遍需求和...",https://book.douban.com/subject/35520512/,https://img9.doubanio.com/view/subject/s/public/s33944495.jpg,99.00,9787111685456,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 ...(展开全部)





如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 第三部分（第6～9章） 数据形式变化 讲解了Pandas的分组聚合操作、合并操作、对比操作、数据透视、转置、归一化、标准化等，以及如何利用多层索引对数据进行升降维。 第四部分（第10～12章） 数据清洗 讲解了缺失值和重复值的识别、删除、填充，数据的替换、格式转换，文本的提取、连接、匹配、切分、替换、格式化、虚拟变量化等，以及分类数据的应用场景和操作方法。 第五部分（第13～14章）时序数据分析 讲解了Pandas中对于各种时间类型数据的处理和分析，以及在时序数据处理中经常使用的窗口计算。 第六部分（第15～16章） 可视化 讲解了Pandas的样式功能如何让数据表格更有表现力，以及Pandas的绘图功能如何让数据自己说话。 第七部分（第17章） 实战案例 介绍了从需求到代码的思考过程，如何利用链式编程思想提高代码编写和数据分析效率，以及数据分析的基本方法与需要掌握的数据分析工具和技术栈，此外还从数据处理和数据分析两个角度给出了大量的应用案例及代码详解。",李庆辉，数据产品专家，某电商公司数据产品团队负责人，擅长通过数据治理、数据分析、数据化运营提升公司的数据应用水平。 精通 Python 数据科学及 Python Web 开发，曾独立开发公司的自动化数据分析平台，参与教育部“1+X”数据分析（Python）职业技能等级标准评审。 中国人工智能学会会员，企业数字化、数据产品和数据分析讲师，在个人网站“盖若”上编写的技术和产品教程广受欢迎。,"前言
        第一部分 Pandas入门
        第1章 Pandas简介及快速入门2
        1.1 Pandas是什么2
        1.1.1 Python简介2
        1.1.2 Python的应用3
        1.1.3 为什么不选择R4
        1.1.4 Pandas简介4
        1.1.5 Pandas的使用人群5
        1.1.6 Pandas的基本功能5
        1.1.7 Pandas的学习方法6
        1.1.8 小结6
        1.2 环境搭建及安装6
        1.2.1 Python环境安装7
        1.2.2 Anaconda简介7
        1.2.3 安装miniconda8
        1.2.4 多Python版本环境9
        1.2.5 安装编辑器10
        1.2.6 Jupyter Notebook10
        1.2.7 用pip安装三方库11
        1.2.8 安装Jupyter Notebook12
        1.2.9 启动Jupyter Notebook12
        1.2.10 使用Jupyter Notebook13
        1.2.11 安装Pandas14
        1.2.12 小结14
        1.3 Pandas快速入门14
        1.3.1 安装导入14
        1.3.2 准备数据集15
        1.3.3 读取数据15
        1.3.4 查看数据16
        1.3.5 验证数据17
        1.3.6 建立索引17
        1.3.7 数据选取18
        1.3.8 排序19
        1.3.9 分组聚合19
        1.3.10 数据转换20
        1.3.11 增加列21
        1.3.12 统计分析21
        1.3.13 绘图21
        1.3.14 导出24
        1.3.15 小结24
        1.4 本章小结24
        第2章 数据结构25
        2.1 数据结构概述25
        2.1.1 什么是数据25
        2.1.2 什么是数据结构26
        2.1.3 小结26
        2.2 Python的数据结构26
        2.2.1 数字27
        2.2.2 字符串27
        2.2.3 布尔型28
        2.2.4 列表29
        2.2.5 元组30
        2.2.6 字典30
        2.2.7 集合31
        2.2.8 小结32
        2.3 NumPy32
        2.3.1 NumPy简介33
        2.3.2 数据结构33
        2.3.3 创建数据34
        2.3.4 数据类型34
        2.3.5 数组信息35
        2.3.6 统计计算35
        2.3.7 小结35
        2.4 Pandas的数据结构35
        2.4.1 Series36
        2.4.2 DataFrame36
        2.4.3 索引37
        2.4.4 小结38
        2.5 Pandas生成数据38
        2.5.1 导入Pandas38
        2.5.2 创建数据38
        2.5.3 生成Series40
        2.5.4 生成DataFrame41
        2.5.5 小结43
        2.6 Pandas的数据类型43
        2.6.1 数据类型查看43
        2.6.2 常见数据类型44
        2.6.3 数据检测44
        2.6.4 小结45
        2.7 本章小结45
        第二部分 Pandas数据分析基础
        第3章 Pandas数据读取与输出48
        3.1 数据读取48
        3.1.1 CSV文件49
        3.1.2 Excel49
        3.1.3 JSON 50
        3.1.4 HTML50
        3.1.5 剪贴板51
        3.1.6 SQL51
        3.1.7 小结52
        3.2 读取CSV52
        3.2.1 语法52
        3.2.2 数据内容53
        3.2.3 分隔符53
        3.2.4 表头54
        3.2.5 列名54
        3.2.6 索引54
        3.2.7 使用部分列54
        3.2.8 返回序列55
        3.2.9 表头前缀55
        3.2.10 处理重复列名55
        3.2.11 数据类型55
        3.2.12 引擎55
        3.2.13 列数据处理56
        3.2.14 真假值转换56
        3.2.15 跳过指定行56
        3.2.16 读取指定行57
        3.2.17 空值替换57
        3.2.18 保留默认空值57
        3.2.19 日期时间解析58
        3.2.20 文件处理59
        3.2.21 符号60
        3.2.22 小结61
        3.3 读取Excel61
        3.3.1 语法61
        3.3.2 文件内容62
        3.3.3 表格62
        3.3.4 表头62
        3.3.5 列名62
        3.3.6 其他62
        3.3.7 小结63
        3.4 数据输出63
        3.4.1 CSV63
        3.4.2 Excel63
        3.4.3 HTML64
        3.4.4 数据库（SQL）64
        3.4.5 Markdown65
        3.4.6 小结65
        3.5 本章小结65
        第4章 Pandas基础操作66
        4.1 索引操作66
        4.1.1 认识索引66
        4.1.2 建立索引67
        4.1.3 重置索引68
        4.1.4 索引类型68
        4.1.5 索引对象69
        4.1.6 索引的属性70
        4.1.7 索引的操作70
        4.1.8 索引重命名72
        4.1.9 修改索引内容72
        4.1.10 小结73
        4.2 数据的信息73
        4.2.1 查看样本73
        4.2.2 数据形状74
        4.2.3 基础信息74
        4.2.4 数据类型74
        4.2.5 行列索引内容75
        4.2.6 其他信息75
        4.2.7 小结75
        4.3 统计计算76
        4.3.1 描述统计76
        4.3.2 数学统计77
        4.3.3 统计函数78
        4.3.4 非统计计算79
        4.3.5 小结80
        4.4 位置计算80
        4.4.1 位置差值diff()80
        4.4.2 位置移动shift()81
        4.4.3 位置序号rank()81
        4.4.4 小结82
        4.5 数据选择82
        4.5.1 选择列83
        4.5.2 切片[]83
        4.5.3 按轴标签.loc84
        4.5.4 按数字索引.iloc86
        4.5.5 取具体值.at/.iat86
        4.5.6 获取数据.get86
        4.5.7 数据截取.truncate87
        4.5.8 索引选择器87
        4.5.9 小结87
        4.6 本章小结88
        第5章 Pandas高级操作89
        5.1 复杂查询89
        5.1.1 逻辑运算89
        5.1.2 逻辑筛选数据91
        5.1.3 函数筛选92
        5.1.4 比较函数92
        5.1.5 查询df.query()93
        5.1.6 筛选df.filter()93
        5.1.7 按数据类型查询93
        5.1.8 小结94
        5.2 数据类型转换94
        5.2.1 推断类型94
        5.2.2 指定类型95
        5.2.3 类型转换astype()95
        5.2.4 转为时间类型96
        5.2.5 小结96
        5.3 数据排序96
        5.3.1 索引排序97
        5.3.2 数值排序98
        5.3.3 混合排序100
        5.3.4 按值大小排序101
        5.3.5 小结101
        5.4 添加修改101
        5.4.1 修改数值101
        5.4.2 替换数据103
        5.4.3 填充空值103
        5.4.4 修改索引名104
        5.4.5 增加列104
        5.4.6 插入列df.insert()105
        5.4.7 指定列df.assign()106
        5.4.8 执行表达式df.eval()108
        5.4.9 增加行109
        5.4.10 追加合并109
        5.4.11 删除110
        5.4.12 删除空值111
        5.4.13 小结111
        5.5 高级过滤111
        5.5.1 df.where()111
        5.5.2 np.where()113
        5.5.3 df.mask()115
        5.5.4 df.lookup()116
        5.5.5 小结116
        5.6 数据迭代116
        5.6.1 迭代Series116
        5.6.2 df.iterrows()117
        5.6.3 df.itertuples()117
        5.6.4 df.items()118
        5.6.5 按列迭代119
        5.6.6 小结119
        5.7 函数应用120
        5.7.1 pipe()120
        5.7.2 apply()121
        5.7.3 applymap()123
        5.7.4 map()124
        5.7.5 agg()124
        5.7.6 transform()125
        5.7.7 copy()126
        5.7.8 小结126
        5.8 本章小结126
        第三部分 数据形式变化
        第6章 Pandas分组聚合128
        6.1 概述128
        6.1.1 原理128
        6.1.2 groupby语法129
        6.1.3 DataFrame应用分组130
        6.1.4 Series应用分组131
        6.1.5 小结131
        6.2 分组131
        6.2.1 分组对象131
        6.2.2 按标签分组132
        6.2.3 表达式132
        6.2.4 函数分组133
        6.2.5 多种方法混合134
        6.2.6 用pipe调用分组方法134
        6.2.7 分组器Grouper135
        6.2.8 索引136
        6.2.9 排序136
        6.2.10 小结136
        6.3 分组对象的操作136
        6.3.1 选择分组137
        6.3.2 迭代分组138
        6.3.3 选择列139
        6.3.4 应用函数apply()139
        6.3.5 管道方法pipe()142
        6.3.6 转换方法transform()142
        6.3.7 筛选方法filter()144
        6.3.8 其他功能145
        6.3.9 小结146
        6.4 聚合统计146
        6.4.1 描述统计146
        6.4.2 统计函数147
        6.4.3 聚合方法agg()147
        6.4.4 时序重采样方法resample()149
        6.4.5 组内头尾值150
        6.4.6 组内分位数150
        6.4.7 组内差值151
        6.4.8 小结151
        6.5 数据分箱151
        6.5.1 定界分箱pd.cut()152
        6.5.2 等宽分箱pd.qcut()152
        6.5.3 小结154
        6.6 分组可视化154
        6.6.1 绘图方法plot()154
        6.6.2 直方图hist()155
        6.6.3 箱线图boxplot()156
        6.6.4 小结157
        6.7 本章小结158
        第7章 Pandas数据合并与对比159
        7.1 数据追加df.append159
        7.1.1 基本语法159
        7.1.2 相同结构160
        7.1.3 不同结构161
        7.1.4 忽略索引161
        7.1.5 重复内容162
        7.1.6 追加序列162
        7.1.7 追加字典163
        7.1.8 小结163
        7.2 数据连接pd.concat163
        7.2.1 基本语法163
        7.2.2 简单连接164
        7.2.3 按列连接164
        7.2.4 合并交集165
        7.2.5 与序列合并165
        7.2.6 指定索引166
        7.2.7 多文件合并166
        7.2.8 目录文件合并167
        7.2.9 小结167
        7.3 数据合并pd.merge167
        7.3.1 基本语法168
        7.3.2 连接键168
        7.3.3 索引连接169
        7.3.4 多连接键169
        7.3.5 连接方法170
        7.3.6 连接指示170
        7.3.7 小结171
        7.4 按元素合并171
        7.4.1 df.combine_first()171
        7.4.2 df.combine()172
        7.4.3 df.update()173
        7.4.4 小结173
        7.5 数据对比df.compare173
        7.5.1 简单对比174
        7.5.2 对齐方式174
        7.5.3 显示相同值174
        7.5.4 保持形状175
        7.5.5 小结175
        7.6 本章小结175
        第8章 Pandas多层索引177
        8.1 概述177
        8.1.1 什么是多层索引177
        8.1.2 通过分组产生多层索引178
        8.1.3 由序列创建多层索引179
        8.1.4 由元组创建多层索引179
        8.1.5 可迭代对象的笛卡儿积180
        8.1.6 将DataFrame转为多层索引对象180
        8.1.7 小结180
        8.2 多层索引操作181
        8.2.1 生成数据181
        8.2.2 索引信息181
        8.2.3 查看层级182
        8.2.4 索引内容182
        8.2.5 排序183
        8.2.6 其他操作183
        8.2.7 小结183
        8.3 数据查询183
        8.3.1 查询行183
        8.3.2 查询列184
        8.3.3 行列查询185
        8.3.4 条件查询185
        8.3.5 用pd.IndexSlice索引数据186
        8.3.6 df.xs()186
        8.3.7 小结186
        8.4 本章小结186
        第9章 Pandas数据重塑与透视187
        9.1 数据透视187
        9.1.1 整理透视187
        9.1.2 整理透视操作188
        9.1.3 聚合透视189
        9.1.4 聚合透视操作190
        9.1.5 聚合透视高级操作191
        9.1.6 小结192
        9.2 数据堆叠192
        9.2.1 理解堆叠193
        9.2.2 堆叠操作df.stack()194
        9.2.3 解堆操作df.unstack()195
        9.2.4 小结195
        9.3 交叉表195
        9.3.1 基本语法196
        9.3.2 生成交叉表196
        9.3.3 归一化197
        9.3.4 指定聚合方法198
        9.3.5 汇总198
        9.3.6 小结199
        9.4 数据转置df.T199
        9.4.1 理解转置199
        9.4.2 转置操作200
        9.4.3 类型变化200
        9.4.4 轴交换df.swapaxes()201
        9.4.5 小结201
        9.5 数据融合201
        9.5.1 基本语法201
        9.5.2 融合操作202
        9.5.3 标识和值203
        9.5.4 指定名称204
        9.5.5 小结204
        9.6 虚拟变量204
        9.6.1 语法结构204
        9.6.2 生成虚拟变量205
        9.6.3 列前缀205
        9.6.4 从DataFrame生成206
        9.6.5 小结207
        9.7 因子化207
        9.7.1 基本方法207
        9.7.2 排序208
        9.7.3 缺失值208
        9.7.4 枚举类型208
        9.7.5 小结208
        9.8 爆炸列表208
        9.8.1 基本功能209
        9.8.2 DataFrame的爆炸209
        9.8.3 非列表格式210
        9.8.4 小结210
        9.9 本章小结210
        第四部分 数据清洗
        第10章 Pandas数据清洗212
        10.1 缺失值的认定212
        10.1.1 缺失值类型212
        10.1.2 缺失值判断213
        10.1.3 缺失值统计214
        10.1.4 缺失值筛选214
        10.1.5 NA标量215
        10.1.6 时间数据中的缺失值216
        10.1.7 整型数据中的缺失值216
        10.1.8 插入缺失值217
        10.1.9 小结217
        10.2 缺失值的操作217
        10.2.1 缺失值填充217
        10.2.2 插值填充219
        10.2.3 缺失值删除220
        10.2.4 缺失值参与计算221
        10.2.5 小结223
        10.3 数据替换223
        10.3.1 指定值替换223
        10.3.2 使用替换方式223
        10.3.3 字符替换223
        10.3.4 缺失值替换224
        10.3.5 数字替换224
        10.3.6 数据修剪225
        10.3.7 小结226
        10.4 重复值及删除数据226
        10.4.1 重复值识别226
        10.4.2 删除重复值228
        10.4.3 删除数据229
        10.4.4 小结229
        10.5 NumPy格式转换230
        10.5.1 转换方法230
        10.5.2 DataFrame转为ndarray230
        10.5.3 Series转为ndarray231
        10.5.4 df.to_records()231
        10.5.5 np.array读取231
        10.5.6 小结232
        10.6 本章小结232
        第11章 Pandas文本处理233
        11.1 数据类型233
        11.1.1 文本数据类型233
        11.1.2 类型转换234
        11.1.3 类型异同234
        11.1.4 小结235
        11.2 字符的操作235
        11.2.1 .str访问器235
        11.2.2 文本格式236
        11.2.3 文本对齐236
        11.2.4 计数和编码236
        11.2.5 格式判定237
        11.2.6 小结237
        11.3 文本高级处理237
        11.3.1 文本分隔237
        11.3.2 字符分隔展开238
        11.3.3 文本切片选择239
        11.3.4 文本划分240
        11.3.5 文本替换241
        11.3.6 指定替换241
        11.3.7 重复替换242
        11.3.8 文本连接243
        11.3.9 文本查询244
        11.3.10 文本包含245
        11.3.11 文本提取246
        11.3.12 提取虚拟变量247
        11.3.13 小结248
        11.4 本章小结248
        第12章 Pandas分类数据249
        12.1 分类数据249
        12.1.1 创建分类数据249
        12.1.2 pd.Categorical()251
        12.1.3 CategoricalDtype对象251
        12.1.4 类型转换252
        12.1.5 小结253
        12.2 分类的操作253
        12.2.1 修改分类253
        12.2.2 追加新分类254
        12.2.3 删除分类254
        12.2.4 顺序255
        12.2.5 小结256
        12.3 本章小结256
        第五部分 时序数据分析
        第13章 Pandas窗口计算258
        13.1 窗口计算258
        13.1.1 理解窗口计算258
        13.1.2 移动窗口259
        13.1.3 扩展窗口259
        13.1.4 指数加权移动260
        13.1.5 小结260
        13.2 窗口操作260
        13.2.1 计算方法260
        13.2.2 基本语法261
        13.2.3 移动窗口使用262
        13.2.4 统计方法263
        13.2.5 agg()264
        13.2.6 apply()264
        13.2.7 扩展窗口265
        13.2.8 小结266
        13.3 本章小结266
        第14章 Pandas时序数据267
        14.1 固定时间267
        14.1.1 时间的表示267
        14.1.2 创建时间点268
        14.1.3 时间的属性269
        14.1.4 时间的方法270
        14.1.5 时间缺失值271
        14.1.6 小结272
        14.2 时长数据272
        14.2.1 创建时间差272
        14.2.2 时长的加减274
        14.2.3 时长的属性275
        14.2.4 时长索引275
        14.2.5 小结275
        14.3 时间序列275
        14.3.1 时序索引275
        14.3.2 创建时序数据276
        14.3.3 数据访问277
        14.3.4 类型转换279
        14.3.5 按格式转换281
        14.3.6 时间访问器.dt282
        14.3.7 时长数据访问器284
        14.3.8 时序数据移动284
        14.3.9 频率转换285
        14.3.10 小结286
        14.4 时间偏移286
        14.4.1 DateOffset对象286
        14.4.2 偏移别名287
        14.4.3 移动偏移289
        14.4.4 应用偏移289
        14.4.5 偏移参数290
        14.4.6 相关查询290
        14.4.7 与时序的计算291
        14.4.8 锚定偏移292
        14.4.9 自定义工作时间294
        14.4.10 小结296
        14.5 时间段297
        14.5.1 Period对象297
        14.5.2 属性方法297
        14.5.3 时间段的计算298
        14.5.4 时间段索引299
        14.5.5 数据查询300
        14.5.6 相关类型转换301
        14.5.7 小结302
        14.6 时间操作302
        14.6.1 时区转换302
        14.6.2 时间的格式化303
        14.6.3 时间重采样304
        14.6.4 上采样306
        14.6.5 重采样聚合307
        14.6.6 时间类型间转换307
        14.6.7 超出时间戳范围时间308
        14.6.8 区间间隔309
        14.6.9 小结311
        14.7 本章小结312
        第六部分 可视化
        第15章 Pandas样式314
        15.1 内置样式314
        15.1.1 样式功能314
        15.1.2 Styler对象315
        15.1.3 空值高亮315
        15.1.4 极值高亮316
        15.1.5 背景渐变317
        15.1.6 条形图318
        15.1.7 小结320
        15.2 显示格式320
        15.2.1 语法结构320
        15.2.2 常用方法320
        15.2.3 综合运用321
        15.2.4 小结321
        15.3 样式高级操作322
        15.3.1 样式配置操作322
        15.3.2 表格CSS样式323
        15.3.3 应用函数324
        15.3.4 样式复用325
        15.3.5 样式清除325
        15.3.6 导出Excel326
        15.3.7 生成HTML326
        15.3.8 小结327
        15.4 本章小结327
        第16章 Pandas可视化328
        16.1 plot()方法328
        16.1.1 plot()概述328
        16.1.2 plot()基础方法329
        16.1.3 图形类型331
        16.1.4 x轴和y轴331
        16.1.5 图形标题332
        16.1.6 字体大小332
        16.1.7 线条样式333
        16.1.8 背景辅助线334
        16.1.9 图例334
        16.1.10 图形大小334
        16.1.11 色系335
        16.1.12 绘图引擎336
        16.1.13 Matplotlib的其他参数337
        16.1.14 图形叠加337
        16.1.15 颜色的表示337
        16.1.16 解决图形中的中文乱码问题338
        16.1.17 小结340
        16.2 常用可视化图形340
        16.2.1 折线图plot.line340
        16.2.2 饼图plot.pie342
        16.2.3 柱状图plot.bar345
        16.2.4 直方图plot.hist348
        16.2.5 箱形图plot.box351
        16.2.6 面积图plot.area353
        16.2.7 散点图plot.scatter354
        16.2.8 六边形分箱图plot.hexbin356
        16.2.9 小结357
        16.3 本章小结357
        第七部分 实战案例
        第17章 Pandas实战案例360
        17.1 实战思想360
        17.1.1 链式方法360
        17.1.2 代码思路362
        17.1.3 分析方法366
        17.1.4 分析流程368
        17.1.5 分析工具368
        17.1.6 小结369
        17.2 数据处理案例370
        17.2.1 剧组表格道具370
        17.2.2 当月最后一个星期三371
        17.2.3 同组数据转为同一行372
        17.2.4 相关性最强的两个变量373
        17.2.5 全表最大值的位置375
        17.2.6 编写年会抽奖程序376
        17.2.7 北京各区无新增新冠肺炎确诊病例天数377
        17.2.8 生成SQL378
        17.2.9 圣诞节的星期分布379
        17.2.10 试验三天中恰有两天下雨的概率381
        17.2.11 计算平均打卡上班时间382
        17.2.12 小结383
        17.3 综合案例383
        17.3.1 中国经济发展分析383
        17.3.2 新冠肺炎疫情分析387
        17.3.3 利用爬虫获取房价390
        17.3.4 全国城市房价分析392
        17.3.5 客服对话文本分析396
        17.3.6 RFM用户分层399
        17.3.7 自动邮件报表404
        17.3.8 鸢尾花品种预测407
        17.3.9 小结410
        17.4 本章小结410
     · · · · · ·     (收起)"
35768338,Vue.js设计与实现,9.6,(197人评价),霍春阳 / 人民邮电出版社 / 2022-2-10 / 119.8,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章...,https://book.douban.com/subject/35768338/,https://img9.doubanio.com/view/subject/s/public/s34120804.jpg,119.8,9787115583864,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章，分为六篇，主要内容包括：框架设计概览、响应系统、渲染器、组件化、编译器和服务端渲染等。通过阅读本书，对Vue.js 2/3具有上手经验的开发人员能够进一步理解Vue.js框架的实现细节，没有Vue.js使用经验但对框架设计感兴趣的前端开发人员，能够快速掌握Vue.js的设计原理。,霍春阳（HcySunYang） Vue.js官方团队成员，专注于Web研发领域，是Vue.js 3的核心贡献者之一，Vue.js文档生成工具Vuese的作者，技术社区活跃者，曾撰写大量颇受好评的技术博客。,"序
        前言
        第　1章 权衡的艺术　2
        1．1　命令式和声明式　2
        1．2　性能与可维护性的权衡　3
        1．3　虚拟DOM的性能到底如何　4
        1．4　运行时和编译时　8
        1．5　总结　11
        第　2章 框架设计的核心要素　12
        2．1　提升用户的开发体验　12
        2．2　控制框架代码的体积　14
        2．3　框架要做到良好的Tree-Shaking　15
        2．4　框架应该输出怎样的构建产物　17
        2．5　特性开关　19
        2．6　错误处理　21
        2．7　良好的TypeScript类型支持　23
        2．8　总结　25
        第3章　Vue．js 3的设计思路　27
        3．1　声明式地描述UI　27
        3．2　初识渲染器　29
        3．3　组件的本质　32
        3．4　模板的工作原理　34
        3．5　Vue．js是各个模块组成的有机整体　36
        3．6　总结　37
        第4章　响应系统的作用与实现　40
        4．1　响应式数据与副作用函数　40
        4．2　响应式数据的基本实现　41
        4．3　设计一个完善的响应系统　43
        4．4　分支切换与cleanup　50
        4．5　嵌套的effect与effect栈　55
        4．6　避免无限递归循环　59
        4．7　调度执行　60
        4．8　计算属性computed与lazy　64
        4．9　watch的实现原理　71
        4．10　立即执行的watch与回调执行时机　75
        4．11　过期的副作用　77
        4．12　总结　82
        第5章　非原始值的响应式方案　84
        5．1　理解Proxy和Reflect　84
        5．2　JavaScript对象及Proxy的工作原理　88
        5．3　如何代理Object　92
        5．4　合理地触发响应　102
        5．5　浅响应与深响应　108
        5．6　只读和浅只读　110
        5．7　代理数组　113
        5．7．1　数组的索引与 length　114
        5．7．2　遍历数组　119
        5．7．3　数组的查找方法　124
        5．7．4　隐式修改数组长度的原型方法　129
        5．8　代理Set和Map　132
        5．8．1　如何代理Set和Map　133
        5．8．2　建立响应联系　137
        5．8．3　避免污染原始数据　140
        5．8．4　处理forEach　143
        5．8．5　迭代器方法　147
        5．8．6　values与keys方法　152
        5．9　总结　155
        第6章　原始值的响应式方案　158
        6．1　引入ref的概念　158
        6．2　响应丢失问题　160
        6．3　自动脱ref　164
        6．4　总结　166
        第7章　渲染器的设计　170
        7．1　渲染器与响应系统的结合　170
        7．2　渲染器的基本概念　172
        7．3　自定义渲染器　175
        7．4　总结　179
        第8章　挂载与更新　180
        8．1　挂载子节点和元素的属性　180
        8．2　HTML Attributes与DOM Properties　182
        8．3　正确地设置元素属性　184
        8．4　class的处理　189
        8．5　卸载操作　192
        8．6　区分vnode的类型　195
        8．7　事件的处理　196
        8．8　事件冒泡与更新时机问题　201
        8．9　更新子节点　204
        8．10　文本节点和注释节点　209
        8．11　Fragment　212
        8．12　总结　215
        第9章　简单Diff算法　218
        9．1　减少DOM操作的性能开销　218
        9．2　DOM复用与key的作用　221
        9．3　找到需要移动的元素　225
        9．4　如何移动元素　228
        9．5　添加新元素　233
        9．6　移除不存在的元素　238
        9．7　总结　241
        第　10章 双端Diff算法　242
        10．1　双端比较的原理　242
        10．2　双端比较的优势　252
        10．3　非理想状况的处理方式　255
        10．4　添加新元素　263
        10．5　移除不存在的元素　268
        10．6　总结　270
        第　11章 快速Diff算法　271
        11．1　相同的前置元素和后置元素　271
        11．2　判断是否需要进行DOM移动操作　279
        11．3　如何移动元素　288
        11．4　总结　296
        第　12章 组件的实现原理　298
        12．1　渲染组件　298
        12．2　组件状态与自更新　301
        12．3　组件实例与组件的生命周期　304
        12．4　props与组件的被动更新　306
        12．5　setup函数的作用与实现　311
        12．6　组件事件与emit的实现　314
        12．7　插槽的工作原理与实现　316
        12．8　注册生命周期　318
        12．9　总结　320
        第　13章 异步组件与函数式组件　322
        13．1　异步组件要解决的问题　322
        13．2　异步组件的实现原理　324
        13．2．1　封装defineAsyncComponent函数　324
        13．2．2　超时与Error组件　325
        13．2．3　延迟与Loading组件　328
        13．2．4　重试机制　331
        13．3　函数式组件　333
        13．4　总结　335
        第　14章 内建组件和模块　337
        14．1　KeepAlive组件的实现原理　337
        14．1．1　组件的激活与失活　337
        14．1．2　include和exclude　342
        14．1．3　缓存管理　343
        14．2　Teleport组件的实现原理　346
        14．2．1　Teleport组件要解决的问题　346
        14．2．2　实现Teleport组件　347
        14．3　Transition组件的实现原理　350
        14．3．1　原生DOM的过渡　351
        14．3．2　实现Transition组件　356
        14．4　总结　360
        第　15章 编译器核心技术概览　364
        15．1　模板DSL的编译器　364
        15．2　parser的实现原理与状态机　368
        15．3　构造AST　374
        15．4　AST的转换与插件化架构　383
        15．4．1　节点的访问　383
        15．4．2　转换上下文与节点操作　387
        15．4．3　进入与退出　392
        15．5　将模板AST转为JavaScript AST　396
        15．6　代码生成　402
        15．7　总结　407
        第　16章 解析器　409
        16．1　文本模式及其对解析器的影响　409
        16．2　递归下降算法构造模板AST　413
        16．3　状态机的开启与停止　419
        16．4　解析标签节点　426
        16．5　解析属性　430
        16．6　解析文本与解码HTML实体　436
        16．6．1　解析文本　436
        16．6．2　解码命名字符引用　438
        16．6．3　解码数字字符引用　445
        16．7　解析插值与注释　449
        16．8　总结　451
        第　17章 编译优化　453
        17．1　动态节点收集与补丁标志　453
        17．1．1　传统Diff算法的问题　453
        17．1．2　Block与PatchFlags　454
        17．1．3　收集动态节点　457
        17．1．4　渲染器的运行时支持　459
        17．2　Block树　461
        17．2．1　带有v-if指令的节点　462
        17．2．2　带有v-for指令的节点　464
        17．2．3　Fragment的稳定性　465
        17．3　静态提升　466
        17．4　预字符串化　468
        17．5　缓存内联事件处理函数　469
        17．6　v-once　470
        17．7　总结　471
        第　18章 同构渲染　474
        18．1　CSR、SSR以及同构渲染　474
        18．2　将虚拟DOM渲染为HTML字符串　478
        18．3　将组件渲染为HTML字符串　484
        18．4　客户端激活的原理　489
        18．5　编写同构的代码　494
        18．5．1　组件的生命周期　494
        18．5．2　使用跨平台的API　496
        18．5．3　只在某一端引入模块　496
        18．5．4　避免交叉请求引起的状态污染　497
        18．5．5　组件　498
        18．6　总结　499
     · · · · · ·     (收起)"
33450010,动手学深度学习,9.3,(552人评价),阿斯顿·张（Aston Zhang）、李沐（Mu Li）、[美] 扎卡里·C. 立顿（Zachary C. Lipton）、[德] 亚历山大·J. 斯莫拉（Alexander J. Smola） / 人民邮电出版社 / 2019-6 / 85.00元,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的...,https://book.douban.com/subject/33450010/,https://img9.doubanio.com/view/subject/s/public/s32322795.jpg,85.00元,9787115490841,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的 Jupyter记事本，它将文字、公式、图像、代码和运行结果结合在了一起。此外，读者还可以访问并参与书中内容的讨论。 全书的内容分为3个部分：第一部分介绍深度学习的背景，提供预备知识，并包括深度学习最基础的概念和技术；第二部分描述深度学习计算的重要组成部分，还解释近年来令深度学习在多个领域大获成功的卷积神经网络和循环神经网络；第三部分评价优化算法，检验影响深度学习计算性能的重要因素，并分别列举深度学习在计算机视觉和自然语言处理中的重要应用。 本书同时覆盖深度学习的方法和实践，主要面向在校大学生、技术人员和研究人员。阅读本书需要读者了解基本的Python编程或附录中描述的线性代数、微分和概率基础。,"阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、Ne...(展开全部)




阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、NeurIPS、AISTATS、CVPR、KDD 、WSDM、OSDI）上发表过论文。 扎卡里·C. 立顿（Zachary C. Lipton） 亚马逊应用科学家，美国卡内基梅隆大学助理教授，美国加州大学圣迭戈分校博士。他专注于机器学习算法及其社会影响的研究，特别是在时序数据与序列决策上的深度学习。这类工作有着广泛的应用场景，包括医疗诊断、对话系统和产品推荐。他创立了博客“Approximately Correct”（approximatelycorrect.com）。 亚历山大·J. 斯莫拉（Alexander J. Smola） 亚马逊副总裁/ 杰出科学家，德国柏林工业大学计算机科学博士。他曾在澳大利亚国立大学、美国加州大学伯克利分校和卡内基梅隆大学任教。他发表了超过200 篇学术论文，并著有5 本书，其论文及书被引用超过10 万次。他的研究兴趣包括深度学习、贝叶斯非参数、核方法、统计建模和可扩展算法。","对本书的赞誉
        前言
        如何使用本书
        资源与支持
        主要符号表
        第1 章　深度学习简介… ………………… 1
        1.1　起源…………………………………………… 2
        1.2　发展…………………………………………… 4
        1.3　成功案例……………………………………… 6
        1.4　特点………………………………………… 7
        小结…………………………………………… 8
        练习…………………………………………… 8
        第2 章　预备知识… ……………………… 9
        2.1　获取和运行本书的代码……………………… 9
        2.1.1　获取代码并安装运行环境 … ……… 9
        2.1.2　更新代码和运行环境 … …………… 11
        2.1.3　使用GPU版的MXNet … ………… 11
        小结……………………………………………12
        练习……………………………………………12
        2.2　数据操作… ……………………………… 12
        2.2.1　创建NDArray ………………………12
        2.2.2　运算 …………………………………14
        2.2.3　广播机制 ……………………………16
        2.2.4　索引 …………………………………17
        2.2.5　运算的内存开销 ……………………17
        2.2.6　NDArray和NumPy相互变换………18
        小结……………………………………………19
        练习……………………………………………19
        2.3　自动求梯度… …………………………… 19
        2.3.1　简单例子 … …………………………19
        2.3.2　训练模式和预测模式 …………… 20
        2.3.3　对Python控制流求梯度 … …… 20
        小结……………………………………………21
        练习……………………………………………21
        2.4　查阅文档… ……………………………… 21
        2.4.1　查找模块里的所有函数和类 … ……21
        2.4.2　查找特定函数和类的使用 ……… 22
        2.4.3　在MXNet网站上查阅 …………… 23
        小结………………………………………… 24
        练习………………………………………… 24
        第3 章　深度学习基础… ……………… 25
        3.1　线性回归…………………………………… 25
        3.1.1　线性回归的基本要素 … ………… 25
        3.1.2　线性回归的表示方法 … ………… 28
        小结………………………………………… 30
        练习………………………………………… 30
        3.2　线性回归的从零开始实现… …………… 30
        3.2.1　生成数据集 … …………………… 30
        3.2.2　读取数据集 ……………………… 32
        3.2.3　初始化模型参数 ………………… 32
        3.2.4　定义模型 ………………………… 33
        3.2.5　定义损失函数 …………………… 33
        3.2.6　定义优化算法 …………………… 33
        3.2.7　训练模型 ………………………… 33
        小结………………………………………… 34
        练习………………………………………… 34
        3.3　线性回归的简洁实现… ………………… 35
        3.3.1　生成数据集 … …………………… 35
        3.3.2　读取数据集 ……………………… 35
        3.3.3　定义模型 ………………………… 36
        3.3.4　初始化模型参数 ………………… 36
        3.3.5　定义损失函数 …………………… 37
        3.3.6　定义优化算法 …………………… 37
        3.3.7　训练模型 ………………………… 37
        小结………………………………………… 38
        练习………………………………………… 38
        3.4　softmax回归… ………………………… 38
        3.4.1　分类问题 … ……………………… 38
        3.4.2　softmax回归模型… …………… 39
        3.4.3　单样本分类的矢量计算表达式…… 40
        3.4.4　小批量样本分类的矢量计算表达式 …………………………… 40
        3.4.5　交叉熵损失函数 ……………………41
        3.4.6　模型预测及评价 ………………… 42
        小结………………………………………… 42
        练习………………………………………… 42
        3.5　图像分类数据集（Fashion-MNIST）… ……………… 42
        3.5.1　获取数据集 … …………………… 42
        3.5.2　读取小批量 ……………………… 44
        小结………………………………………… 45
        练习………………………………………… 45
        3.6　softmax回归的从零开始实现… ……… 45
        3.6.1　读取数据集 … …………………… 45
        3.6.2　初始化模型参数 ………………… 45
        3.6.3　实现softmax运算 … …………… 46
        3.6.4　定义模型 ………………………… 46
        3.6.5　定义损失函数 …………………… 47
        3.6.6　计算分类准确率 ………………… 47
        3.6.7　训练模型 ………………………… 48
        3.6.8　预测… …………………………… 48
        小结………………………………………… 49
        练习………………………………………… 49
        3.7　softmax回归的简洁实现… …………… 49
        3.7.1　读取数据集 … …………………… 49
        3.7.2　定义和初始化模型 ……………… 50
        3.7.3　softmax和交叉熵损失函数 … … 50
        3.7.4　定义优化算法 …………………… 50
        3.7.5　训练模型 ………………………… 50
        小结………………………………………… 50
        练习………………………………………… 50
        3.8　多层感知机… …………………………… 51
        3.8.1　隐藏层 … ……………………………51
        3.8.2　激活函数 ………………………… 52
        3.8.3　多层感知机 ……………………… 55
        小结………………………………………… 55
        练习………………………………………… 55
        3.9　多层感知机的从零开始实现… ………… 56
        3.9.1　读取数据集 … …………………… 56
        3.9.2　定义模型参数 …………………… 56
        3.9.3　定义激活函数 …………………… 56
        3.9.4　定义模型 ………………………… 56
        3.9.5　定义损失函数 …………………… 57
        3.9.6　训练模型 ………………………… 57
        小结………………………………………… 57
        练习………………………………………… 57
        3.10　多层感知机的简洁实现………………… 57
        3.10.1　定义模型 ………………………… 58
        3.10.2　训练模型 … …………………… 58
        小结………………………………………… 58
        练习………………………………………… 58
        3.11　模型选择、欠拟合和过拟合… ………… 58
        3.11.1　训练误差和泛化误差 …………… 59
        3.11.2　模型选择 ………………………… 59
        3.11.3　欠拟合和过拟合 ………………… 60
        3.11.4　多项式函数拟合实验 ……………61
        小结………………………………………… 65
        练习………………………………………… 65
        3.12　权重衰减………………………………… 65
        3.12.1　方法 ……………………………… 65
        3.12.2　高维线性回归实验 … ………… 66
        3.12.3　从零开始实现 … ……………… 66
        3.12.4　简洁实现 … …………………… 68
        小结………………………………………… 70
        练习………………………………………… 70
        3.13　丢弃法…………………………………… 70
        3.13.1　方法 ……………………………… 70
        3.13.2　从零开始实现 … …………………71
        3.13.3　简洁实现 … …………………… 73
        小结………………………………………… 74
        练习………………………………………… 74
        3.14　正向传播、反向传播和计算图………… 74
        3.14.1　正向传播 ……………………… 74
        3.14.2　正向传播的计算图 … ………… 75
        3.14.3　反向传播 … …………………… 75
        3.14.4　训练深度学习模型 … ………… 76
        小结………………………………………… 77
        练习………………………………………… 77
        3.15　数值稳定性和模型初始化……………… 77
        3.15.1　衰减和爆炸 ……………………… 77
        3.15.2　随机初始化模型参数 … ……… 78
        小结………………………………………… 78
        练习………………………………………… 79
        3.16　实战Kaggle比赛：房价预测… ……… 79
        3.16.1　Kaggle比赛 … ………………… 79
        3.16.2　读取数据集 … ………………… 80
        3.16.3　预处理数据集 … …………………81
        3.16.4　训练模型 … …………………… 82
        3.16.5　k 折交叉验证 …………………… 82
        3.16.6　模型选择 … …………………… 83
        3.16.7　预测并在Kaggle提交结果… … 84
        小结………………………………………… 85
        练习………………………………………… 85
        第4 章　深度学习计算… ……………… 86
        4.1　模型构造………………………………… 86
        4.1.1　继承Block类来构造模型 … …… 86
        4.1.2　Sequential类继承自Block类…………………………… 87
        4.1.3　构造复杂的模型… ……………… 88
        小结………………………………………… 89
        练习………………………………………… 90
        4.2　模型参数的访问、初始化和共享… …… 90
        4.2.1　访问模型参数 … ………………… 90
        4.2.2　初始化模型参数 ………………… 92
        4.2.3　自定义初始化方法 ……………… 93
        4.2.4　共享模型参数 …………………… 94
        小结………………………………………… 94
        练习………………………………………… 94
        4.3　模型参数的延后初始化… ……………… 95
        4.3.1　延后初始化 … …………………… 95
        4.3.2　避免延后初始化 ………………… 96
        小结………………………………………… 96
        练习………………………………………… 97
        4.4　自定义层… ……………………………… 97
        4.4.1　不含模型参数的自定义层 … …… 97
        4.4.2　含模型参数的自定义层 ………… 98
        小结………………………………………… 99
        练习………………………………………… 99
        4.5　读取和存储… …………………………… 99
        4.5.1　读写NDArray… ………………… 99
        4.5.2　读写Gluon模型的参数… ……… 100
        小结………………………………………… 101
        练习………………………………………… 101
        4.6　GPU计算………………………………… 101
        4.6.1　计算设备 … ……………………… 102
        4.6.2　NDArray的GPU计算…………… 102
        4.6.3　Gluon的GPU计算 ……………… 104
        小结………………………………………… 105
        练习………………………………………… 105
        第5 章　卷积神经网络… ……………… 106
        5.1　二维卷积层………………………………… 106
        5.1.1　二维互相关运算 … ……………… 106
        5.1.2　二维卷积层 … …………………… 107
        5.1.3　图像中物体边缘检测 … ………… 108
        5.1.4　通过数据学习核数组 … ………… 109
        5.1.5　互相关运算和卷积运算 … ……… 109
        5.1.6　特征图和感受野… ……………… 110
        小结………………………………………… 110
        练习………………………………………… 110
        5.2　填充和步幅… …………………………… 111
        5.2.1　填充 … …………………………… 111
        5.2.2　步幅 ……………………………… 112
        小结………………………………………… 113
        练习………………………………………… 113
        5.3　多输入通道和多输出通道… …………… 114
        5.3.1　多输入通道 … …………………… 114
        5.3.2　多输出通道… …………………… 115
        5.3.3　1×1卷积层 ……………………… 116
        小结………………………………………… 117
        练习………………………………………… 117
        5.4　池化层… ………………………………… 117
        5.4.1　二维最大池化层和平均池化层 … ………………………… 117
        5.4.2　填充和步幅 ……………………… 119
        5.4.3　多通道 …………………………… 120
        小结………………………………………… 120
        练习………………………………………… 121
        5.5　卷积神经网络（LeNet）… …………… 121
        5.5.1　LeNet模型 … …………………… 121
        5.5.2　训练模型… ……………………… 122
        小结………………………………………… 124
        练习………………………………………… 124
        5.6　深度卷积神经网络（AlexNet）… …… 124
        5.6.1　学习特征表示 … ………………… 125
        5.6.2　AlexNet… ……………………… 126
        5.6.3　读取数据集 ……………………… 127
        5.6.4　训练模型 ………………………… 128
        小结………………………………………… 128
        练习………………………………………… 129
        5.7　使用重复元素的网络（VGG）………… 129
        5.7.1　VGG块 …………………………… 129
        5.7.2　VGG网络 … …………………… 129
        5.7.3　训练模型… ……………………… 130
        小结………………………………………… 131
        练习………………………………………… 131
        5.8　网络中的网络（NiN）… ……………… 131
        5.8.1　NiN块 … ………………………… 131
        5.8.2　NiN模型 … ……………………… 132
        5.8.3　训练模型… ……………………… 133
        小结………………………………………… 134
        练习………………………………………… 134
        5.9　含并行连结的网络（GoogLeNet）…… 134
        5.9.1　Inception块 ……………………… 134
        5.9.2　GoogLeNet模型 … …………… 135
        5.9.3　训练模型 ………………………… 137
        小结………………………………………… 137
        练习………………………………………… 137
        5.10　批量归一化……………………………… 138
        5.10.1　批量归一化层 ………………… 138
        5.10.2　从零开始实现 … ……………… 139
        5.10.3　使用批量归一化层的LeNet … … 140
        5.10.4　简洁实现 … …………………… 141
        小结………………………………………… 142
        练习………………………………………… 142
        5.11　残差网络（ResNet） ……………… 143
        5.11.1　残差块 …………………………… 143
        5.11.2　ResNet模型… ………………… 145
        5.11.3　训练模型………………………… 146
        小结………………………………………… 146
        练习………………………………………… 146
        5.12　稠密连接网络（DenseNet）………… 147
        5.12.1　稠密块 …………………………… 147
        5.12.2　过渡层 … ……………………… 148
        5.12.3　DenseNet模型 ………………… 148
        5.12.4　训练模型 … …………………… 149
        小结………………………………………… 149
        练习………………………………………… 149
        第6 章　循环神经网络… ……………… 150
        6.1　语言模型………………………………… 150
        6.1.1　语言模型的计算 … ……………… 151
        6.1.2　n 元语法 … ……………………… 151
        小结………………………………………… 152
        练习………………………………………… 152
        6.2　循环神经网络… ………………………… 152
        6.2.1　不含隐藏状态的神经网络 … …… 152
        6.2.2　含隐藏状态的循环神经网络… … 152
        6.2.3　应用：基于字符级循环神经网络的语言模型 … ……………………… 154
        小结………………………………………… 155
        练习………………………………………… 155
        6.3　语言模型数据集（歌词）…… 155
        6.3.1　读取数据集 … …………………… 155
        6.3.2　建立字符索引 …………………… 156
        6.3.3　时序数据的采样 ………………… 156
        小结………………………………………… 158
        练习………………………………………… 159
        6.4　循环神经网络的从零开始实现… ……… 159
        6.4.1　one-hot向量 … ………………… 159
        6.4.2　初始化模型参数 ………………… 160
        6.4.3　定义模型 ………………………… 160
        6.4.4　定义预测函数 …………………… 161
        6.4.5　裁剪梯度 ………………………… 161
        6.4.6　困惑度 …………………………… 162
        6.4.7　定义模型训练函数 ……………… 162
        6.4.8　训练模型并创作歌词 …………… 163
        小结………………………………………… 164
        练习………………………………………… 164
        6.5　循环神经网络的简洁实现… …………… 165
        6.5.1　定义模型 … ……………………… 165
        6.5.2　训练模型 ………………………… 166
        小结………………………………………… 168
        练习………………………………………… 168
        6.6　通过时间反向传播… …………………… 168
        6.6.1　定义模型 … ……………………… 168
        6.6.2　模型计算图 ……………………… 169
        6.6.3　方法 ……………………………… 169
        小结………………………………………… 170
        练习………………………………………… 170
        6.7　门控循环单元（GRU）………………… 170
        6.7.1　门控循环单元 … ………………… 171
        6.7.2　读取数据集 ……………………… 173
        6.7.3　从零开始实现 …………………… 173
        6.7.4　简洁实现 ………………………… 175
        小结………………………………………… 176
        练习………………………………………… 176
        6.8　长短期记忆（LSTM）… ……………… 176
        6.8.1　长短期记忆 … …………………… 176
        6.8.2　读取数据集 ……………………… 179
        6.8.3　从零开始实现 …………………… 179
        6.8.4　简洁实现 ………………………… 181
        小结………………………………………… 181
        练习………………………………………… 182
        6.9　深度循环神经网络… …………………… 182
        小结………………………………………… 183
        练习………………………………………… 183
        6.10　双向循环神经网络……………………… 183
        小结………………………………………… 184
        练习………………………………………… 184
        第7 章　优化算法… …………………… 185
        7.1　优化与深度学习…………………………… 185
        7.1.1　优化与深度学习的关系 … ……… 185
        7.1.2　优化在深度学习中的挑战 … …… 186
        小结………………………………………… 188
        练习………………………………………… 189
        7.2　梯度下降和随机梯度下降… …………… 189
        7.2.1　一维梯度下降 … ………………… 189
        7.2.2　学习率 …………………………… 190
        7.2.3　多维梯度下降 …………………… 191
        7.2.4　随机梯度下降 …………………… 193
        小结………………………………………… 194
        练习………………………………………… 194
        7.3　小批量随机梯度下降… ………………… 194
        7.3.1　读取数据集 … …………………… 195
        7.3.2　从零开始实现 …………………… 196
        7.3.3　简洁实现 ………………………… 198
        小结………………………………………… 199
        练习………………………………………… 199
        7.4　动量法… …………………………………200
        7.4.1　梯度下降的问题 … ……………… 200
        7.4.2　动量法 …………………………… 201
        ·6·　目　　录
        7.4.3　从零开始实现 …………………… 203
        7.4.4　简洁实现 ………………………… 205
        小结………………………………………… 205
        练习………………………………………… 205
        7.5　AdaGrad算法……………………………206
        7.5.1　算法 … …………………………… 206
        7.5.2　特点 ……………………………… 206
        7.5.3　从零开始实现 …………………… 208
        7.5.4　简洁实现 ………………………… 209
        小结………………………………………… 209
        练习………………………………………… 209
        7.6　RMSProp算法… ………………………209
        7.6.1　算法 … …………………………… 210
        7.6.2　从零开始实现 …………………… 211
        7.6.3　简洁实现 ………………………… 212
        小结………………………………………… 212
        练习………………………………………… 212
        7.7　AdaDelta算法… ……………………… 212
        7.7.1　算法… …………………………… 212
        7.7.2　从零开始实现 …………………… 213
        7.7.3　简洁实现 ………………………… 214
        小结………………………………………… 214
        练习………………………………………… 214
        7.8　Adam算法… …………………………… 215
        7.8.1　算法 … …………………………… 215
        7.8.2　从零开始实现 …………………… 216
        7.8.3　简洁实现 ………………………… 216
        小结………………………………………… 217
        练习………………………………………… 217
        第8 章　计算性能… …………………… 218
        8.1　命令式和符号式混合编程… …………… 218
        8.1.1　混合式编程取两者之长 … ……… 220
        8.1.2　使用HybridSequential类构造模型 … …………………………… 220
        8.1.3　使用HybridBlock类构造模型… …………………………… 222
        小结………………………………………… 224
        练习………………………………………… 224
        8.2　异步计算… ………………………………224
        8.2.1　MXNet中的异步计算 …………… 224
        8.2.2　用同步函数让前端等待计算结果 … …………………………… 226
        8.2.3　使用异步计算提升计算性能 …… 226
        8.2.4　异步计算对内存的影响 ………… 227
        小结………………………………………… 229
        练习………………………………………… 229
        8.3　自动并行计算… …………………………229
        8.3.1　CPU和GPU的并行计算 … …… 230
        8.3.2　计算和通信的并行计算 ………… 231
        小结………………………………………… 231
        练习………………………………………… 231
        8.4　多GPU计算……………………………… 232
        8.4.1　数据并行 … ……………………… 232
        8.4.2　定义模型 ………………………… 233
        8.4.3　多GPU之间同步数据 … ……… 234
        8.4.4　单个小批量上的多GPU训练 … …………………………… 236
        8.4.5　定义训练函数 …………………… 236
        8.4.6　多GPU训练实验 … …………… 237
        小结………………………………………… 237
        练习………………………………………… 237
        8.5　多GPU计算的简洁实现………………… 237
        8.5.1　多GPU上初始化模型参数……… 238
        8.5.2　多GPU训练模型 … …………… 239
        小结………………………………………… 241
        练习………………………………………… 241
        第9 章　计算机视觉… ………………… 242
        9.1　图像增广…………………………………242
        9.1.1　常用的图像增广方法 … ………… 243
        9.1.2　使用图像增广训练模型 … ……… 246
        小结………………………………………… 250
        练习………………………………………… 250
        9.2　微调… ……………………………………250
        热狗识别 … ……………………………… 251
        小结………………………………………… 255
        练习………………………………………… 255
        目　　录　·7·
        9.3　目标检测和边界框… ……………………255
        边界框 … ………………………………… 256
        小结………………………………………… 257
        练习………………………………………… 257
        9.4　锚框… …………………………………… 257
        9.4.1　生成多个锚框… ………………… 257
        9.4.2　交并比 …………………………… 259
        9.4.3　标注训练集的锚框 ……………… 260
        9.4.4　输出预测边界框… ……………… 263
        小结………………………………………… 265
        练习………………………………………… 265
        9.5　多尺度目标检测… ………………………265
        小结………………………………………… 268
        练习………………………………………… 268
        9.6　目标检测数据集（皮卡丘）… …………268
        9.6.1　获取数据集 … …………………… 269
        9.6.2　读取数据集… …………………… 269
        9.6.3　图示数据 ………………………… 270
        小结………………………………………… 270
        练习………………………………………… 271
        9.7　单发多框检测（SSD）… ……………… 271
        9.7.1　定义模型… ……………………… 271
        9.7.2　训练模型 ………………………… 275
        9.7.3　预测目标 ………………………… 277
        小结………………………………………… 278
        练习………………………………………… 278
        9.8　区域卷积神经网络（R-CNN）系列……280
        9.8.1　R-CNN … ……………………… 280
        9.8.2　Fast R-CNN …………………… 281
        9.8.3　Faster R-CNN ………………… 283
        9.8.4　Mask R-CNN … ……………… 284
        小结………………………………………… 285
        练习………………………………………… 285
        9.9　语义分割和数据集… ……………………285
        9.9.1　图像分割和实例分割 … ………… 285
        9.9.2　Pascal VOC2012语义分割数据集 … ………………………… 286
        小结………………………………………… 290
        练习………………………………………… 290
        9.10　全卷积网络（FCN）… ………………290
        9.10.1　转置卷积层 …………………… 291
        9.10.2　构造模型 … …………………… 292
        9.10.3　初始化转置卷积层……………… 294
        9.10.4　读取数据集 … ………………… 295
        9.10.5　训练模型………………………… 296
        9.10.6　预测像素类别…………………… 296
        小结………………………………………… 297
        练习………………………………………… 297
        9.11　样式迁移… ………………………………298
        9.11.1　方法 ……………………………… 298
        9.11.2　读取内容图像和样式图像……… 299
        9.11.3　预处理和后处理图像 ………… 300
        9.11.4　抽取特征 ……………………… 301
        9.11.5　定义损失函数 ………………… 302
        9.11.6　创建和初始化合成图像 ……… 303
        9.11.7　训练模型………………………… 304
        小结………………………………………… 306
        练习………………………………………… 306
        9.12　实战Kaggle比赛：图像
        分类（CIFAR-10）……………………306
        9.12.1　获取和整理数据集 ……………… 307
        9.12.2　图像增广 … …………………… 310
        9.12.3　读取数据集 … ………………… 310
        9.12.4　定义模型………………………… 311
        9.12.5　定义训练函数 … ……………… 312
        9.12.6　训练模型 … …………………… 312
        9.12.7　对测试集分类并在Kaggle
        提交结果 … …………………… 313
        小结………………………………………… 313
        练习………………………………………… 313
        9.13　实战Kaggle比赛：狗的品种
        识别（ImageNet Dogs）…………… 314
        9.13.1　获取和整理数据集 …………… 315
        9.13.2　图像增广 … …………………… 316
        9.13.3　读取数据集 … ………………… 317
        9.13.4　定义模型 … …………………… 318
        9.13.5　定义训练函数 … ……………… 318
        9.13.6　训练模型 … …………………… 319
        ·8·　目　　录
        9.13.7　对测试集分类并在Kaggle提交结果 … …………………… 319
        小结………………………………………… 320
        练习………………………………………… 320
        第10 章　自然语言处理………………… 321
        10.1　词嵌入（word2vec）………………… 321
        10.1.1　为何不采用one-hot向量… …… 321
        10.1.2　跳字模型 ………………………… 322
        10.1.3　连续词袋模型 …………………… 323
        小结………………………………………… 325
        练习………………………………………… 325
        10.2　近似训练…………………………………325
        10.2.1　负采样 …………………………… 325
        10.2.2　层序softmax …………………… 326
        小结………………………………………… 327
        练习………………………………………… 328
        10.3　word2vec的实现………………………328
        10.3.1　预处理数据集 …………………… 328
        10.3.2　负采样 … ……………………… 331
        10.3.3　读取数据集 … ………………… 331
        10.3.4　跳字模型 … …………………… 332
        10.3.5　训练模型 … …………………… 333
        10.3.6　应用词嵌入模型 … …………… 335
        小结………………………………………… 336
        练习………………………………………… 336
        10.4　子词嵌入（fastText）… ……………336
        小结………………………………………… 337
        练习………………………………………… 337
        10.5　全局向量的词嵌入（GloVe）…………337
        10.5.1　GloVe模型 …………………… 338
        10.5.2　从条件概率比值理解GloVe模型……………………… 339
        小结………………………………………… 340
        练习………………………………………… 340
        10.6　求近义词和类比词………………………340
        10.6.1　使用预训练的词向量 ………… 340
        10.6.2　应用预训练词向量 … ………… 341
        小结………………………………………… 343
        练习………………………………………… 343
        10.7　文本情感分类：使用循环神经网络…… 343
        10.7.1　文本情感分类数据集 ………… 343
        10.7.2　使用循环神经网络的模型……… 345
        小结………………………………………… 347
        练习………………………………………… 347
        10.8　文本情感分类：使用卷积神经网络（textCNN）… …………………347
        10.8.1　一维卷积层 … ………………… 348
        10.8.2　时序最大池化层 … …………… 349
        10.8.3　读取和预处理IMDb数据集 … ……………………… 350
        10.8.4　textCNN模型 … ……………… 350
        小结………………………………………… 353
        练习………………………………………… 353
        10.9　编码器-解码器（seq2seq）…………353
        10.9.1　编码器 ………………………… 354
        10.9.2　解码器 … ……………………… 354
        10.9.3　训练模型………………………… 355
        小结………………………………………… 355
        练习………………………………………… 355
        10.10　 束搜索… ………………………………355
        10.10.1　贪婪搜索 … …………………… 356
        10.10.2　穷举搜索 ……………………… 357
        10.10.3　束搜索 ………………………… 357
        小结………………………………………… 358
        练习………………………………………… 358
        10.11　注意力机制… …………………………358
        10.11.1　计算背景变量 … ……………… 359
        10.11.2　更新隐藏状态 … ……………… 360
        10.11.3　发展… ………………………… 361
        小结………………………………………… 361
        练习………………………………………… 361
        10.12　机器翻译… …………………………… 361
        10.12.1　读取和预处理数据集… ……… 361
        10.12.2　含注意力机制的编码器-解码器 … …………… 363
        10.12.3　训练模型 ……………………… 365
        10.12.4　预测不定长的序列… ………… 367
        10.12.5　评价翻译结果 ………………… 367
        小结………………………………………… 369
        练习………………………………………… 369
        附录A　数学基础… …………………… 370
        附录B　使用 Jupyter 记事本… ……… 376
        附录C　使用 AWS 运行代码…………… 381
        附录D　GPU 购买指南………………… 388
        附录E　如何为本书做贡献… ………… 391
        附录F　d2lzh 包索引…………………… 395
        附录G　中英文术语对照表… ………… 397
        参考文献………………………………… 402
        索引……………………………………… 407
     · · · · · ·     (收起)"
26349607,MATLAB之父:编程实践(中译本),9.3,(20人评价),[ MEI ] Cleve Moler / 薛定宇 / 北京航空航天大学出版社 / 2014-3-1 / 39.9,《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Compu...,https://book.douban.com/subject/26349607/,https://img9.doubanio.com/view/subject/s/public/s28031915.jpg,39.9,9787512414655,"《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求...(展开全部)





《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求式的好奇精神。强烈的好奇心，是克利夫给人留下的最深印象，大到人文历史风土人情，小到会议讲座礼尚往来，他都保持着一种童真般的好奇。这种强烈的好奇心也可以从这本书涉猎广泛的内容中得到体会―― 矩阵、历法、谷歌网页排名、音乐、天体运行、分形图、生命进化、数独等等包罗万象。 这些精彩的内容连同生动文笔都在薛定宇老师的译本中得到了很好的体现。薛老师自己的书在读者中享有很高声誉，我最早拜读的就是他写的自动控制领域经典的教材《控制系统计算机辅助设计―― MATLAB 语言与应用》，结构严谨，思维缜密，内容翔实。这种风格在此书中文版的翻译中与原文达到了奇妙融合，使读者在领略克利夫的独特思路时逻辑清晰，而且兴趣盎然，一定是一次非常愉快的阅读体验。 《MATLAB 之父：编程实践》是北京航空航天大学出版社与迈斯沃克公司在图书合作方面的一个杰作，是迈斯沃克公司近两年中国图书计划中最重要的一个项目。《MATLAB之父：编程实践》一书也获得国内最大的MATLAB/Simulink技术交流平台——MATLAB中文论坛的鼎力推荐,MATLAB中文论坛的“MATLAB读书频道”为本书提供了专门版块供读者交流，以期共同进步。","作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国...(展开全部)




作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国家工程院院士，并获多项荣誉，包括瑞典林学平大学荣誉学位，加拿大滑铁卢大学荣誉数学博士学位，丹麦科技大学荣誉博士等。Cleve还获得IEEE计算机学会的2012年计算机先驱奖。","写在前面
        译者的话
        前言
        第1章迭代（Iteration）1
        第2章斐波那契数（FibonacciNumbers）15
        第3章日历与时钟（CalendarsandClocks）29
        第4章矩阵（Matrices）39
        第5章线性方程组（LinearEquations）53
        第6章蕨型叶分形（FractalFern）63
        第7章谷歌的网页排名值（GooglePageRank）71
        第8章指数函数（ExponentialFunction）85
        第9章T形积木（TPuzzle）99
        第10章幻方问题（MagicSquares）107
        第11章井字棋的魅力（TicTacToeMagic）123
        第12章生命游戏（GameofLife）131
        第13章曼德勃罗集（MandelbrotSet）141
        第14章数独（Sudoku）159
        第15章常微分方程（OrdinaryDifferentialEquations）173
        第16章捕食者与猎物模型（Predator-PreyModel）185
        第17章轨道（Orbits）191
        第18章浅水方程（ShallowWaterEquations）207
        第19章摩尔斯电码（MorseCode）211
        第20章音乐（Music）227
     · · · · · ·     (收起)"
35602582,现代C++语言核心特性解析,8.9,(46人评价),谢丙堃 / 人民邮电出版社 / 2021-10,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还...,https://book.douban.com/subject/35602582/,https://img3.doubanio.com/view/subject/s/public/s33999027.jpg,,9787115564177,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理，让读者能够知其然也知其所以然。本书适合出于工作需要而学习 C++ 新特性的 C++ 从业者，也适合对 C++ 新特性有浓烈兴趣的 C++ 爱好者。而对 C++ 入门者来说，也有必要在有一定的 C++ 基础后阅读本书，通过本书来进一步学习 C++ 的核心特性。本书的多媒体版本已由“盛格塾”以微信小程序方式推出，包含作者的语音讲解、插图、PPT 和示例代码。读者可以在手机上学习，也可以在线提问，与老师和其他同学互动。,谢丙堃，从事 C++ 开发工作十余年，先后在数家知名互联网公司担任 C++ 高级开发工程师、技术专家和技术经理。他也是 C++ 语言的爱好者，热衷于研究 C++ 语言的新特性以及 C++ 模板元编程技术。,"第1章　新基础类型（C++11～C++20） 1
        1.1 整数类型long long 1
        1.2 新字符类型char16_t和char32_t 4
        1.2.1 字符集和编码方法 4
        1.2.2 使用新字符类型char16_t和char32_t 5
        1.2.3 wchar_t存在的问题 6
        1.2.4 新字符串连接 7
        1.2.5 库对新字符类型的支持 7
        1.3 char8_t字符类型 8
        1.4 总结 8
        第2章　内联和嵌套命名空间（C++11～C++20） 9
        2.1 内联命名空间的定义和使用 9
        2.2 嵌套命名空间的简化语法 11
        2.3 总结 13
        第3章　auto占位符（C++11～C++17） 14
        3.1 重新定义的auto关键字 14
        3.2 推导规则 16
        3.3 什么时候使用auto 18
        3.4 返回类型推导 20
        3.5 lambda表达式中使用auto类型推导 20
        3.6 非类型模板形参占位符 21
        3.7 总结 22
        第4章　decltype说明符（C++11～C++17） 23
        4.1 回顾typeof和typeid 23
        4.2 使用decltype说明符 24
        4.3 推导规则 27
        4.4 cv限定符的推导 29
        4.5 decltype(auto) 30
        4.6 decltype(auto)作为非类型模板形参占位符 31
        4.7 总结 32
        第5章　函数返回类型后置（C++11） 33
        5.1 使用函数返回类型后置声明函数 33
        5.2 推导函数模板返回类型 34
        5.3 总结 36
        第6章　右值引用（C++11 C++17 C++20） 37
        6.1 左值和右值 37
        6.2 左值引用 39
        6.3 右值引用 40
        6.4 右值的性能优化空间 42
        6.5 移动语义 43
        6.6 值类别 47
        6.7 将左值转换为右值 48
        6.8 万能引用和引用折叠 50
        6.9 完美转发 52
        6.10 针对局部变量和右值引用的隐式移动操作 55
        6.11 总结 57
        第7章　lambda表达式（C++11～C++20） 58
        7.1 lambda表达式语法 58
        7.2 捕获列表 60
        7.2.1 作用域 60
        7.2.2 捕获值和捕获引用 61
        7.2.3 特殊的捕获方法 64
        7.3 lambda表达式的实现原理 65
        7.4 无状态lambda表达式 68
        7.5 在STL中使用lambda表达式 68
        7.6 广义捕获 69
        7.7 泛型lambda表达式 72
        7.8 常量lambda表达式和捕获*this 72
        7.9 捕获[=, this] 73
        7.10 模板语法的泛型lambda表达式 74
        7.11 可构造和可赋值的无状态lambda表达式 76
        7.12 总结 77
        第8章　非静态数据成员默认初始化（C++11 C++20） 78
        8.1 使用默认初始化 78
        8.2 位域的默认初始化 79
        8.3 总结 80
        第9章　列表初始化（C++11 C++20） 81
        9.1 回顾变量初始化 81
        9.2 使用列表初始化 82
        9.3 std::initializer_list详解 84
        9.4 使用列表初始化的注意事项 86
        9.4.1 隐式缩窄转换问题 86
        9.4.2 列表初始化的优先级问题 87
        9.5 指定初始化 88
        9.6 总结 90
        第10章　默认和删除函数（C++11） 91
        10.1 类的特殊成员函数 91
        10.2 显式默认和显式删除 95
        10.3 显式删除的其他用法 98
        10.4 explicit和=delete 99
        10.5 总结 100
        第11章　非受限联合类型（C++11） 101
        11.1 联合类型在C++中的局限性 101
        11.2 使用非受限联合类型 102
        11.3 总结 106
        第12章　委托构造函数（C++11） 107
        12.1 冗余的构造函数 107
        12.2 委托构造函数 110
        12.3 委托模板构造函数 114
        12.4 捕获委托构造函数的异常 115
        12.5 委托参数较少的构造函数 116
        12.6 总结 117
        第13章　继承构造函数（C++11） 118
        13.1 继承关系中构造函数的困局 118
        13.2 使用继承构造函数 119
        13.3 总结 123
        第14章　强枚举类型（C++11 C++17 C++20） 124
        14.1 枚举类型的弊端 124
        14.2 使用强枚举类型 129
        14.3 列表初始化有底层类型枚举对象 131
        14.4 使用using打开强枚举类型 133
        14.5 总结 135
        第15章　扩展的聚合类型（C++17 C++20） 136
        15.1 聚合类型的新定义 136
        15.2 聚合类型的初始化 137
        15.3 扩展聚合类型的兼容问题 139
        15.4 禁止聚合类型使用用户声明的构造函数 140
        15.5 使用带小括号的列表初始化聚合类型对象 142
        15.6 总结 143
        第16章　override和final说明符（C++11） 144
        16.1 重写、重载和隐藏 144
        16.2 重写引发的问题 145
        16.3 使用override说明符 145
        16.4 使用final说明符 146
        16.5 override和final说明符的特别之处 148
        16.6 总结 148
        第17章　基于范围的for循环（C++11 C++17 C++20） 149
        17.1 烦琐的容器遍历 149
        17.2 基于范围的for循环语法 150
        17.3 begin和end函数不必返回相同类型 151
        17.4 临时范围表达式的陷阱 152
        17.5 实现一个支持基于范围的for循环的类 153
        17.6 总结 155
        第18章　支持初始化语句的if和switch（C++17） 156
        18.1 支持初始化语句的if 156
        18.2 支持初始化语句的switch 159
        18.3 总结 160
        第19章　static_assert声明 161
        19.1 运行时断言 161
        19.2 静态断言的需求 162
        19.3 静态断言 163
        19.4 单参数static_assert 164
        19.5 总结 165
        第20章　结构化绑定（C++17 C++20） 166
        20.1 使用结构化绑定 166
        20.2 深入理解结构化绑定 169
        20.3 结构化绑定的3种类型 171
        20.3.1 绑定到原生数组 171
        20.3.2 绑定到结构体和类对象 172
        20.3.3 绑定到元组和类元组的对象 173
        20.4 实现一个类元组类型 175
        20.5 绑定的访问权限问题 178
        20.6 总结 179
        第21章　noexcept关键字（C++11 C++17 C++20） 180
        21.1 使用noexcept代替throw 180
        21.2 用noexcept来解决移动构造问题 183
        21.3 noexcept和throw() 185
        21.4 默认使用noexcept的函数 186
        21.5 使用noexcept的时机 189
        21.6 将异常规范作为类型的一部分 190
        21.7 总结 192
        第22章　类型别名和别名模板（C++11 C++14） 193
        22.1 类型别名 193
        22.2 别名模板 194
        22.3 总结 196
        第23章　指针字面量nullptr（C++11） 197
        23.1 零值整数字面量 197
        23.2 nullptr关键字 198
        23.3 总结 201
        第24章　三向比较（C++20） 202
        24.1 “太空飞船”（spaceship）运算符 202
        24.2 三向比较的返回类型 202
        24.2.1 std::strong_ordering 203
        24.2.2 std::weak_ordering 204
        24.2.3 std::partial_ordering 205
        24.3 对基础类型的支持 206
        24.4 自动生成的比较运算符函数 207
        24.5 兼容旧代码 210
        24.6 总结 211
        第25章　线程局部存储（C++11） 212
        25.1 操作系统和编译器对线程局部存储的支持 212
        25.2 thread_local说明符 213
        25.3 总结 217
        第26章　扩展的inline说明符（C++17） 218
        26.1 定义非常量静态成员变量的问题 218
        26.2 使用inline说明符 219
        26.3 总结 220
        第27章　常量表达式（C++11～C++20） 221
        27.1 常量的不确定性 221
        27.2 constexpr值 224
        27.3 constexpr函数 225
        27.4 constexpr构造函数 228
        27.5 对浮点的支持 230
        27.6 C++14标准对常量表达式函数的增强 230
        27.7 constexpr lambdas表达式 233
        27.8 constexpr的内联属性 235
        27.9 if constexpr 236
        27.10 允许constexpr虚函数 240
        27.11 允许在constexpr函数中出现Try-catch 244
        27.12 允许在constexpr中进行平凡的默认初始化 244
        27.13 允许在constexpr中更改联合类型的有效成员 245
        27.14 使用consteval声明立即函数 246
        27.15 使用constinit检查常量初始化 247
        27.16 判断常量求值环境 248
        27.17 总结 252
        第28章　确定的表达式求值顺序（C++17） 253
        28.1 表达式求值顺序的不确定性 253
        28.2 表达式求值顺序详解 254
        28.3 总结 255
        第29章　字面量优化（C++11～C++17） 257
        29.1 十六进制浮点字面量 257
        29.2 二进制整数字面量 258
        29.3 单引号作为整数分隔符 258
        29.4 原生字符串字面量 259
        29.5 用户自定义字面量 261
        29.6 总结 267
        第30章　alignas和alignof（C++11 C++17） 268
        30.1 不可忽视的数据对齐问题 268
        30.2 C++11标准之前控制数据对齐的方法 270
        30.3 使用alignof运算符 272
        30.4 使用alignas说明符 273
        30.5 其他关于对齐字节长度的支持 276
        30.6 C++17中使用new分配指定对齐字节长度的对象 278
        30.7 总结 279
        第31章　属性说明符和标准属性（C++11～C++20） 280
        31.1 GCC的属性语法 280
        31.2 MSVC的属性语法 281
        31.3 标准属性说明符语法 282
        31.4 使用using打开属性的命名空间 283
        31.5 标准属性 283
        31.5.1 noreturn 284
        31.5.2 carries_dependency 286
        31.5.3 deprecated 286
        31.5.4 fallthrough 287
        31.5.5 nodiscard 288
        31.5.6 maybe_unused 290
        31.5.7 likely和unlikely 290
        31.5.8 no_unique_address 291
        31.6 总结 293
        第32章　新增预处理器和宏（C++17 C++20） 294
        32.1 预处理器__has_include 294
        32.2 特性测试宏 295
        32.2.1 属性特性测试宏 295
        32.2.2 语言功能特性测试宏 295
        32.2.3 标准库功能特性测试宏 297
        32.3 新增宏__VA_OPT__ 301
        32.4 总结 302
        第33章　协程（C++20） 303
        33.1 协程的使用方法 303
        33.2 协程的实现原理 308
        33.2.1 co_await运算符原理 308
        33.2.2 co_yield运算符原理 313
        33.2.3 co_return运算符原理 317
        33.2.4 promise_type的其他功能 319
        33.3 总结 320
        第34章　基础特性的其他优化（C++11～C++20） 321
        34.1 显式自定义类型转换运算符（C++11） 321
        34.2 关于std::launder()（C++17） 325
        34.3 返回值优化（C++11～C++17） 326
        34.4 允许按值进行默认比较（C++20） 333
        34.5 支持new表达式推导数组长度（C++20） 334
        34.6 允许数组转换为未知范围的数组（C++20） 335
        34.7 在delete运算符函数中析构对象（C++20） 336
        34.8 调用伪析构函数结束对象声明周期（C++20） 337
        34.9 修复const和默认复制构造函数不匹配造成无法编译的问题（C++20） 338
        34.10 不推荐使用volatile的情况（C++20） 339
        34.11 不推荐在下标表达式中使用逗号运算符（C++20） 340
        34.12 模块（C++20） 340
        34.13 总结 341
        第35章　可变参数模板（C++11 C++17 C++20） 342
        35.1 可变参数模板的概念和语法 342
        35.2 形参包展开 344
        35.3 sizeof...运算符 352
        35.4 可变参数模板的递归计算 353
        35.5 折叠表达式 354
        35.6 一元折叠表达式中空参数包的特殊处理 357
        35.7 using声明中的包展开 358
        35.8 lambda表达式初始化捕获的包展开 359
        35.9 总结 361
        第36章　typename优化（C++17 C++20） 362
        36.1 允许使用typename声明模板形参 362
        36.2 减少typename使用的必要性 363
        36.3 总结 365
        第37章　模板参数优化（C++11 C++17 C++20） 366
        37.1 允许常量求值作为所有非类型模板的实参 366
        37.2 允许局部和匿名类型作为模板实参 368
        37.3 允许函数模板的默认模板参数 369
        37.4 函数模板添加到ADL查找规则 370
        37.5 允许非类型模板形参中的字面量类类型 371
        37.6 扩展的模板参数匹配规则 373
        37.7 总结 374
        第38章　类模板的模板实参推导（C++17 C++20） 375
        38.1 通过初始化构造推导类模板的模板实参 375
        38.2 拷贝初始化优先 377
        38.3 lambda类型的用途 378
        38.4 别名模板的类模板实参推导 380
        38.5 聚合类型的类模板实参推导 380
        38.6 总结 382
        第39章　用户自定义推导指引（C++17） 383
        39.1 使用自定义推导指引推导模板实例 383
        39.2 聚合类型类模板的推导指引 386
        39.3 总结 387
        第40章　SFINAE（C++11） 388
        40.1 替换失败和编译错误 388
        40.2 SFINAE规则详解 389
        40.3 总结 394
        第41章　概念和约束（C++20） 395
        41.1 使用std::enable_if约束模板 395
        41.2 概念的背景介绍 396
        41.3 使用concept和约束表达式定义概念 397
        41.4 requires子句和约束检查顺序 398
        41.5 原子约束 401
        41.6 requires表达式 403
        41.6.1 简单要求 404
        41.6.2 类型要求 405
        41.6.3 复合要求 405
        41.6.4 嵌套要求 406
        41.7 约束可变参数模板 407
        41.8 约束类模板特化 408
        41.9 约束auto 409
        41.10 总结 410
        第42章　模板特性的其他优化（C++11 C++14） 411
        42.1 外部模板（C++11） 411
        42.2 连续右尖括号的解析优化（C++11） 413
        42.3 friend声明模板形参（C++11） 415
        42.4 变量模板（C++14） 417
        42.5 explicit(bool) 419
        42.6 总结 423
        附录   特性章节对照表 424
     · · · · · ·     (收起)"
36303408,深度学习入门2,9.7,(32人评价),[日]斋藤康毅 / 郑明智 / 人民邮电出版社 / 2023-3 / 129.80元,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。
手把手带你创建深度学习框架，直击现代深度学习框架本质！
◎ 编辑推荐
• 简明易懂，讲...",https://book.douban.com/subject/36303408/,https://img3.doubanio.com/view/subject/s/public/s34476102.jpg,129.80元,9787115607515,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，...(展开全部)





“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，本书旨在揭开这些技术和机制的神秘面纱，帮助读者正确理解技术，体会它们的有趣之处。为此，本书会带领读者从零开始创建一个深度学习框架——DeZero。 DeZero 是本书原创的框架，它用最少的代码实现了现代深度学习框架的功能。本书分60 个步骤来完成这个框架，在此过程中，读者会加深对PyTorch、TensorFlow 和Chainer 等现代深度学习框架的理解，看清深度学习框架的本质。 本书沿袭《深度学习入门：基于Python 的理论与实现》的风格，语言通俗，代码简洁，讲解详细。在自制框架的过程中，读者还能进一步巩固Python 编程和软件开发相关的知识。 本书适合对深度学习框架感兴趣的读者阅读。",斋藤康毅 1984年生于日本长崎县，东京工业大学毕业，并完成东京大学研究生院课程。目前在某企业从事人工智能相关的研究和开发工作。著有《深度学习入门：基于Python的理论与实现》，同时也是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。,"前言
        第1阶段 自动微分 1
        步骤1 作为“箱子”的变量  3
        1.1 什么是变量  3
        1.2 实现Variable类  4
        1.3 （补充）NumPy的多维数组    6
        步骤2 创建变量的函数     8
        2.1 什么是函数      8
        2.2 Function类的实现   9
        2.3 使用Function类     10
        步骤3 函数的连续调用       13
        3.1 Exp函数的实现     13
        3.2 函数的连续调用     14
        步骤4 数值微分       16
        4.1 什么是导数       16
        4.2 数值微分的实现     17
        4.3 复合函数的导数     20
        4.4 数值微分存在的问题      21
        步骤5 反向传播的理论知识       22
        5.1 链式法则        22
        5.2 反向传播的推导      23
        5.3 用计算图表示       25
        步骤6 手动进行反向传播        27
        6.1 Variable类的功能扩展       27
        6.2 Function类的功能扩展       28
        6.3 Square类和Exp类的功能扩展      28
        6.4 反向传播的实现      29
        步骤7 反向传播的自动化        32
        7.1 为反向传播的自动化创造条件      33
        7.2 尝试反向传播       36
        7.3 增加backward方法       38
        步骤8 从递归到循环        40
        8.1 现在的Variable类       40
        8.2 使用循环实现       41
        8.3 代码验证        42
        步骤9 让函数更易用        43
        9.1 作为Python函数使用       43
        9.2 简化backward方法       45
        9.3 只支持ndarray       46
        步骤10 测试         50
        10.1 Python的单元测试       50
        10.2 square函数反向传播的测试      52
        10.3 通过梯度检验来自动测试      53
        10.4 测试小结       54
        第2阶段 用自然的代码表达       59
        步骤11 可变长参数（正向传播篇)       61
        11.1 修改Function类       62
        11.2 Add类的实现      64
        步骤12 可变长参数（改进篇)        65
        12.1 第1项改进：使函数更容易使用      65
        12.2 第2项改进：使函数更容易实现      67
        12.3 add函数的实现       69
        步骤13 可变长参数（反向传播篇)       70
        13.1 支持可变长参数的Add类的反向传播     70
        13.2 修改Variable类       71
        13.3 Square类的实现      73
        步骤14 重复使用同一个变量        75
        14.1 问题的原因 76
        14.2 解决方案       77
        14.3 重置导数       79
        步骤15 复杂的计算图（理论篇）81
        15.1 反向传播的正确顺序       82
        15.2 当前的DeZero        84
        15.3 函数的优先级      87
        步骤16 复杂的计算图（实现篇）88
        16.1 增加“辈分”变量      88
        16.2 按照“辈分”顺序取出元素     90
        16.3 Variable类的backward       92
        16.4 代码验证       93
        步骤17 内存管理和循环引用        97
        17.1 内存管理       97
        17.2 引用计数方式的内存管理      98
        17.3 循环引用      100
        17.4 weakref模块      102
        17.5 代码验证      104
        步骤18 减少内存使用量的模式      106
        18.1 不保留不必要的导数      106
        18.2 回顾Function类      109
        18.3 使用Confifig类进行切换      110
        18.4 模式的切换      111
        18.5 使用with语句切换    112
        步骤19 让变量更易用       116
        19.1 命名变量      116
        19.2 实例变量ndarray      117
        19.3 len函数和print函数      119
        步骤20 运算符重载（1）122
        20.1 Mul类的实现      122
        20.2 运算符重载      125
        步骤21 运算符重载（2）128
        21.1 与ndarray一起使用     128
        21.2 与flfloat和int一起使用    130
        21.3 问题1：左项为flfloat或int的情况    131
        21.4 问题2：左项为ndarray实例的情况   133
        步骤22 运算符重载（3）134
        22.1 负数       135
        22.2 减法       136
        22.3 除法       138
        22.4 幂运算       139
        步骤23 打包         141
        23.1 文件结构      142
        23.2 将代码移到核心类     142
        23.3 运算符重载      144
        23.4 实际的_ _init_ _.py文件     146
        23.5 导入dezero       147
        步骤24 复杂函数的求导        149
        24.1 Sphere函数       150
        24.2 matyas函数       151
        24.3 GoldsteinPrice函数      152
        第3阶段 实现高阶导数         161
        步骤25 计算图的可视化（1） 163
        25.1 安装Graphviz       163
        25.2 使用DOT语言描述图形     165
        25.3 指定节点属性     165
        25.4 连接节点      167
        步骤26 计算图的可视化（2）169
        26.1 可视化代码的使用示例      169
        26.2 从计算图转换为DOT语言    171
        26.3 从DOT语言转换为图像     174
        26.4 代码验证      176
        步骤27 泰勒展开的导数        178
        27.1 sin函数的实现       178
        27.2 泰勒展开的理论知识      179
        27.3 泰勒展开的实现     180
        27.4 计算图的可视化     182
        步骤28 函数优化        184
        28.1 Rosenbrock函数      184
        28.2 求导       185
        28.3 梯度下降法的实现     186
        步骤29 使用牛顿法进行优化（手动计算）190
        29.1 使用牛顿法进行优化的理论知识    191
        29.2 使用牛顿法实现优化      195
        步骤30 高阶导数（准备篇） 197
        30.1 确认工作①：Variable实例变量    197
        30.2 确认工作②：Function类     199
        30.3 确认工作③：Variable类的反向传播    201
        步骤31 高阶导数（理论篇） 204
        31.1 在反向传播时进行的计算     204
        31.2 创建反向传播的计算图的方法    206
        步骤32 高阶导数（实现篇） 209
        32.1 新的DeZero       209
        32.2 函数类的反向传播     210
        32.3 实现更有效的反向传播（增加模式控制代码）211
        32.4 修改_ _init_ _.py      213
        步骤33 使用牛顿法进行优化（自动计算） 215
        33.1 求二阶导数      215
        33.2 使用牛顿法进行优化      217
        步骤34 sin函数的高阶导数        219
        34.1 sin函数的实现       219
        34.2 cos函数的实现      220
        34.3 sin函数的高阶导数      221
        步骤35 高阶导数的计算图       225
        35.1 tanh函数的导数     226
        35.2 tanh函数的实现     226
        35.3 高阶导数的计算图可视化     227
        步骤36 DeZero的其他用途        234
        36.1 double backprop的用途     234
        36.2 深度学习研究中的应用示例     236
        第4阶段 创建神经网络         243
        步骤37 处理张量        245
        37.1 对各元素进行计算     245
        37.2 使用张量时的反向传播      247
        37.3 使用张量时的反向传播（补充内容）249
        步骤38 改变形状的函数        254
        38.1 reshape函数的实现      254
        38.2 从Variable对象调用reshape    258
        38.3 矩阵的转置      259
        38.4 实际的transpose函数（补充内容）262
        步骤39 求和的函数        264
        39.1 sum函数的反向传播      264
        39.2 sum函数的实现      266
        39.3 axis和keepdims      268
        步骤40 进行广播的函数        272
        40.1 broadcast_to函数和sum_to函数    272
        40.2 DeZero的broadcast_to函数和sum_to函数  275
        40.3 支持广播      277
        步骤41 矩阵的乘积        280
        41.1 向量的内积和矩阵的乘积     280
        41.2 检查矩阵的形状     282
        41.3 矩阵乘积的反向传播      282
        步骤42 线性回归        288
        42.1 玩具数据集      288
        42.2 线性回归的理论知识      289
        42.3 线性回归的实现     291
        42.4 DeZero的mean_squared_error函数（补充内容）  295
        步骤43 神经网络        298
        43.1 DeZero中的linear函数      298
        43.2 非线性数据集     301
        43.3 激活函数和神经网络      302
        43.4 神经网络的实现     303
        步骤44 汇总参数的层       307
        44.1 Parameter类的实现     307
        44.2 Layer类的实现      309
        44.3 Linear类的实现      312
        44.4 使用Layer实现神经网络    314
        步骤45 汇总层的层        316
        45.1 扩展Layer类      316
        45.2 Model类      319
        45.3 使用Model来解决问题      321
        45.4 MLP类      323
        步骤46 通过Optimizer更新参数      325
        46.1 Optimizer类      325
        46.2 SGD类的实现       326
        46.3 使用SGD类来解决问题     327
        46.4 SGD以外的优化方法     328
        步骤47 softmax函数和交叉熵误差      331
        47.1 用于切片操作的函数      331
        47.2 softmax函数      334
        47.3 交叉熵误差      337
        步骤48 多分类       340
        48.1 螺旋数据集      340
        48.2 用于训练的代码     341
        步骤49 Dataset类和预处理        346
        49.1 Dataset类的实现     346
        49.2 大型数据集的情况     348
        49.3 数据的连接      349
        49.4 用于训练的代码     350
        49.5 数据集的预处理     351
        步骤50 用于取出小批量数据的DataLoader     354
        50.1 什么是迭代器     354
        50.2 使用DataLoader      358
        50.3 accuracy函数的实现      359
        50.4 螺旋数据集的训练代码      360
        步骤51 MINST的训练       363
        51.1 MNIST数据集       364
        51.2 训练MNIST       366
        51.3 改进模型      368
        第5阶段 DeZero高级挑战      377
        步骤52 支持GPU        379
        52.1 CuPy的安装和使用方法     379
        52.2 cuda模块      382
        52.3 向Variable / Layer / DataLoader类添加代码   383
        52.4 函数的相应修改     386
        52.5 在GPU上训练MNIST      388
        步骤53 模型的保存和加载       391
        53.1 NumPy的save函数和load函数     391
        53.2 Layer类参数的扁平化    394
        53.3 Layer类的save函数和load函数     395
        步骤54 Dropout和测试模式       398
        54.1 什么是Dropout      398
        54.2 Inverted Dropout     401
        54.3 增加测试模式     401
        54.4 Dropout的实现      402
        步骤55 CNN的机制（1） 404
        55.1 CNN的网络结构      404
        55.2 卷积运算      405
        55.3 填充       407
        55.4 步幅       408
        55.5 输出大小的计算方法      409
        步骤56 CNN的机制（2）411
        56.1 三阶张量      411
        56.2 结合方块进行思考     412
        56.3 小批量处理      414
        56.4 池化层       415
        步骤57 conv2d函数和pooling函数     418
        57.1 使用im2col展开     418
        57.2 conv2d函数的实现      420
        57.3 Conv2d层的实现      425
        57.4 pooling函数的实现      426
        步骤58 具有代表性的CNN（VGG16）429
        58.1 VGG16的实现      429
        58.2 已训练的权重数据     431
        58.3 使用已训练的VGG16     435
        步骤59 使用RNN处理时间序列数据      438
        59.1 RNN层的实现       438
        59.2 RNN模型的实现      442
        59.3 切断连接的方法     445
        59.4 正弦波的预测     446
        步骤60 LSTM与数据加载器       451
        60.1 用于时间序列数据的数据加载器    451
        60.2 LSTM层的实现      453
        附录A inplace运算（步骤14的补充内容）463
        A.1 问题确认        463
        A.2 关于复制和覆盖        464
        A.3 DeZero的反向传播        465
        附录B 实现get_item函数（步骤47的补充内容）466
        附录C 在Google Colaboratory上运行      469
        后 记         473
        参考文献          477
     · · · · · ·     (收起)"
35863224,C++20高级编程(第5版),8.4,(195人评价),[比]马克·格雷戈勒（Marc Gregoire） / 程序喵大人、惠惠、墨梵 / 清华大学出版社 / 2022-4 / 228,"拥抱C++的深度和复杂性，挖掘更多可能
众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉...",https://book.douban.com/subject/35863224/,https://img3.doubanio.com/view/subject/s/public/s34341252.jpg,228,9787302602132,"拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函...(展开全部)





拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函数等 ● 深入讨论新的C++20标准库功能，例如文本格式化、范围、原子智能指针、同步原语、日期、时区等","Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Win...(展开全部)




Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Windows和Linux平台上开发24×7运行的C++程序，例如KNX/EIB家庭自动化监控软件。除了C/C++之外，Marc还喜欢C#。 2007年4月，他凭借Visual C++方面的专业技能，获得了微软年度MVP称号。 Marc还是比利时C++用户组(www.becpp.org)的创始人，是C++ Standard Library Quick Reference 第1版和第2版(Apress)的共同作者，以及多家出版社出版的多种书籍的技术编辑，是C++大会CppCon的活跃演讲者。","第I部分  专业的C++简介
        第1章  C++和标准库速成   3
        1.1  C++速成   3
        1.1.1  小程序“Hello World”   4
        1.1.2  名称空间   7
        1.1.3  字面量   9
        1.1.4  变量   9
        1.1.5  运算符   12
        1.1.6  枚举类型   14
        1.1.7  结构体   16
        1.1.8  条件语句   17
        1.1.9  条件运算符   19
        1.1.10  逻辑比较运算符   20
        1.1.11  三向比较运算符   21
        1.1.12  函数   22
        1.1.13  属性   23
        1.1.14  C风格的数组   26
        1.1.15  std::array   27
        1.1.16  std::vector   28
        1.1.17  std::pair   28
        1.1.18  std::optional   29
        1.1.19  结构化绑定   30
        1.1.20  循环   30
        1.1.21  初始化列表   31
        1.1.22  C++中的字符串   32
        1.1.23  作为面向对象语言的C++   32
        1.1.24  作用域解析   35
        1.1.25  统一初始化   36
        1.1.26  指针和动态内存   39
        1.1.27  const的用法   43
        1.1.28  constexpr关键字   45
        1.1.29  consteval关键字   46
        1.1.30  引用   47
        1.1.31  const_cast()   55
        1.1.32  异常   56
        1.1.33  类型别名   56
        1.1.34  类型定义   57
        1.1.35  类型推断   58
        1.1.36  标准库   60
        1.2  第一个大型的C++程序   61
        1.2.1  雇员记录系统   61
        1.2.2  Employee类   61
        1.2.3  Database类   64
        1.2.4  用户界面   67
        1.2.5  评估程序   69
        1.3  本章小结   69
        1.4  练习   69
        第2章  使用string和string_view   71
        2.1  动态字符串   71
        2.1.1  C风格字符串   71
        2.1.2  字符串字面量   73
        2.1.3  C++ std::string类   75
        2.1.4  数值转换   78
        2.1.5  std::string_view类   81
        2.1.6  非标准字符串   84
        2.2  字符串格式化   84
        2.2.1  格式说明符   85
        2.2.2  格式说明符错误   87
        2.2.3  支持自定义类型   87
        2.3  本章小结   90
        2.4  练习   90
        第3章  编码风格   91
        3.1  良好外观的重要性   91
        3.1.1  事先考虑   91
        3.1.2  良好风格的元素   92
        3.2  为代码编写文档   92
        3.2.1  使用注释的原因   92
        3.2.2  注释的风格   96
        3.3  分解   99
        3.3.1  通过重构分解   100
        3.3.2  通过设计分解   101
        3.3.3  本书中的分解   101
        3.4  命名   101
        3.4.1  选择恰当的名称   101
        3.4.2  命名约定   102
        3.5  使用具有风格的语言特性   103
        3.5.1  使用常量   104
        3.5.2  使用引用代替指针   104
        3.5.3  使用自定义异常   104
        3.6  格式   105
        3.6.1  关于大括号对齐的争论   105
        3.6.2  关于空格和圆括号的争论   106
        3.6.3  空格、制表符、换行符   106
        3.7  风格的挑战   107
        3.8  本章小结   107
        3.9  练习   107
        第II部分  专业的C++软件设计
        第4章  设计专业的C++程序   113
        4.1  程序设计概述   113
        4.2  程序设计的重要性   114
        4.3  C++设计   116
        4.4  C++设计的两个原则   116
        4.4.1  抽象   116
        4.4.2  重用   118
        4.5  重用现有代码   119
        4.5.1  关于术语的说明   119
        4.5.2  决定是否重用代码   120
        4.5.3  重用代码的指导原则   121
        4.6  设计一个国际象棋程序   127
        4.6.1  需求   127
        4.6.2  设计步骤   127
        4.7  本章小结   132
        4.8  练习   133
        第5章  面向对象设计   135
        5.1  过程化的思考方式   135
        5.2  面向对象思想   136
        5.2.1  类   136
        5.2.2  组件   136
        5.2.3  属性   136
        5.2.4  行为   137
        5.2.5  综合考虑   137
        5.3  生活在类的世界里   138
        5.3.1  过度使用类   138
        5.3.2  过于通用的类   139
        5.4  类之间的关系   139
        5.4.1  “有一个”关系   139
        5.4.2  “是一个”关系(继承)   140
        5.4.3  “有一个”与“是一个”的
        区别   142
        5.4.4  not-a关系   144
        5.4.5  层次结构   145
        5.4.6  多重继承   146
        5.4.7  混入类   147
        5.5  本章小结   147
        5.6  练习   148
        第6章  设计可重用代码   149
        6.1  重用哲学   149
        6.2  如何设计可重用代码   150
        6.2.1  使用抽象   150
        6.2.2  构建理想的重用代码   151
        6.2.3  设计有用的接口   157
        6.2.4  设计成功的抽象   162
        6.2.5  SOLID原则   162
        6.3  本章小结   163
        6.4  练习   163
        第III部分  C++编码方法
        第7章  内存管理   167
        7.1  使用动态内存   167
        7.1.1  如何描绘内存   168
        7.1.2  分配和释放   169
        7.1.3  数组   170
        7.1.4  使用指针   177
        7.2  数组-指针的对偶性   178
        7.2.1  数组就是指针   178
        7.2.2  并非所有指针都是数组   180
        7.3  底层内存操作   180
        7.3.1  指针运算   180
        7.3.2  自定义内存管理   181
        7.3.3  垃圾回收   181
        7.3.4  对象池   182
        7.4  常见的内存陷阱   182
        7.4.1  数据缓冲区分配不足以及
        内存访问越界   182
        7.4.2  内存泄漏   183
        7.4.3  双重释放和无效指针   186
        7.5  智能指针   186
        7.5.1  unique_ptr   187
        7.5.2  shared_ptr   190
        7.5.3  weak_ptr   193
        7.5.4  向函数传递参数   193
        7.5.5  从函数中返回   194
        7.5.6  enable_shared_from_this   194
        7.5.7  过时的、移除的auto_ptr   195
        7.6  本章小结   195
        7.7  练习   195
        第8章  类和对象   197
        8.1  电子表格示例介绍   197
        8.2  编写类   198
        8.2.1  类定义   198
        8.2.2  定义方法   200
        8.2.3  使用对象   203
        8.3  对象的生命周期   205
        8.3.1  创建对象   205
        8.3.2  销毁对象   219
        8.3.3  对象赋值   220
        8.3.4  编译器生成的拷贝构造函数和
        拷贝赋值运算符   223
        8.3.5  复制和赋值的区别   223
        8.4  本章小结   224
        8.5  练习   225
        第9章  精通类和对象   227
        9.1  友元   227
        9.2  对象中的动态内存分配   228
        9.2.1  Spreadsheet类   228
        9.2.2  使用析构函数释放内存   231
        9.2.3  处理复制和赋值   231
        9.2.4  使用移动语义处理移动   237
        9.2.5  零规则   246
        9.3  与方法有关的更多内容   246
        9.3.1  static方法   246
        9.3.2  const方法   247
        9.3.3  方法重载   248
        9.3.4  内联方法   251
        9.3.5  默认参数   252
        9.4  不同的数据成员类型   252
        9.4.1  静态数据成员   253
        9.4.2  const static数据成员   254
        9.4.3  引用数据成员   255
        9.5  嵌套类   256
        9.6  类内的枚举类型   257
        9.7  运算符重载   258
        9.7.1  示例：为SpreadsheetCell
        实现加法   258
        9.7.2  重载算术运算符   261
        9.7.3  重载比较运算符   262
        9.7.4  创建具有运算符重载的类型   266
        9.8  创建稳定的接口   266
        9.9  本章小结   270
        9.10  练习   270
        第10章  揭秘继承技术   271
        10.1  使用继承构建类   271
        10.1.1  扩展类   272
        10.1.2  重写方法   275
        10.2  使用继承重用代码   282
        10.2.1  WeatherPrediction类   282
        10.2.2  在派生类中添加功能   283
        10.2.3  在派生类中替换功能   284
        10.3  利用父类   285
        10.3.1  父类构造函数   285
        10.3.2  父类的析构函数   286
        10.3.3  使用父类方法   287
        10.3.4  向上转型和向下转型   289
        10.4  继承与多态性   290
        10.4.1  回到电子表格   290
        10.4.2  设计多态性的电子表格
        单元格   291
        10.4.3  SpreadsheetCell基类   291
        10.4.4  独立的派生类   293
        10.4.5  利用多态性   294
        10.4.6  考虑将来   295
        10.5  多重继承   296
        10.5.1  从多个类继承   296
        10.5.2  名称冲突和歧义基类   297
        10.6  有趣而晦涩的继承问题   300
        10.6.1  修改重写方法的返回类型   300
        10.6.2  派生类中添加虚基类方法的
        重载   301
        10.6.3  继承的构造函数   302
        10.6.4  重写方法时的特殊情况   306
        10.6.5  派生类中的复制构造函数和
        赋值运算符   312
        10.6.6  运行期类型工具   313
        10.6.7  非public继承   314
        10.6.8  虚基类   315
        10.7  类型转换   316
        10.7.1  static_cast()   316
        10.7.2  reinterpret_cast()   317
        10.7.3  std::bit_cast()   318
        10.7.4  dynamic_cast()   318
        10.7.5  类型转换小结   319
        10.8  本章小结   319
        10.9  练习   320
        第11章  零碎的工作   321
        11.1  模块   321
        11.1.1  模块接口文件   322
        11.1.2  模块实现文件   324
        11.1.3  从实现中分离接口   325
        11.1.4  可见性和可访问性   326
        11.1.5  子模块   326
        11.1.6  模块划分   327
        11.1.7  头文件单元   329
        11.2  头文件   330
        11.2.1  重复定义   330
        11.2.2  循环依赖   330
        11.2.3  查询头文件是否存在   331
        11.3  核心语言特性的特性测试宏   331
        11.4  STATIC关键字   332
        11.4.1  静态数据成员和方法   332
        11.4.2  静态链接   332
        11.4.3  函数中的静态变量   334
        11.4.4  非局部变量的初始化顺序   335
        11.4.5  非局部变量的销毁顺序   335
        11.5  C的实用工具   335
        11.5.1  变长参数列表   336
        11.5.2  预处理器宏   337
        11.6  本章小结   338
        11.7  练习   338
        第12章  利用模板编写泛型代码   341
        12.1  模板概述   341
        12.2  类模板   342
        12.2.1  编写类模板   342
        12.2.2  编译器处理模板的原理   349
        12.2.3  将模板代码分布到多个
        文件中   350
        12.2.4  模板参数   351
        12.2.5  方法模板   355
        12.2.6  类模板的特化   359
        12.2.7  从类模板派生   361
        12.2.8  继承还是特化   362
        12.2.9  模板别名   362
        12.3  函数模板   363
        12.3.1  函数模板的重载   364
        12.3.2  类模板的友元函数模板   365
        12.3.3  对模板参数推导的更多介绍   366
        12.3.4  函数模板的返回类型   367
        12.4  简化函数模板的语法   368
        12.5  变量模板   369
        12.6  概念   369
        12.6.1  语法   369
        12.6.2  约束表达式   370
        12.6.3  预定义的标准概念   372
        12.6.4  类型约束的auto   372
        12.6.5  类型约束和函数模板   373
        12.6.6  类型约束和类模板   375
        12.6.7  类型约束和类方法   375
        12.6.8  类型约束和模板特化   376
        12.7  本章小结   376
        12.8  练习   377
        第13章  C++ I/O揭秘   379
        13.1  使用流   379
        13.1.1  流的含义   380
        13.1.2  流的来源和目的地   381
        13.1.3  流式输出   381
        13.1.4  流式输入   386
        13.1.5  对象的输入输出   392
        13.1.6  自定义的操作算子   393
        13.2  字符串流   393
        13.3  文件流   394
        13.3.1  文本模式与二进制模式   395
        13.3.2  通过seek()和tell()在文件中
        转移   395
        13.3.3  将流链接在一起   397
        13.4  双向I/O   398
        13.5  文件系统支持库   399
        13.5.1  路径   399
        13.5.2  目录条目   401
        13.5.3  辅助函数   401
        13.5.4  目录遍历   401
        13.6  本章小结   402
        13.7  练习   403
        第14章  错误处理   405
        14.1  错误与异常   405
        14.1.1  异常的含义   405
        14.1.2  C++中异常的优点   406
        14.1.3  建议   407
        14.2  异常机制   407
        14.2.1  抛出和捕获异常   408
        14.2.2  异常类型   410
        14.2.3  按const引用捕获异常对象   411
        14.2.4  抛出并捕获多个异常   411
        14.2.5  未捕获的异常   414
        14.2.6  noexcept说明符   415
        14.2.7  noexcept(expression)说明符   415
        14.2.8  noexcept(expression)运算符   415
        14.2.9  抛出列表   416
        14.3  异常与多态性   416
        14.3.1  标准异常层次结构   416
        14.3.2  在类层次结构中捕获异常   418
        14.3.3  编写自己的异常类   419
        14.3.4  源码位置   421
        14.3.5  日志记录的源码位置   422
        14.3.6  异常的源码位置   422
        14.3.7  嵌套异常   423
        14.4 重新抛出异常   425
        14.5  堆栈的释放与清理   426
        14.5.1  使用智能指针   427
        14.5.2  捕获、清理并重新抛出   428
        14.6  常见的错误处理问题   428
        14.6.1  内存分配错误   428
        14.6.2  构造函数中的错误   430
        14.6.3  构造函数的function-try-blocks   432
        14.6.4  析构函数中的错误   435
        14.7  本章小结   435
        14.8  练习   435
        第15章  C++运算符重载   437
        15.1  运算符重载概述   437
        15.1.1  重载运算符的原因   438
        15.1.2  运算符重载的限制   438
        15.1.3  运算符重载的选择   438
        15.1.4  不应重载的运算符   440
        15.1.5  可重载运算符小结   440
        15.1.6  右值引用   443
        15.1.7  优先级和结合性   444
        15.1.8  关系运算符   444
        15.2  重载算术运算符   445
        15.2.1  重载一元负号和一元正号
        运算符   445
        15.2.2  重载递增和递减运算符   446
        15.3  重载按位运算符和二元逻辑
        运算符   446
        15.4  重载插入运算符和提取运算符   447
        15.5  重载下标运算符   448
        15.5.1  通过operator[]提供只读访问   451
        15.5.2  非整数数组索引   452
        15.6  重载函数调用运算符   452
        15.7  重载解除引用运算符   453
        15.7.1  实现operator*   454
        15.7.2  实现operator->   455
        15.7.3  operator.*和operator ->*的
        含义   455
        15.8  编写转换运算符   456
        15.8.1  auto运算符   456
        15.8.2  使用显式转换运算符解决
        多义性问题   457
        15.8.3  用于布尔表达式的转换   457
        15.9  重载内存分配和内存释放
        运算符   459
        15.9.1  new和delete的工作原理   459
        15.9.2  重载operator new和
        operator delete   461
        15.9.3  显式地删除/默认化operator new
        和operator delete   463
        15.9.4  重载带有额外参数的operator new
        和operator delete   463
        15.9.5  重载带有内存大小参数的
        operator delete   464
        15.9.6  重载用户定义的字面量
        运算符   464
        15.9.7  cooked模式字面量运算符   465
        15.9.8  raw模式字面量运算符   465
        15.9.9  标准用户定义的字面量   466
        15.10  本章小结   466
        15.11  练习   466
        第16章  C++标准库概述   469
        16.1  编码原则   470
        16.1.1  使用模板   470
        16.1.2  使用运算符重载   470
        16.2  C++标准库概述   470
        16.2.1  字符串   470
        16.2.2  正则表达式   471
        16.2.3  I/O流   471
        16.2.4  智能指针   471
        16.2.5  异常   471
        16.2.6  数学工具   472
        16.2.7  时间和日期工具   473
        16.2.8  随机数   473
        16.2.9  初始化列表   474
        16.2.10  Pair和Tuple   474
        16.2.11  词汇类型   474
        16.2.12  函数对象   474
        16.2.13  文件系统   474
        16.2.14  多线程   475
        16.2.15  类型萃取   475
        16.2.16  标准整数类型   475
        16.2.17  标准库特性测试宏   475
        16.2.18  <version>   476
        16.2.19  源位置   476
        16.2.20  容器   476
        16.2.21  算法   482
        16.2.22  范围库   488
        16.2.23  标准库中还缺什么   488
        16.3  本章小结   489
        16.4  练习   489
        第17章  理解迭代器与范围库   491
        17.1  迭代器   491
        17.1.1  获取容器的迭代器   494
        17.1.2  迭代器萃取   495
        17.1.3  示例   495
        17.2  流迭代器   496
        17.2.1  输出流迭代器   497
        17.2.2  输入流迭代器   497
        17.3  迭代器适配器   498
        17.3.1  插入迭代器   498
        17.3.2  逆向迭代器   499
        17.3.3  移动迭代器   500
        17.4  范围   502
        17.4.1  基于范围的算法   502
        17.4.2  视图   504
        17.4.3  范围工厂   508
        17.5  本章小结   509
        17.6  练习   509
        第18章  标准库容器   511
        18.1  容器概述   511
        18.1.1  对元素的要求   512
        18.1.2  异常和错误检查   513
        18.2  顺序容器   514
        18.2.1  vector   514
        18.2.2  vector<bool>特化   531
        18.2.3  deque   532
        18.2.4  list   532
        18.2.5  forward_list   535
        18.2.6  array   537
        18.2.7  span   538
        18.3  容器适配器   540
        18.3.1  queue   540
        18.3.2  priority_queue   542
        18.3.3  stack   545
        18.4  有序关联容器   545
        18.4.1  pair工具类   545
        18.4.2  map   546
        18.4.3  multimap   554
        18.4.4  set   556
        18.4.5  multiset   558
        18.5  无序关联容器/哈希表   558
        18.5.1  哈希函数   559
        18.5.2  unordered_map   560
        18.5.3  unordered_multimap   563
        18.5.4  unordered_set/
        unordered_multiset   564
        18.6  其他容器   564
        18.6.1  标准C风格数组   564
        18.6.2  string   565
        18.6.3  流   566
        18.6.4  bitset   566
        18.7  本章小结   570
        18.8  练习   570
        第19章  函数指针，函数对象，lambda
        表达式   571
        19.1  函数指针   571
        19.2  指向方法(和数据成员)的指针   573
        19.3  函数对象   576
        19.3.1  编写第一个函数对象   576
        19.3.2  标准库中的函数对象   576
        19.4  lambda表达式   582
        19.4.1  语法   583
        19.4.2  lambda表达式作为参数   587
        19.4.3  泛型lambda表达式   587
        19.4.4  lambda捕获表达式   587
        19.4.5  模板化lambda表达式   588
        19.4.6  lambda表达式作为返回类型   589
        19.4.7  未计算上下文中的lambda
        表达式   589
        19.4.8  默认构造、拷贝和赋值   589
        19.5  调用   590
        19.6  本章小结   590
        19.7  练习   590
        第20章  掌握标准库算法   593
        20.1  算法概述   593
        20.1.1  find()和find_if()算法   594
        20.1.2  accumulate()算法   596
        20.1.3  在算法中使用移动语义   597
        20.1.4  算法回调   597
        20.2  算法详解   598
        20.2.1  非修改序列算法   598
        20.2.2  修改序列算法   603
        20.2.3  操作算法   611
        20.2.4  分区算法   613
        20.2.5  排序算法   614
        20.2.6  二分查找算法   615
        20.2.7  集合算法   616
        20.2.8  最小/最大算法   618
        20.2.9  并行算法   619
        20.2.10  约束算法   620
        20.2.11  数值处理算法   621
        20.3  本章小结   622
        20.4  练习   622
        第21章  字符串的本地化与正则表达式   625
        21.1  本地化   625
        21.1.1  宽字符   625
        21.1.2  本地化字符串字面量   626
        21.1.3  非西方字符集   626
        21.1.4  locale和facet   628
        21.1.5  转换   631
        21.2  正则表达式   632
        21.2.1  ECMAScript语法   632
        21.2.2  regex库   637
        21.2.3  regex_match()   638
        21.2.4  regex_search()   640
        21.2.5  regex_iterator   641
        21.2.6  regex_token_iterator   642
        21.2.7  regex_replace()   644
        21.3  本章小结   646
        21.4  练习   646
        第22章  日期和时间工具   647
        22.1  编译期有理数   647
        22.2  持续时间   649
        22.3  时钟   653
        22.4  时间点   655
        22.5  日期   656
        22.6  时区   658
        22.7  本章小结   659
        22.8  练习   659
        第23章  随机数工具   661
        23.1  C风格随机数生成器   661
        23.1.1  随机数引擎   662
        23.1.2  随机数引擎适配器   663
        23.1.3  预定义的随机数引擎和
        引擎适配器   664
        23.1.4  生成随机数   664
        23.1.5  随机数分布   666
        23.2  本章小结   668
        23.3  练习   669
        第24章  其他库工具   671
        24.1  variant   671
        24.2  any   673
        24.3  元组   674
        24.3.1  分解元组   676
        24.3.2  串联   677
        24.3.3  比较   677
        24.3.4  make_from_tuple()   678
        24.3.5  apply()   678
        24.4  本章小结   678
        24.5  练习   678
        第IV部分  掌握C++的高级特性
        第25章  自定义和扩展标准库   683
        25.1  分配器   683
        25.2  扩展标准库   684
        25.2.1  扩展标准库的原因   685
        25.2.2  编写标准库算法   685
        25.2.3  编写标准库容器   686
        25.2.4  将directed_graph实现为
        标准库容器   696
        25.2.5  添加分配器支持   712
        25.2.6  改善graph_node   716
        25.2.7  附加的标准库类似功能   717
        25.2.8  进一步改善   719
        25.2.9  其他容器类型   719
        25.3  本章小结   720
        25.4  练习   720
        第26章  高级模板   721
        26.1  深入了解模板参数   721
        26.1.1  深入了解模板类型参数   721
        26.1.2  template template参数介绍   724
        26.1.3  深入了解非类型模板参数   725
        26.2  类模板部分特例化   727
        26.3  通过重载模拟函数部分特例化   730
        26.4  模板递归   731
        26.4.1  N维网格：初次尝试   731
        26.4.2  真正的N维网格   732
        26.5  可变参数模板   734
        26.5.1  类型安全的变长参数列表   734
        26.5.2  可变数目的混入类   736
        26.5.3  折叠表达式   737
        26.6  模板元编程   739
        26.6.1  编译时阶乘   739
        26.6.2  循环展开   740
        26.6.3  打印元组   741
        26.6.4  类型trait   744
        26.6.5  模板元编程结论   752
        26.7  本章小结   752
        26.8  练习   752
        第27章  C++多线程编程   753
        27.1  多线程编程概述   754
        27.1.1  争用条件   755
        27.1.2  撕裂   756
        27.1.3  死锁   756
        27.1.4  伪共享   757
        27.2  线程   757
        27.2.1  通过函数指针创建线程   758
        27.2.2  通过函数对象创建线程   759
        27.2.3  通过lambda创建线程   760
        27.2.4  通过成员函数创建线程   760
        27.2.5  线程本地存储   761
        27.2.6  取消线程   761
        27.2.7  自动join线程   761
        27.2.8  从线程获得结果   762
        27.2.9  复制和重新抛出异常   762
        27.3  原子操作库   764
        27.3.1  原子操作   766
        27.3.2  原子智能指针   767
        27.3.3  原子引用   767
        27.3.4  使用原子类型   767
        27.3.5  等待原子变量   769
        27.4  互斥   770
        27.4.1  互斥体类   770
        27.4.2  锁   772
        27.4.3  std::call_once   774
        27.4.4  互斥体对象的用法示例   776
        27.5  条件变量   779
        27.5.1  虚假唤醒   780
        27.5.2  使用条件变量   780
        27.6  latch   781
        27.7  barrier   782
        27.8  semaphore   782
        27.9  future   783
        27.9.1  std::promise和std::future   784
        27.9.2  std::packaged_task   784
        27.9.3  std::async   785
        27.9.4  异常处理   786
        27.9.5  std::shared_future   786
        27.10  示例：多线程的Logger类   787
        27.11  线程池   791
        27.12  协程   792
        27.13  线程设计和最佳实践   793
        27.14  本章小结   794
        27.15  练习   794
        第V部分  C++软件工程
        第28章  充分利用软件工程方法   799
        28.1  过程的必要性   799
        28.2  软件生命周期模型   800
        28.2.1  瀑布模型   800
        28.2.2  生鱼片模型   802
        28.2.3  螺旋类模型   802
        28.2.4  敏捷   804
        28.3  软件工程方法论   805
        28.3.1  UP   805
        28.3.2  RUP   806
        28.3.3  Scrum   806
        28.3.4  极限编程   808
        28.3.5  软件分流   812
        28.4  构建自己的过程和方法   812
        28.4.1  对新思想采取开放态度   812
        28.4.2  提出新想法   812
        28.4.3  知道什么行得通、什么行不通   812
        28.4.4  不要逃避   813
        28.5  源代码控制   813
        28.6  本章小结   814
        28.7  练习   814
        第29章  编写高效的C++程序   817
        29.1  性能和效率概述   817
        29.1.1  提升效率的两种方式   818
        29.1.2  两种程序   818
        29.1.3  C++是不是低效的语言   818
        29.2  语言层次的效率   818
        29.2.1  高效地操纵对象   819
        29.2.2  预分配内存   823
        29.2.3  使用内联方法和函数   823
        29.3  设计层次的效率   823
        29.3.1  尽可能多地缓存   823
        29.3.2  使用对象池   824
        29.4  剖析   829
        29.4.1  使用gprof的剖析示例   829
        29.4.2  使用Visual C++ 2019的剖析示例   836
        29.5  本章小结   838
        29.6  练习   838
        第30章  熟练掌握测试技术   841
        30.1  质量控制   841
        30.1.1  谁负责测试   842
        30.1.2  bug的生命周期   842
        30.1.3  bug跟踪工具   843
        30.2  单元测试   844
        30.2.1  单元测试方法   844
        30.2.2  单元测试过程   845
        30.2.3  实际中的单元测试   848
        30.3  模糊测试   855
        30.4  高级测试   855
        30.4.1  集成测试   855
        30.4.2  系统测试   856
        30.4.3  回归测试   857
        30.5  用于成功测试的建议   857
        30.6  本章小结   858
        30.7  练习   858
        第31章  熟练掌握调试技术   859
        31.1  调试的基本定律   859
        31.2  bug分类学   860
        31.3  避免bug   860
        31.4  为bug做好规划   861
        31.4.1  错误日志   861
        31.4.2  调试跟踪   862
        31.4.3  断言   869
        31.4.4  崩溃转储   870
        31.5  调试技术   870
        31.5.1  重现bug   870
        31.5.2  调试可重复的bug   871
        31.5.3  调试不可重现的bug   871
        31.5.4  调试退化   872
        31.5.5  调试内存问题   872
        31.5.6  调试多线程程序   876
        31.5.7  调试示例：文章引用   876
        31.5.8  从ArticleCitations示例中总结出的教训   887
        31.6  本章小结   887
        31.7  练习   887
        第32章  使用设计技术和框架   889
        32.1  容易忘记的语法   890
        32.1.1  编写类   890
        32.1.2  派生类   891
        32.1.3  编写lambda表达式   892
        32.1.4  使用“复制和交换”惯用语法   892
        32.1.5  抛出和捕捉异常   893
        32.1.6  写入文件   894
        32.1.7  读取文件   894
        32.1.8  写入类模板   895
        32.1.9  约束模板参数   895
        32.2  始终存在更好的方法   896
        32.2.1  RAII   896
        32.2.2  双分派   898
        32.2.3  混入类   902
        32.3  面向对象的框架   904
        32.3.1  使用框架   904
        32.3.2  MVC范型   905
        32.4  本章小结   906
        32.5  练习   906
        第33章  应用设计模式   907
        33.1  依赖注入   908
        33.1.1  示例：日志机制   908
        33.1.2  依赖注入logger的实现   908
        33.1.3  使用依赖注入   909
        33.2  抽象工厂模式   910
        33.2.1  示例：模拟汽车工厂   910
        33.2.2  实现抽象工厂   911
        33.2.3  使用抽象工厂   912
        33.3  工厂方法模式   913
        33.3.1  示例：模拟第二个汽车工厂   913
        33.3.2  实现工厂   914
        33.3.3  使用工厂   915
        33.3.4  工厂的其他类型   917
        33.3.5  工厂的其他用法   917
        33.4  适配器模式   918
        33.4.1  示例：适配Logger类   918
        33.4.2  实现适配器   919
        33.4.3  使用适配器   920
        33.5  代理模式   920
        33.5.1  示例：隐藏网络连接问题   920
        33.5.2  实现代理   921
        33.5.3  使用代理   922
        33.6  迭代器模式   922
        33.7  观察者模式   923
        33.7.1  示例：从主题中暴露事件   923
        33.7.2  实现观察者   923
        33.7.3  使用观察者   924
        33.8  装饰器模式   925
        33.8.1  示例：在网页中定义样式   926
        33.8.2  装饰器的实现   926
        33.8.3  使用装饰器   927
        33.9  责任链模式   928
        33.9.1  示例：事件处理   928
        33.9.2  实现责任链   928
        33.9.3  使用责任链   929
        33.10  单例模式   930
        33.10.1  日志记录机制   931
        33.10.2  实现单例   931
        33.10.3  使用单例   933
        33.11  本章小结   933
        33.12  练习   933
        第34章  开发跨平台和跨语言的应用程序   935
        34.1  跨平台开发   935
        34.1.1  架构问题   935
        34.1.2  实现问题   938
        34.1.3  平台专用功能   940
        34.2  跨语言开发   940
        34.2.1  混用C和C++   941
        34.2.2  改变范型   941
        34.2.3  链接C代码   944
        34.2.4  从C#调用C++代码   946
        34.2.5  C++/CLI在C++中使用C#代码和在C#中使用C++代码   947
        34.2.6  在Java中使用JNI调用C++代码   948
        34.2.7  从C++代码调用脚本   950
        34.2.8  从脚本调用C++代码   950
        34.2.9  从C++调用汇编代码   952
        34.3  本章小结   953
        34.4  练习   953
        第VI部分  附录
        附录A  C++面试   957
        在线资源(扫描封底二维码下载)
        附录B  标准库头文件   977
        附录C  UML简介   983
        附录D  带注解的参考文献   989
     · · · · · ·     (收起)"
30329536,数据密集型应用系统设计,9.7,(1709人评价),Martin Kleppmann / 赵军平、李三平、吕云松、耿煜 / 中国电力出版社 / 2018-9-1 / 128,"全书分为三大部分：
第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以...",https://book.douban.com/subject/30329536/,https://img1.doubanio.com/view/subject/s/public/s34186559.jpg,128,9787519821968,"全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方...(展开全部)





全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方式就是集成多个不同的数据库、缓存模块以及索引模块等。首先第10章以批处理开始来处理派生数据，紧接着第11章采用流式处理。第12章总结之前介绍的多种技术，并分析讨论未来构建可靠、可扩展和可维护应用系统可能的新方向或方法。","作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, ...(展开全部)




作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, Nvidia GPU Tech Conf等做技术分享，持续关注数据密集和计算密集相关技术的演进、融合与赋能推广。 吕云松，北京大学计算机硕士，硕士及DELL EMC中国研究院实习期间专注于大数据实时流式处理相关的研究。现就职于华为2012中软院黎曼实验室，主要从事深度学习的研发。 耿煜，DELL EMC架构师兼GTM负责人，致力于推广企业级数字化转型方案。深耕分布式架构以及云计算12年，先后任职于ChinaCache，Sun Microsystems以及EMC等公司。 李三平，美国麻省大学计算机工程专业博士，DELL EMC中国研究院首席科学家，研究方向为机器学习、深度学习、智能运维、遥感影像等。已在IEEE Transactions期刊和会议上发表论文数十篇，申请美国专利20余项。推崇简约，热衷机器学习。","前言 .....................................................1
        第一部分 数据系统基础
        第1章 可靠、可扩展与可维护的应用系统 ................... 11
        认识数据系统 ...........................................12
        可靠性 ..................................................14
        可扩展性 ................................................18
        可维护性 ................................................25
        小结 .....................................................28
        第2章 数据模型与查询语言 ............................... 33
        关系模型与文档模型 .......................................34
        数据查询语言 ...........................................46
        图状数据模型 ......................................52
        小结 ...................................................65
        第3章 数据存储与检索 .................................. 71
        数据库核心：数据结构 ...................................72
        事务处理与分析处理 ...................................89
        列式存储 .........................................94
        小结 ..............................................101
        第4章 数据编码与演化 .............................. 109
        数据编码格式 .................................... 110
        数据流模式 ......................................124
        小结 .............................................134
        第二部分 分布式数据系统
        第5章 数据复制 ................................. 145
        主节点与从节点 ..................................146
        复制滞后问题 ......................................154
        多主节点复制 .......................................160
        无主节点复制 .....................................168
        小结 ..............................................181
        第6章 数据分区 ............................... 189
        数据分区与数据复制 .................................190
        键-值数据的分区 ...................................190
        分区与二级索引 ...................................195
        分区再平衡 ....................................198
        请求路由 ..................................202
        小结 .................................204
        第7章 事务 .............................. 211
        深入理解事务 ......................................212
        弱隔离级别 .................................221
        串行化 ...........................................237
        小结 ...........................................250
        第8章 分布式系统的挑战 ...................... 259
        故障与部分失效 ...............................260
        不可靠的网络 ..................................262
        不可靠的时钟 ..................................271
        知识，真相与谎言 ...............................282
        小结 ..........................................292
        第9章 一致性与共识 ..................... 303
        一致性保证 ....................................304
        可线性化 ........................................305
        顺序保证 ........................................319
        分布式事务与共识 .................................330
        小结 ...............................................349
        第三部分 派生数据
        第10章 批处理系统 ................................ 367
        使用UNIX工具进行批处理 .............................368
        MapReduce与分布式文件系统 .........................375
        超越MapReduce ....................................394
        小结 ............................................403
        第11章 流处理系统 .............................. 413
        发送事件流 .......................................414
        数据库与流 .......................................424
        流处理 .........................................435
        小结 ............................................449
        第12章 数据系统的未来 ............................ 461
        数据集成 .........................................461
        分拆数据库 .......................................469
        端到端的正确性 ....................................484
        做正确的事情 .......................................500
        小结 ..............................................509
        术语表 ............................................ 521
     · · · · · ·     (收起)"
35144587,Go专家编程,9.1,(128人评价),任洪彩 / 电子工业出版社 / 2020-7 / 108.00元,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松...,https://book.douban.com/subject/35144587/,https://img3.doubanio.com/view/subject/s/public/s33699643.jpg,108.00元,9787121365577,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松地了解Go语言的内部运作机制。 本书首先介绍Go语言常见的数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者可以借此测验自身对该知识点的掌握程度。接着介绍了Go语言最基础的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了一些标准库、异常处理和依赖管理等非语法相关但非常重要的内容。最后结合作者的见闻，整理了一些发生在真实项目中的编程陷阱。,任洪彩，华为云原生团队核心成员，开源爱好者，深度参与CNCF（云原生计算基金会）旗下Kubernetes、Prometheus等项目贡献，Kubernetes资深成员，担任Kubernetes SIG-Instrumentation Approver，敏捷软件思想深度实践者，在Nokia、华为等公司参与过多个大型项目的研发与重构，对Go、C/C++、Python、Swift等语言均有深入的研究与实践。,"第1章　常见数据结构的实现原理
        1.1　管道
        1.1.1　热身测验
        1.1.2　特性速览
        1.1.3　实现原理
        1.2　slice
        1.2.1　热身测验
        1.2.2　特性速览
        1.2.3　实现原理
        1.2.4　切片表达式
        1.3　map
        1.3.1　热身测验
        1.3.2　特性速览
        1.3.3　实现原理
        1.4　struct
        1.4.1　热身测验
        1.4.2　内嵌字段
        1.4.3　方法受体
        1.4.4　字段标签
        1.5　iota
        1.5.1　热身测验
        1.5.2　特性速览
        1.5.3　实现原理
        1.6　string
        1.6.1　热身测验
        1.6.2　特性速览
        1.6.3　实现原理
        第2章　控制结构
        2.1　select
        2.1.1　热身测验
        2.1.2　特性速览
        2.1.3　实现原理
        2.2　for-range
        2.2.1　热身测验
        2.2.2　特性速览
        2.2.3　实现原理
        第3章　协程
        3.1　协程的概念
        3.2　调度模型
        3.3　调度策略
        第4章　内存管理
        4.1　内存分配
        4.2　垃圾回收
        4.3　逃逸分析
        第5章　并发控制
        5.1　channel
        5.2　WaitGroup
        5.3　context
        5.4　Mutex
        5.5　RWMutex
        5.5.1　读写锁的数据结构
        5.5.2　场景分析
        第6章　反射
        6.1　热身测验
        6.2　接口
        6.3　反射定律
        第7章　测试
        7.1　快速开始
        7.1.1　单元测试
        7.1.2　基准测试
        7.1.3　示例测试
        7.2　进阶测试
        7.2.1　子测试
        7.2.2　Main测试
        7.3　实现原理
        7.3.1　testing.common
        7.3.2　testing.TB接口
        7.3.3　单元测试的实现原理
        7.3.4　性能测试的实现原理
        7.3.5　示例测试的实现原理
        7.3.6　Main测试的实现原理
        7.3.7　go test的工作机制
        7.4　扩展阅读
        7.4.1　测试参数
        7.4.2　benchstat
        第8章　异常处理
        8.1　error
        8.1.1　热身测验
        8.1.2　基础error
        8.1.3　链式error
        8.1.4　工程迁移
        8.2　defer
        8.2.1　热身测验
        8.2.2　约法三章
        8.2.3　实现原理
        8.2.4　性能优化
        8.3　panic
        8.3.1　热身测验
        8.3.2　工作机制
        8.3.3　源码剖析
        8.4　recover
        8.4.1　热身测验
        8.4.2　工作机制
        8.4.3　源码剖析
        第9章　定时器
        9.1　一次性定时器（Timer）
        9.1.1　快速开始
        9.1.2　实现原理
        9.2　周期性定时器（Ticker）
        9.2.1　快速开始
        9.2.2　实现原理
        9.3　runtimeTimer
        9.3.1　实现原理
        9.3.2　性能优化
        9.4　案例分享
        第10章　语法糖
        10.1　简短变量声明符
        10.1.1　热身测验
        10.1.2　规则
        10.2　可变参函数
        第11章　版本管理
        11.1　安装Go
        11.2　删除Go
        11.3　升级Go
        11.4　Go版本管理器
        11.4.1　快速开始
        11.4.2　工作机制
        11.4.3　小结
        11.5　源码编译
        11.5.1　源码下载
        11.5.2　源码编译过程
        第12章　Go语言依赖管理
        12.1　GOPATH
        12.1.1　GOROOT是什么
        12.1.2　GOPATH是什么
        12.1.3　依赖查找
        12.1.4　GOPATH的缺点
        12.2　vendor
        12.2.1　vendor目录位置
        12.2.2　搜索顺序
        12.2.3　vendor的不足
        12.3　Go Module
        12.3.1　Go Module基础
        12.3.2　快速实践
        12.3.3　replace指令
        12.3.4　exclude指令
        12.3.5　indirect指令
        12.3.6　版本选择机制
        12.3.7　incompatible
        12.3.8　伪版本
        12.3.9　依赖包存储
        12.3.10　go.sum
        12.3.11　模块代理
        12.3.12　GOSUMDB的工作机制
        12.3.13　GOSUMDB的实现原理
        12.3.14　第三方代理
        12.3.15　私有模块
        12.3.16　Go Module的演进
        第13章　编程陷阱
        13.1　切片扩容
        13.2　空切片
        13.3　append的本质
        13.4　循环变量引用
        13.5　协程引用循环变量
        13.6　recover失效
     · · · · · ·     (收起)"
25844633,实现领域驱动设计,8.4,(416人评价),Vaughn Vernon / 滕云 / 电子工业出版社 / 2014-3 / 99.00元,领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如...,https://book.douban.com/subject/25844633/,https://img1.doubanio.com/view/subject/s/public/s29544670.jpg,99.00元,9787121224485,"领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为...(展开全部)





领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为一本DDD 参考书。",作者：Vaughn Vernon是一个经验丰富的软件工匠，在软件设计、开发和架构方面拥有超过25年的从业经验。他提倡通过创新来简化软件的设计和实现。从20世纪80年代开始，他便开始使用面向对象语言进行编程；在 20世纪 90年代早期，他便在领域建模中应用了领域驱动设计，那时他使用的是Smalltalk语言。他在很多业务领域都有从业经验，包括航空、环境、地理、保险、医学和电信等领域。同时，Vaughn在技术上也取得了很大的成功，包括开发可重用的框架和类库等。他在全球范围之内提供软件咨询和演讲，此外，他还在许多国家教授《实现领域驱动设计》的课程。你可以通过www.VaughnVernon.co访问到他的最新研究成果。他的Twitter：@VaughnVernon。,"序............... xix
        前言............. xxi
        致谢............ xxxi
        关于作者................... xxxv
        如何使用本书.........xxxvii
        第1章 DDD入门...............1
        我能DDD吗？..................2
        为什么我们需要DDD.............5
        如何DDD...................... 17
        使用DDD的业务价值..............22
        1.你获得了一个非常有用的领域模型................22
        2.你的业务得到了更准确的定义和理解............23
        3.领域专家可以为软件设计做出贡献...........23
        4.更好的用户体验....................23
        5.清晰的模型边界.....................24
        6.更好的企业架构..............24
        7.敏捷、迭代式和持续建模....................24
        8.使用战略和战术新工具........................24
        实施DDD所面临的挑战.....................25
        虚构的案例，真实的实践................... 33
        本章小结.........................36
        第2章 领域、子域和限界上下文.....................37
        总览....................... 37
        工作中的子域和限界上下文............................. 38
        将关注点放在核心域上............................. 42
        战略设计为什么重要.................... 45
        现实世界中领域和子域...................48
        理解限界上下文..................... 53
        限界上下文不仅仅只包含模型..................... 57
        限界上下文的大小...................... 59
        与技术组件保持一致................... 61
        示例上下文........................ 62
        协作上下文..................63
        身份与访问上下文..................69
        敏捷项目管理上下文................. 71
        本章小结....................................73
        第3章 上下文映射图............................75
        上下文映射图为什么重要........................ 75
        绘制上下文映射图......................77
        产品和组织关系........................79
        映射3个示例限界上下文........................82
        本章小结............................97
        第4章 架构.......................99
        采访一个成功的CIO.................... 100
        分层................................. 104
        依赖倒置原则.................... 107
        六边形架构（端口与适配器）..................... 110
        面向服务架构.......................114
        REST................................117
        REST作为一种架构风格...........................117
        RESTful HTTP服务器的关键方面 ........................................ 118
        RESTful HTTP客户端的关键方面 ........................................ 119
        REST和DDD..................... 120
        为什么是REST？......................... 121
        命令和查询职责分离——CQRS................. 121
        CQRS的各个方面........................ 123
        处理具有最终一致性的查询模型.................. 128
        事件驱动架构................... 129
        管道和过滤器..................... 131
        长时处理过程（也叫Saga）................... 134
        事件源...................... 140
        数据网织和基于网格的分布式计算....................... 143
        数据复制..................... 144
        事件驱动网织和领域事件.................. 145
        持续查询................... 145
        分布式处理...................... 146
        本章小结............................ 148
        第5章 实体......................... 149
        为什么使用实体......................... 149
        唯一标识............................ 151
        用户提供唯一标识......................... 152
        应用程序生成唯一标识........................... 153
        持久化机制生成唯一标识............................ 156
        另一个限界上下文提供唯一标识..................... 160
        标识生成时间..................... 161
        委派标识......................... 163
        标识稳定性.......................... 165
        发现实体及其本质特征............................. 167
        揭开实体及其本质特征的神秘面纱................. 168
        挖掘实体的关键行为.......................... 172
        角色和职责......................... 176
        创建实体......................... 181
        验证................................... 183
        跟踪变化............................ 192
        本章小结................................ 192
        第6章 值对象..................... 193
        值对象的特征.......................... 194
        度量或描述.......................... 195
        不变性........................... 195
        概念整体................................ 196
        可替换性.......................... 199
        值对象相等性..........................200
        无副作用行为............................. 201
        最小化集成..................204
        用值对象表示标准类型........................206
        测试值对象........................ 210
        实现.............................. 214
        持久化值对象................. 219
        拒绝由数据建模泄漏带来的不利影响..................220
        ORM与单个值对象................................ 221
        多个值对象序列化到单个列中.....................224
        使用数据库实体保存多个值对象....................225
        使用联合表保存多个值对象..........................229
        ORM与枚举状态对象........................................230
        本章小结....................... 233
        第7章 领域服务.................................235
        什么是领域服务（首先，什么不是领域服务）.................. 237
        请确定你是否需要一个领域服务................................ 238
        建模领域服务.................. 241
        独立接口有必要吗.............................244
        一个计算过程..........................246
        转换服务........................249
        为领域服务创建一个迷你层.........................250
        测试领域服务............................250
        本章小结.................. 253
        第8章 领域事件...............................255
        何时/为什么使用领域事件.......................... 255
        建模领域事件.................... 258
        创建具有聚合特征的领域事件................... 263
        身份标识............................264
        从领域模型中发布领域事件.............................. 265
        发送方................... 265
        订阅方.....................269
        向远程限界上下文发布领域事件............................. 271
        消息设施的一致性........................... 271
        自治服务和系统............................. 272
        容许时延.................. 273
        事件存储.................. 274
        转发存储事件的架构风格........................... 279
        以REST资源的方式发布事件通知....................... 279
        通过消息中间件发布事件通知.................. 283
        实现............................284
        发布NotificationLog............... 285
        发布基于消息的事件通知..............................290
        本章小结........................297
        第9章 模块................................299
        通过模块完成设计..................................299
        模块的基本命名规范..........................302
        领域模型的命名规范...........................302
        敏捷项目管理上下文中的模块..............................305
        其他层中的模块..................308
        先考虑模块，再是限界上下文...............................309
        本章小结......................... 310
        第10章 聚合...................... 311
        在Scrum核心领域中使用聚合........................ 312
        第一次尝试：臃肿的聚合....................... 313
        第二次尝试：多个聚合........................... 314
        原则：在一致性边界之内建模真正的不变条件................317
        原则：设计小聚合............................. 319
        不要相信每一个用例............................ 321
        原则：通过唯一标识引用其他聚合......................... 322
        通过标识引用使多个聚合协同工作 ...................................... 324
        建模对象导航性............................ 325
        可伸缩性和分布式............................. 326
        原则：在边界之外使用最终一致性............................. 327
        谁的任务？............................ 328
        打破原则的理由......................... 329
        理由之一：方便用户界面................................. 329
        理由之二：缺乏技术机制............................. 330
        理由之三：全局事务.......................................... 331
        理由之四：查询性能.................................. 331
        遵循原则.................... 332
        通过发现，深入理解............................... 332
        重新思考设计............................... 332
        估算聚合成本............................. 334
        常见用例场景........................ 335
        内存消耗............................ 336
        探索另外的设计................................... 337
        实现最终一致性.............................. 338
        这是Scrum团队成员的任务吗？......................... 339
        决定的时候到了.............................. 341
        实现........................................ 341
        创建具有唯一标识的根实体........................ 342
        优先使用值对象...................... 343
        使用迪米特法则和“告诉而非询问”原则 ...............344
        乐观并发...............346
        避免依赖注入................348
        本章小结................................ 349
        第11章 工厂................. 351
        领域模型中的工厂................. 351
        聚合根中的工厂方法............................. 352
        创建CalendarEntry实例................... 353
        创建Discussion实例............................ 357
        领域服务中的工厂.......................... 358
        本章小结.......................... 361
        第12章 资源库...........................363
        面向集合资源库...........................364
        Hibernate实现...................... 369
        TopLink实现.................... 377
        面向持久化资源库........................ 379
        Coherence实现............................ 381
        MongoDB实现......................... 386
        额外的行为...................................... 391
        管理事务................................. 393
        警告................................. 397
        类型层级............................... 397
        资源库 vs 数据访问对象（DAO）..............................400
        测试资源库.......................................... 401
        以内存实现进行测试...................404
        本章小结................................407
        第13章 集成限界上下文...............................409
        集成基础知识....................................409
        分布式系统之间存在根本性区别.......................411
        跨系统边界交换信息...............................411
        通过REST资源集成限界上下文......................... 417
        实现REST资源.......................... 418
        使用防腐层实现REST客户端........... 421
        通过消息集成限界上下文................ 428
        从Scrum的产品负责人和团队成员处得到持续通知 .................... 428
        你能处理这样的职责吗？..................... 434
        长时处理过程，以及避免职责............. 439
        长时处理过程的状态机和超时跟踪器 .................................. 450
        设计一个更复杂的长时处理过程 ..........................................460
        当消息机制或你的系统不可用时 ...........................................464
        本章小结.................................465
        第14章 应用程序..................467
        用户界面...................................469
        渲染领域对象............. 470
        渲染数据传输对象................... 471
        使用调停者发布聚合的内部状态 .......................................... 471
        通过领域负载对象渲染聚合实例 .......................................... 472
        聚合实例的状态展现............................. 473
        用例优化资源库查询...................... 474
        处理不同类型的客户端................... 474
        渲染适配器以及处理用户编辑............. 475
        应用服务 ............................................ 478
        示例应用服务 ................................ 478
        解耦服务输出 .....................485
        组合多个限界上下文 .....................487
        基础设施 ...............................489
        企业组件容器 ....................490
        本章小结 ....................494
        附录A 聚合与事件源：A+ES ..........................495
        应用服务内部 ....................... 496
        命令处理器 .....................505
        Lambda语法...................508
        并发控制 ....................... 510
        A+ES所带来的结构自由性 .............. 513
        性能 ............................ 513
        实现事件存储 ..................... 516
        关系型持久化 .................. 520
        BLOB持久化 ...................... 522
        专注的聚合 ............................ 523
        读模型投射 ........................... 524
        与聚合设计一道使用 ................ 527
        增强事件 ........................... 527
        工具和模式 ................... 529
        事件序列器 .......... 530
        事件不变性 ................ 531
        值对象 ..................... 531
        协议生成 .................... 534
        单元测试和需求规范 .............. 535
        事件源和函数式语言 .......... 536
        参考文献 ..................539
     · · · · · ·     (收起)"
30333919,架构整洁之道,8.7,(858人评价),【美】Robert C. Martin（罗伯特 C. 马丁） / 电子工业出版社 / 2018-9 / 99.00元,《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过...,https://book.douban.com/subject/30333919/,https://img9.doubanio.com/view/subject/s/public/s29943454.jpg,99.00元,9787121347962,"《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构...(展开全部)





《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构设计，还是软件研发管理，《架构整洁之道》都是不可或缺的。","Robert C·Martin
作者","第1部分  概述
        第1章  设计与架构究竟是什么  3
        目标是什么  4
        案例分析  5
        本章小结  11
        第2章  两个价值维度  12
        行为价值  13
        架构价值  13
        哪个价值维度更重要  14
        艾森豪威尔矩阵  15
        为好的软件架构而持续斗争  16
        第2部分  从基础构件开始：编程范式
        第3章  编程范式总览  21
        结构化编程  22
        面向对象编程  22
        函数式编程  23
        仅供思考  23
        本章小结  24
        第4章  结构化编程  25
        可推导性  26
        goto是有害的  28
        功能性降解拆分  29
        形式化证明没有发生  29
        科学来救场  29
        测试  30
        本章小结  31
        第5章  面向对象编程  32
        封装  33
        继承  36
        多态  38
        本章小结  44
        第6章  函数式编程  45
        整数平方  46
        不可变性与软件架构  47
        可变性的隔离  48
        事件溯源  49
        本章小结  51
        第3部分  设计原则
        第7章  SRP：单一职责原则  56
        反面案例2：代码合并  59
        解决方案  60
        本章小结  61
        第8章  OCP：开闭原则  62
        思想实验  63
        依赖方向的控制  67
        信息隐藏  67
        本章小结  67
        第9章  LSP：里氏替换原则  68
        继承的使用指导  69
        正方形/长方形问题  70
        LSP与软件架构  70
        违反LSP的案例  71
        本章小结  73
        第10章 ISP：接口隔离原则  74
        ISP与编程语言  76
        ISP与软件架构  76
        本章小结  77
        第11章 DIP：依赖反转原则  78
        稳定的抽象层  79
        工厂模式  80
        具体实现组件  82
        本章小结  82
        第4部分  组件构建原则
        第12章 组件  84
        组件发展史  85
        重定位技术  88
        链接器  88
        本章小结  90
        第13章 组件聚合  91
        复用/发布等同原则  92
        共同闭包原则  93
        共同复用原则  94
        组件聚合张力图  95
        本章小结  97
        第14章 组件耦合  98
        无依赖环原则  99
        自上而下的设计  105
        稳定依赖原则  106
        稳定抽象原则  112
        本章小结  117
        第5部分  软件架构
        第15章 什么是软件架构  120
        开发（Development）  122
        部署（Deployment）  123
        运行（Operation）  123
        维护（Maintenance）  124
        保持可选项  124
        设备无关性  126
        垃圾邮件  128
        物理地址寻址  129
        本章小结  130
        第16章 独立性  131
        用例  132
        运行  133
        开发  133
        部署  134
        保留可选项  134
        按层解耦  135
        用例的解耦  136
        解耦的模式  136
        开发的独立性  137
        部署的独立性  137
        重复  138
        再谈解耦模式  139
        本章小结  141
        第17章 划分边界  142
        几个悲伤的故事  143
        FitNesse  146
        应在何时、何处画这些线  148
        输入和输出怎么办  151
        插件式架构  152
        插件式架构的好处  153
        本章小结  154
        第18章 边界剖析  155
        跨边界调用  156
        令人生畏的单体结构  156
        部署层次的组件  158
        线程  159
        本地进程  159
        服务  160
        本章小结  161
        第19章 策略与层次  162
        层次（Level）  163
        本章小结  166
        第20章 业务逻辑  167
        业务实体  168
        用例  169
        请求和响应模型  171
        本章小结  172
        第21章 尖叫的软件架构  173
        架构设计的主题  174
        架构设计的核心目标  175
        那Web呢  175
        框架是工具而不是生活信条  175
        可测试的架构设计  176
        本章小结  176
        第22章 整洁架构  177
        依赖关系规则  179
        一个常见的应用场景  183
        本章小结  184
        第23章 展示器和谦卑对象  185
        谦卑对象模式  186
        展示器与视图  186
        测试与架构  187
        数据库网关  188
        数据映射器  188
        服务监听器  189
        本章小结  189
        第24章 不完全边界  190
        省掉最后一步  191
        单向边界  192
        门户模式  193
        本章小结  193
        第25章 层次与边界  194
        基于文本的冒险游戏：Hunt The Wumpus  195
        可否采用整洁架构  196
        交汇数据流  199
        数据流的分割  199
        本章小结  201
        第26章 Main组件  203
        最细节化的部分  204
        本章小结  208
        第27章 服务：宏观与微观  209
        面向服务的架构  210
        服务所带来的好处  210
        运送猫咪的难题  212
        对象化是救星  213
        基于组件的服务  215
        横跨型变更  216
        本章小结  216
        第28章 测试边界  217
        测试也是一种系统组件  218
        可测试性设计  219
        测试专用API  220
        本章小结  221
        第29章 整洁的嵌入式架构  222
        “程序适用测试”测试  225
        目标硬件瓶颈  228
        本章小结  238
        第6部分  实现细节
        第30章 数据库只是实现细节  240
        关系型数据库  241
        为什么数据库系统如此流行  242
        假设磁盘不存在会怎样  243
        实现细节  243
        但性能怎么办呢  244
        一段轶事  244
        本章小结  246
        第31章 Web是实现细节  247
        无尽的钟摆  248
        总结一下  250
        本章小结  251
        第32章 应用程序框架是实现细节  252
        框架作者  253
        单向婚姻  253
        风险  254
        解决方案  255
        不得不接受的依赖  255
        本章小结  256
        第33章 案例分析：视频销售网站  257
        产品  258
        用例分析  258
        组件架构  260
        依赖关系管理  261
        本章小结  262
        第34章 拾遗  263
        按层封装  264
        按功能封装  266
        端口和适配器  268
        按组件封装  270
        具体实现细节中的陷阱  274
        组织形式与封装的区别  275
        其他的解耦合模式  277
        本章小结：本书拾遗  279
        后序  280
        附录A  架构设计考古  283
     · · · · · ·     (收起)"
5387403,Effective C++,9.5,(1104人评价),[美] Scott Meyers / 侯捷 / 电子工业出版社 / 2011-1-1 / 65.00元,"在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。
作者高超的技术把握力、独特...",https://book.douban.com/subject/5387403/,https://img2.doubanio.com/view/subject/s/public/s4647091.jpg,65.00元,9787121123320,在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。 作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和仿效。 这本书不是读完一遍就可以束之高阁的快餐读物，也不是用以解决手边问题的参考手册，而是需要你去反复阅读体会的，C++是真正程序员的语言，背后有着精深的思想与无以伦比的表达能力，这使得它具有类似宗教般的魅力。,"侯捷
译者","译序
        中英简繁术语对照
        目录
        序言
        致谢
        导读
        1. 让自己习惯c++
        2. 构造/析构/赋值运算
        3. 资源管理
        4. 设计与声明
        5. 实现
        6. 继承与面向对象设计
        7. 模板与泛型编程
        8. 定制new和delete
        9. 杂项讨论
        a 本书之外
        b 新旧版条款对照
        索引
     · · · · · ·     (收起)"
36654266,高级算法和数据结构,9.7,(28人评价),马塞洛·拉·罗卡（Marcello La Rocca） / 肖鉴明 / 人民邮电出版社 / 2023-12 / 149.80元,这是一本关于“高级/进阶”算法和数据结构的图书，主要介绍了用于Web应用程序、系统编程和数据处理领域的各种算法，旨在让读者了解如何用这些算法应对各种棘手的编...,https://book.douban.com/subject/36654266/,https://img9.doubanio.com/view/subject/s/public/s34704215.jpg,149.80元,9787115614575,这是一本关于“高级/进阶”算法和数据结构的图书，主要介绍了用于Web应用程序、系统编程和数据处理领域的各种算法，旨在让读者了解如何用这些算法应对各种棘手的编码挑战，以及如何将其应用于具体问题，以应对新技术浪潮下的“棘手”问题。 本书对一些广为人知的基本算法进行了扩展，还介绍了用于改善优先队列、有效缓存、对数据进行集群等的技术，以期读者能针对不同编程问题选出更好的解决方案。书中示例大多辅以图解，并以不囿于特定语言的伪代码以及多种语言的代码样本加以闸释。 学完本书，读者可以了解高级算法和数据结构的相关内容，并能运用这些知识让代码具备更优性能，甚至能够独立设计数据结构，应对需要自定义解决方案的情况。 本书可作为高等院校计算机相关专业本科高年级学生以及研究生的学习用书，也可供从事与算法相关工作的开发者参考。,Marcello La Rocca现为一家电商公司的高级软件工程师，曾参与开发Twitter、微软和苹果等公司的大型Web应用程序和数据基础设施，并发明了NeatSort这一自适应排序算法。他的主要研究领域为图、算法优化、机器学习和量子计算。,"第1章　初识数据结构　1
        1.1　数据结构　2
        1.1.1　定义数据结构　2
        1.1.2　描述数据结构　3
        1.1.3　算法与数据结构有区别吗　4
        1.2　设定目标：阅读本书后的期望　4
        1.3　打包背包：数据结构与现实世界的结合　5
        1.3.1　抽象化问题　5
        1.3.2　寻找解决方案　6
        1.3.3　拯救大家的算法　7
        1.3.4　打破常规来思考问题　8
        1.3.5　完美的结局　9
        1.4　小结　9
        第一部分　改进基本数据结构
        第2章　改进优先队列：d叉堆　12
        2.1　本章结构　13
        2.2　问题：处理优先级　13
        2.3　已知解决方案：让列表保持有序　15
        2.4　描述数据结构API：优先队列　15
        2.4.1　使用优先队列　16
        2.4.2　优先级为何非常重要　17
        2.5　具体数据结构　17
        2.5.1　性能比较　18
        2.5.2　正确的具体数据结构是什么　18
        2.5.3　堆　18
        2.5.4　优先级、最小堆和最大堆　20
        2.5.5　高级变体：d叉堆　21
        2.6　如何实现堆　22
        2.6.1　向上冒泡　22
        2.6.2　向下推动　25
        2.6.3　插入　27
        2.6.4　移除顶部元素　28
        2.6.5　修改　30
        2.6.6　处理重复优先级　31
        2.6.7　堆化　32
        2.6.8　API之外的方法：包含　34
        2.6.9　性能回顾　34
        2.6.10　从伪代码到实现　35
        2.7　用例：找到最大的k个元素　35
        2.7.1　选择正确的数据结构　36
        2.7.2　正确地使用数据结构　36
        2.7.3　代码写起来　36
        2.8　更多的用例　37
        2.8.1　图中的最小距离：Dijkstra算法　37
        2.8.2　更多的图算法：Prim算法　37
        2.8.3　数据压缩：霍夫曼编码　38
        2.9　对分支因子进行分析　41
        2.9.1　是否需要d叉堆　41
        2.9.2　运行时间　42
        2.9.3　寻找最佳分支因子　42
        2.9.4　分支因子与内存的关系　43
        2.10　性能分析：寻找最佳分支因子　43
        2.10.1　剖析　44
        2.10.2　解释结果　45
        2.10.3　堆化的谜团　49
        2.10.4　选择最佳分支因子　49
        2.11　小结　50
        第3章　树堆：使用随机化来平衡二叉搜索树　52
        3.1　问题：多索引　53
        3.2　解决方案：描述与API　53
        3.3　树堆　54
        3.3.1　旋转　57
        3.3.2　一些设计问题　60
        3.3.3　实现搜索方法　61
        3.3.4　插入　61
        3.3.5　删除　64
        3.3.6　去顶、看顶以及修改　66
        3.3.7　返回最小键和最大键　67
        3.3.8　性能回顾　67
        3.4　应用：随机树堆　68
        3.4.1　平衡树　68
        3.4.2　引入随机化　70
        3.4.3　随机树堆的应用　71
        3.5　性能分析和剖析　72
        3.5.1　理论：期望高度　72
        3.5.2　剖析高度　74
        3.5.3　剖析运行时间　76
        3.5.4　剖析内存使用情况　78
        3.5.5　结论　78
        3.6　小结　80
        第4章　布隆过滤器：减少跟踪内容所需的内存　81
        4.1　字典问题：跟踪事物　82
        4.2　实现字典的其他方法　83
        4.3　描述数据结构API：关联数组　83
        4.4　具体数据结构　84
        4.4.1　无序数组：快速插入，慢速搜索　84
        4.4.2　有序数组和二分查找：慢插入，稍微快一些的搜索　85
        4.4.3　哈希表：在不需要有序的情况下，具有平均常数时间的性能　86
        4.4.4　二叉搜索树：所有操作都是对数阶的　86
        4.4.5　布隆过滤器：与哈希表一样快，但（由于一个缺陷而）更节省内存　88
        4.5　表面之下：布隆过滤器是如何工作的　88
        4.6　实现　89
        4.6.1　使用布隆过滤器　90
        4.6.2　位的读取和写入　91
        4.6.3　找到键存储的位置　92
        4.6.4　生成哈希函数　93
        4.6.5　构造函数　93
        4.6.6　查找键　94
        4.6.7　存储键　95
        4.6.8　估计准确率　96
        4.7　应用场景　97
        4.7.1　缓存　97
        4.7.2　路由　98
        4.7.3　爬虫　98
        4.7.4　I/O提取器　98
        4.7.5　拼写检查器　98
        4.7.6　分布式数据库和文件系统　99
        4.8　为什么布隆过滤器是可行的　99
        4.8.1　为什么没有假阴性　100
        4.8.2　为什么有假阳性　100
        4.8.3　作为随机算法的布隆过滤器　101
        4.9　性能分析　101
        4.9.1　运行时间　101
        4.9.2　构造函数　102
        4.9.3　存储元素　102
        4.9.4　查找元素　102
        4.10　估计布隆过滤器的精确度　102
        4.11　改进的变体　106
        4.11.1　布隆表过滤器　106
        4.11.2　组合布隆过滤器　106
        4.11.3　分层布隆过滤器　106
        4.11.4　压缩布隆过滤器　107
        4.11.5　可扩展布隆过滤器　107
        4.12　小结　108
        第5章　不交集：次线性时间的处理过程　109
        5.1　不同子集问题　110
        5.2　解决方案的论证　111
        5.3　描述数据结构API：不交集　112
        5.4　简单解决方案　113
        5.5　使用树状结构　117
        5.5.1　从链表转移到树　117
        5.5.2　实现使用树的版本　118
        5.6　改进运行时间的启发式算法　120
        5.6.1　路径压缩　121
        5.6.2　实现平衡性与路径压缩　122
        5.7　应用程序　124
        5.7.1　图：连通分量　124
        5.7.2　图：最小生成树的Kruskal算法　124
        5.7.3　聚类　125
        5.7.4　合一　126
        5.8　小结　126
        第6章　trie与基数树：高效的字符串搜索　127
        6.1　拼写检查　128
        6.1.1　拼写检查器的设计　128
        6.1.2　压缩是关键　129
        6.1.3　描述与API　129
        6.2　trie　130
        6.2.1　为什么trie更好　132
        6.2.2　搜索　134
        6.2.3　插入　137
        6.2.4　删除　139
        6.2.5　搜索最长前缀词　140
        6.2.6　返回匹配特定前缀的所有键　141
        6.2.7　什么时候应该使用trie　143
        6.3　基数树　144
        6.3.1　节点和边　146
        6.3.2　搜索　148
        6.3.3　插入　149
        6.3.4　删除　151
        6.3.5　搜索最长前缀词　153
        6.3.6　返回匹配特定前缀的所有键　153
        6.4　应用程序　154
        6.4.1　拼写检查器　154
        6.4.2　字符串相似度　156
        6.4.3　字符串排序　157
        6.4.4　T9　157
        6.4.5　自动完成　158
        6.5　小结　158
        第7章　用例：LRU缓存　160
        7.1　不要重复计算　160
        7.2　第一次尝试：记住数据　163
        7.2.1　描述与API　164
        7.2.2　请保存新数据　164
        7.2.3　处理异步调用　165
        7.2.4　将缓存的值标记为“正在加载”　166
        7.3　内存（真的）不够　167
        7.4　清除陈旧数据：LRU缓存　168
        7.4.1　有时必须要重复解决问题　169
        7.4.2　时间排序　170
        7.4.3　性能　174
        7.5　当新数据更有价值时：LFU　175
        7.5.1　如何选择缓存的清除策略　176
        7.5.2　LFU缓存有什么不同　176
        7.5.3　性能　178
        7.5.4　LFU缓存的不足　178
        7.6　如何使用缓存也同样重要　179
        7.7　同步简介　180
        7.7.1　（在Java中）解决并发问题　182
        7.7.2　锁简介　183
        7.7.3　获取锁　183
        7.7.4　重入锁　184
        7.7.5　读锁　185
        7.7.6　解决并发的其他方法　186
        7.8　缓存应用程序　186
        7.9　小结　187
        第二部分　多维查询
        第8章　最近邻搜索　190
        8.1　最近邻搜索问题　190
        8.2　解决方案　191
        8.2.1　第一次尝试　191
        8.2.2　有时缓存并不是答案　191
        8.2.3　简化事情以获得灵感　192
        8.2.4　谨慎选择数据结构　193
        8.3　描述与API　194
        8.4　迁移到k维空间　195
        8.4.1　一维二分查找　196
        8.4.2　迁移到更高维度　196
        8.4.3　用数据结构对二维空间进行建模　197
        8.5　小结　198
        第9章　k-d树：索引多维数据　199
        9.1　从结束的地方继续　199
        9.2　迁移到k维空间：循环遍历
        维度　199
        9.2.1　构造BST　201
        9.2.2　不变量　204
        9.2.3　保持平衡的重要性　204
        9.3　方法　205
        9.3.1　搜索　206
        9.3.2　插入　208
        9.3.3　平衡树　209
        9.3.4　删除　212
        9.3.5　最近邻搜索　218
        9.3.6　区域搜索　224
        9.3.7　所有方法的回顾　227
        9.4　限制与可能的改进　228
        9.5　小结　229
        第10章　相似性搜索树：图像检索的近似
        最近邻搜索　230
        10.1　从结束的地方继续　230
        10.1.1　一个新的（更复杂的）例子　231
        10.1.2　克服k-d树的缺陷　232
        10.2　R树　232
        10.2.1　先退一步：B树简介　232
        10.2.2　由B树到R树　233
        10.2.3　在R树中插入点　236
        10.2.4　搜索　237
        10.3　SS树　238
        10.3.1　搜索　241
        10.3.2　插入　244
        10.3.3　插入：方差、均值与投影　249
        10.3.4　插入：分裂节点　252
        10.3.5　删除　255
        10.4　相似性搜索　259
        10.4.1　最近邻搜索　260
        10.4.2　区域搜索　262
        10.4.3　近似相似性搜索　263
        10.5　SS+树　265
        10.5.1　SS树会更好吗　266
        10.5.2　缓解超球体的限制　267
        10.5.3　改进拆分启发式算法　267
        10.5.4　减少重叠　268
        10.6　小结　270
        第11章　最近邻搜索的应用　271
        11.1　应用程序：查找最近的枢纽　271
        11.1.1　解决方案的初稿　272
        11.1.2　天堂里的麻烦　273
        11.2　中心化应用程序　274
        11.2.1　过滤点　274
        11.2.2　复杂的决定　276
        11.3　迁移到分布式应用程序　278
        11.3.1　处理HTTP通信的问题　279
        11.3.2　保持库存同步　281
        11.3.3　经验教训　281
        11.4　其他应用程序　282
        11.4.1　色彩还原　282
        11.4.2　粒子的相互作用　283
        11.4.3　多维数据库查询的优化　285
        11.4.4　聚类　287
        11.5　小结　287
        第12章　聚类　288
        12.1　聚类简介　289
        12.1.1　机器学习的类型　289
        12.1.2　聚类的类型　290
        12.2　k均值算法　291
        12.2.1　k均值算法的问题　295
        12.2.2　维度诅咒再次来袭　296
        12.2.3　k均值算法的性能分析　297
        12.2.4　用k-d树来加快k均值算法　297
        12.2.5　关于k均值算法的最后一些提示　300
        12.3　DBSCAN算法　300
        12.3.1　直接可达与密度可达　301
        12.3.2　从定义到算法　302
        12.3.3　实现　304
        12.3.4　DBSCAN算法的优缺点　305
        12.4　OPTICS算法　307
        12.4.1　定义　308
        12.4.2　OPTICS算法的核心思想　308
        12.4.3　从可达距离到聚类　311
        12.4.4　分层聚类　314
        12.4.5　性能分析和最终的考虑　318
        12.5　评估聚类结果：评估指标　318
        12.6　小结　322
        第13章　并行聚类：MapReduce与树冠聚类　323
        13.1　并行化　323
        13.1.1　并行计算与分布式计算　324
        13.1.2　并行化k均值算法　325
        13.1.3　树冠聚类　325
        13.1.4　应用树冠聚类　327
        13.2　MapReduce　328
        13.2.1　MapReduce是如何工作的　328
        13.2.2　先映射，后归约　331
        13.2.3　表面之下，还有更多　334
        13.3　MapReduce版本的k均值算法　334
        13.3.1　并行化树冠聚类　337
        13.3.2　使用树冠聚类来进行质心的初始化　339
        13.3.3　MapReduce版本的树冠聚类　340
        13.4　MapReduce版本的DBSCAN 算法　343
        13.5　小结　348
        第三部分　平面图与最小交叉数
        第14章　图简介：寻找距离最短的
        路径　350
        14.1　定义　351
        14.1.1　图的实现　351
        14.1.2　作为代数类型的图　353
        14.1.3　伪代码　354
        14.2　图的属性　354
        14.2.1　无向　355
        14.2.2　连通　355
        14.2.3　无环　356
        14.3　图的遍历：BFS与DFS　357
        14.3.1　优化配送路线　357
        14.3.2　广度优先搜索　359
        14.3.3　重建到目标的路径　361
        14.3.4　深度优先搜索　362
        14.3.5　再次比较队列与堆栈　364
        14.3.6　投递包裹的最佳路线　365
        14.4　加权图中的最短路径：迪杰斯特拉 算法　365
        14.4.1　与BFS算法的区别　366
        14.4.2　实现　367
        14.4.3　分析　368
        14.4.4　投递包裹的最佳路线　369
        14.5　超越迪杰斯特拉算法：A*
        算法　370
        14.5.1　A*算法到底有多好　372
        14.5.2　将启发式函数作为平衡实时数据的一种方式　375
        14.6　小结　376
        第15章　图嵌入与平面性：绘制具有最少相交边的图　377
        15.1　图嵌入　378
        15.1.1　一些基础定义　379
        15.1.2　完全图与完全二分图　380
        15.2　平面图　381
        15.2.1　在实践中使用库拉托夫斯基定理　381
        15.2.2　平面性测试　382
        15.2.3　用于平面性测试的朴素算法　383
        15.2.4　提高性能　386
        15.2.5　高效的算法　388
        15.3　非平面图　389
        15.3.1　找到交叉数　391
        15.3.2　直线交叉数　392
        15.4　边的交叉点　393
        15.4.1　直线线段　394
        15.4.2　折线　397
        15.4.3　贝塞尔曲线　397
        15.4.4　二次贝塞尔曲线之间的交点　398
        15.4.5　顶点与顶点相交以及边与顶点相交　401
        15.5　小结　402
        第16章　梯度下降：（不仅是）图的优化问题　403
        16.1　用于交叉数的启发式算法　404
        16.1.1　刚才提到启发式了吗　404
        16.1.2　扩展到曲线边　408
        16.2　优化的工作原理　409
        16.2.1　成本函数　410
        16.2.2　阶跃函数与局部最小值　412
        16.2.3　优化随机抽样算法　412
        16.3　梯度下降　414
        16.3.1　梯度下降中的数学描述　415
        16.3.2　几何解释　416
        16.3.3　什么时候可以应用梯度下降　418
        16.3.4　梯度下降的问题　418
        16.4　梯度下降的应用　419
        16.5　使用梯度下降进行图嵌入　422
        16.5.1　另一种标准　423
        16.5.2　实现　425
        16.6　小结　426
        第17章　模拟退火：超越局部最小值的优化　427
        17.1　模拟退火　428
        17.1.1　有时候需要先向上爬才能到达底部　429
        17.1.2　实现　431
        17.1.3　为什么模拟退火是有效的　432
        17.1.4　短程与长程的转换　434
        17.1.5　变体　435
        17.1.6　模拟退火与梯度下降：应该选择哪一个呢　436
        17.2　模拟退火与旅行推销员　436
        17.2.1　精确解与近似解　438
        17.2.2　可视化成本　438
        17.2.3　修剪域　440
        17.2.4　状态转换　440
        17.2.5　相邻交换与随机交换　443
        17.2.6　TSP近似算法的应用　444
        17.3　模拟退火与图嵌入　444
        17.3.1　最小边交叉　445
        17.3.2　力导向绘制　446
        17.4　小结　450
        第18章　遗传算法：受生物学启发的快速收敛优化　451
        18.1　遗传算法简介　451
        18.1.1　来自大自然的灵感　453
        18.1.2　染色体　456
        18.1.3　种群　457
        18.1.4　适应度　458
        18.1.5　自然选择　459
        18.1.6　选择交配的个体　461
        18.1.7　交叉操作　466
        18.1.8　突变操作　468
        18.1.9　遗传算法模板　469
        18.1.10　遗传算法在什么时候效果最好　470
        18.2　TSP　471
        18.2.1　适应度、染色体与初始化　471
        18.2.2　突变操作　472
        18.2.3　交叉操作　472
        18.2.4　结果与参数调整　473
        18.2.5　超越TSP：优化整个车队的路线　476
        18.3　最小顶点覆盖　477
        18.3.1　顶点覆盖的应用　478
        18.3.2　实现遗传算法　478
        18.4　遗传算法的其他应用　480
        18.4.1　最大流问题　480
        18.4.2　蛋白质折叠　481
        18.4.3　超越遗传算法　482
        18.4.4　算法，超越本书　483
        18.5　小结　483
        附录A　伪代码快速指南　485
        附录B　大O符号　494
        附录C　核心数据结构　500
        附录D　类似于优先队列的容器　511
        附录E　递归　514
        附录F　分类问题与随机算法的度量指标　520
     · · · · · ·     (收起)"
30270959,深度学习入门,9.5,(1381人评价),[日］斋藤康毅 / 陆宇杰 / 人民邮电出版社 / 2018-7 / 59.00元,本书是深度学习真正意义上的入门书，深入浅出地剖析了深度学习的原理和相关技术。书中使用Python3，尽量不依赖外部库或工具，从基本的数学知识出发，带领读者从...,https://book.douban.com/subject/30270959/,https://img9.doubanio.com/view/subject/s/public/s29815955.jpg,59.00元,9787115485588,本书是深度学习真正意义上的入门书，深入浅出地剖析了深度学习的原理和相关技术。书中使用Python3，尽量不依赖外部库或工具，从基本的数学知识出发，带领读者从零创建一个经典的深度学习网络，使读者在此过程中逐步理解深度学习。书中不仅介绍了深度学习和神经网络的概念、特征等基础知识，对误差反向传播法、卷积神经网络等也有深入讲解，此外还介绍了深度学习相关的实用技巧，自动驾驶、图像生成、强化学习等方面的应用，以及为什么加深层可以提高识别精度等“为什么”的问题。,作者简介： 斋藤康毅 东京工业大学毕业，并完成东京大学研究生院课程。现从事计算机视觉与机器学习相关的研究和开发工作。是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。 译者简介： 陆宇杰 众安科技NLP算法工程师。主要研究方向为自然语言处理及其应用，对图像识别、机器学习、深度学习等领域有密切关注。Python爱好者。,"译者序　　xiii
        前言　　xv
        第1章　Python入门　　1
        1.1 Python是什么　　1
        1.2 Python的安装　　2
        1.2.1　Python版本　　2
        1.2.2　使用的外部库　　2
        1.2.3　Anaconda发行版　　3
        1.3 Python解释器　　4
        1.3.1　算术计算　　4
        1.3.2　数据类型　　5
        1.3.3　变量　　5
        1.3.4　列表　　6
        1.3.5　字典　　7
        1.3.6　布尔型　　7
        1.3.7　if 语句　　8
        1.3.8　for 语句　　8
        1.3.9　函数　　9
        1.4 Python脚本文件　　9
        1.4.1　保存为文件　　9
        1.4.2　类　　10
        1.5 NumPy　　11
        1.5.1　导入NumPy　　11
        1.5.2　生成NumPy数组　　12
        1.5.3　NumPy 的算术运算　　12
        1.5.4　NumPy的N维数组　　13
        1.5.5　广播　　14
        1.5.6　访问元素　　15
        1.6 Matplotlib　　16
        1.6.1　绘制简单图形　　16
        1.6.2　pyplot 的功能　　17
        1.6.3　显示图像　　18
        1.7 小结　　19
        第2章　感知机　　21
        2.1 感知机是什么　　21
        2.2 简单逻辑电路　　23
        2.2.1　与门　　23
        2.2.2　与非门和或门　　23
        2.3 感知机的实现　　25
        2.3.1　简单的实现　　25
        2.3.2　导入权重和偏置　　26
        2.3.3　使用权重和偏置的实现　　26
        2.4 感知机的局限性　　28
        2.4.1　异或门　　28
        2.4.2　线性和非线性　　30
        2.5 多层感知机　　31
        2.5.1　已有门电路的组合　　31
        2.5.2　异或门的实现　　33
        2.6 从与非门到计算机　　35
        2.7 小结　　36
        第3章　神经网络　　37
        3.1 从感知机到神经网络　　37
        3.1.1　神经网络的例子　　37
        3.1.2　复习感知机　　38
        3.1.3　激活函数登场　　40
        3.2 激活函数　　42
        3.2.1　sigmoid 函数　　42
        3.2.2　阶跃函数的实现　　43
        3.2.3　阶跃函数的图形　　44
        3.2.4　sigmoid 函数的实现　　45
        3.2.5　sigmoid 函数和阶跃函数的比较　　46
        3.2.6　非线性函数　　48
        3.2.7　ReLU函数　　49
        3.3 多维数组的运算　　50
        3.3.1　多维数组　　50
        3.3.2　矩阵乘法　　51
        3.3.3　神经网络的内积　　55
        3.4　　3 层神经网络的实现　　56
        3.4.1　符号确认　　57
        3.4.2　各层间信号传递的实现　　58
        3.4.3　代码实现小结　　62
        3.5 输出层的设计　　63
        3.5.1　恒等函数和softmax 函数　　64
        3.5.2　实现softmax 函数时的注意事项　　66
        3.5.3　softmax 函数的特征　　67
        3.5.4　输出层的神经元数量　　68
        3.6 手写数字识别　　69
        3.6.1　MNIST数据集　　70
        3.6.2　神经网络的推理处理　　73
        3.6.3　批处理　　75
        3.7 小结　　79
        第4章　神经网络的学习　　81
        4.1 从数据中学习　　81
        4.1.1　数据驱动　　82
        4.1.2　训练数据和测试数据　　84
        4.2 损失函数　　85
        4.2.1　均方误差　　85
        4.2.2　交叉熵误差　　87
        4.2.3　mini-batch 学习　　88
        4.2.4　mini-batch 版交叉熵误差的实现　　91
        4.2.5　为何要设定损失函数　　92
        4.3 数值微分　　94
        4.3.1　导数　　94
        4.3.2　数值微分的例子　　96
        4.3.3　偏导数　　98
        4.4 梯度　　100
        4.4.1　梯度法　　102
        4.4.2　神经网络的梯度　　106
        4.5 学习算法的实现　　109
        4.5.1　2 层神经网络的类　　110
        4.5.2　mini-batch 的实现　　114
        4.5.3　基于测试数据的评价　　116
        4.6 小结　　118
        第5章　误差反向传播法　　121
        5.1 计算图　　121
        5.1.1　用计算图求解　　122
        5.1.2　局部计算　　124
        5.1.3　为何用计算图解题　　125
        5.2 链式法则　　126
        5.2.1　计算图的反向传播　　127
        5.2.2　什么是链式法则　　127
        5.2.3　链式法则和计算图　　129
        5.3 反向传播　　130
        5.3.1　加法节点的反向传播　　130
        5.3.2　乘法节点的反向传播　　132
        5.3.3　苹果的例子　　133
        5.4 简单层的实现　　135
        5.4.1　乘法层的实现　　135
        5.4.2　加法层的实现　　137
        5.5 激活函数层的实现　　139
        5.5.1　ReLU层　　139
        5.5.2　Sigmoid 层　　141
        5.6 AffineSoftmax层的实现　　144
        5.6.1　Affine层　　144
        5.6.2　批版本的Affine层　　148
        5.6.3　Softmax-with-Loss 层　　150
        5.7 误差反向传播法的实现　　154
        5.7.1　神经网络学习的全貌图　　154
        5.7.2　对应误差反向传播法的神经网络的实现　　155
        5.7.3　误差反向传播法的梯度确认　　158
        5.7.4　使用误差反向传播法的学习　　159
        5.8 小结　　161
        第6章　与学习相关的技巧　　163
        6.1 参数的更新　　163
        6.1.1　探险家的故事　　164
        6.1.2　SGD　　164
        6.1.3　SGD的缺点　　166
        6.1.4　Momentum　　168
        6.1.5　AdaGrad　　170
        6.1.6　Adam　　172
        6.1.7　使用哪种更新方法呢　　174
        6.1.8　基于MNIST数据集的更新方法的比较　　175
        6.2 权重的初始值　　176
        6.2.1　可以将权重初始值设为0 吗　　176
        6.2.2　隐藏层的激活值的分布　　177
        6.2.3　ReLU的权重初始值　　181
        6.2.4　基于MNIST数据集的权重初始值的比较　　183
        6.3 Batch Normalization　　184
        6.3.1　Batch Normalization 的算法　　184
        6.3.2　Batch Normalization 的评估　　186
        6.4 正则化　　188
        6.4.1　过拟合　　189
        6.4.2　权值衰减　　191
        6.4.3　Dropout　　192
        6.5 超参数的验证　　195
        6.5.1　验证数据　　195
        6.5.2　超参数的最优化　　196
        6.5.3　超参数最优化的实现　　198
        6.6 小结　　200
        第7章　卷积神经网络　　201
        7.1 整体结构　　201
        7.2 卷积层　　202
        7.2.1　全连接层存在的问题　　203
        7.2.2　卷积运算　　203
        7.2.3　填充　　206
        7.2.4　步幅　　207
        7.2.5　3 维数据的卷积运算　　209
        7.2.6　结合方块思考　　211
        7.2.7　批处理　　213
        7.3 池化层　　214
        7.4 卷积层和池化层的实现　　216
        7.4.1　4 维数组　　216
        7.4.2　基于im2col 的展开　　217
        7.4.3　卷积层的实现　　219
        7.4.4　池化层的实现　　222
        7.5 CNN的实现　　224
        7.6 CNN的可视化　　228
        7.6.1　第1 层权重的可视化　　228
        7.6.2　基于分层结构的信息提取　　230
        7.7 具有代表性的CNN　　231
        7.7.1　LeNet　　231
        7.7.2　AlexNet　　232
        7.8 小结　　233
        第8章　深度学习　　235
        8.1 加深网络　　235
        8.1.1　向更深的网络出发　　235
        8.1.2　进一步提高识别精度　　238
        8.1.3　加深层的动机　　240
        8.2 深度学习的小历史　　242
        8.2.1　ImageNet　　243
        8.2.2　VGG　　244
        8.2.3　GoogLeNet　　245
        8.2.4　ResNet　　246
        8.3 深度学习的高速化　　248
        8.3.1　需要努力解决的问题　　248
        8.3.2　基于GPU的高速化　　249
        8.3.3　分布式学习　　250
        8.3.4　运算精度的位数缩减　　252
        8.4 深度学习的应用案例　　253
        8.4.1　物体检测　　253
        8.4.2　图像分割　　255
        8.4.3　图像标题的生成　　256
        8.5 深度学习的未来　　258
        8.5.1　图像风格变换　　258
        8.5.2　图像的生成　　259
        8.5.3　自动驾驶　　261
        8.5.4　Deep Q-Network（强化学习）　　262
        8.6 小结　　264
        附录A　Softmax-with-Loss 层的计算图　　267
        A.1 正向传播　　268
        A.2 反向传播　　270
        A.3 小结　　277
        参考文献　　279
     · · · · · ·     (收起)"
36547630,Rust程序设计（第2版）,9.3,(33人评价),[美]吉姆·布兰迪（Jim Blandy）、[美]贾森 • 奥伦多夫（Jason Orendorff）、[美]莉奥诺拉 • F. S. 廷德尔（Leonora F. S. Tindall） / 汪志成（@雪狼） / 人民邮电出版社 / 2023-9-5 / 179.8元,"本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。
书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的...",https://book.douban.com/subject/36547630/,https://img3.doubanio.com/view/subject/s/public/s34641512.jpg,179.8元,9787115621818,"本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。 书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的高性能，并大大简化了并发程序的编写。第2版对上一版内容进行了重组和完善，新增了对“异步编程”的介绍。借助书中的大量案例，你也能用Rust编写出兼顾安全性与高性能的程序。本书内容包括基本数据类型、所有权、引用、表达式、错误处理、crate与模块、结构、枚举与模式等基础知识，以及特型与泛型、闭包、迭代器、集合、字符串与文本、输入与输出、并发、异步编程、宏等进阶知识。 编辑推荐 1.【内容全面】Rust一本就通，涉及Rust所有关键特性 2.【代码开源】基于Rust 2021大版本，开源示例代码 3.【实战性强】讲解深入浅出，含大量案例，实践性强 4.【作译者资深】Mozilla创始团员编写，雪狼翻译 ...(展开全部)





本书是Rust领域经典参考书，由业内资深系统程序员编写，广受读者好评。 书中全面介绍了Rust这种新型系统编程语言——具有无与伦比的安全性，兼具C和C++的高性能，并大大简化了并发程序的编写。第2版对上一版内容进行了重组和完善，新增了对“异步编程”的介绍。借助书中的大量案例，你也能用Rust编写出兼顾安全性与高性能的程序。本书内容包括基本数据类型、所有权、引用、表达式、错误处理、crate与模块、结构、枚举与模式等基础知识，以及特型与泛型、闭包、迭代器、集合、字符串与文本、输入与输出、并发、异步编程、宏等进阶知识。 编辑推荐 1.【内容全面】Rust一本就通，涉及Rust所有关键特性 2.【代码开源】基于Rust 2021大版本，开源示例代码 3.【实战性强】讲解深入浅出，含大量案例，实践性强 4.【作译者资深】Mozilla创始团员编写，雪狼翻译 5.【专家推荐】陈天、唐刚、王旭、张汉东、张炎泼 6.【超强品控】30位一线Rust开发者与爱好者精心审读",吉姆·布兰迪（Jim Blandy），Mozilla Firefox工程师，Subversion版本控制系统最初设计者之一。拥有40多年编程经验，其中包括30多年自由软件开发经验，曾在GNU Emacs、GNU Debugger等项目上工作。 贾森·奥伦多夫（Jason Orendorff），GitHub工程师，专注开发尚未公开的Rust项目，曾在Mozilla参与JavaScript引擎SpiderMonkey的开发。兴趣广泛，包括：语法学、烘焙、时间旅行，以及帮助人们理解复杂主题。 莉奥诺拉·F. S. 廷德尔（Leonora F. S. Tindall），软件工程师、类型系统爱好者。她喜欢使用Rust等先进语言在一些关键领域构建健壮且适应性强的系统软件，特别是在医疗保健和数据所有权管理等领域。,"目录
        专家推荐
        译者序
        前言
        中文版审读致谢
        第 1章　系统程序员也能享受美好 1
        1.1　Rust为你负重前行 2
        1.2　高效并行编程 3
        1.3　性能毫不妥协 3
        1.4　协作无边无界 4
        第 2章　Rust导览 5
        2.1　rustup与Cargo 6
        2.2　Rust函数 8
        2.3　编写与运行单元测试 9
        2.4　处理命令行参数 10
        2.5　搭建Web服务器 13
        2.6　并发 18
        2.6.1　什么是曼德博集 19
        2.6.2　解析并配对命令行参数 22
        2.6.3　从像素到复数的映射 24
        2.6.4　绘制曼德博集 25
        2.6.5　写入图像文件 26
        2.6.6　并发版曼德博程序 27
        2.6.7　运行曼德博绘图器 32
        2.6.8　大“安”无形 33
        2.7　文件系统与命令行工具 33
        2.7.1　命令行界面 34
        2.7.2　读写文件 36
        2.7.3　查找并替换 37
        第3章　基本数据类型 39
        3.1　固定宽度的数值类型 41
        3.1.1　整型 42
        3.1.2　检查算法、回绕算法、饱和算法和溢出算法 45
        3.1.3　浮点类型 46
        3.2　布尔类型 48
        3.3　字符 49
        3.4　元组 50
        3.5　指针类型 51
        3.5.1　引用 52
        3.5.2　Box 52
        3.5.3　裸指针 53
        3.6　数组、向量和切片 53
        3.6.1　数组 53
        3.6.2　向量 54
        3.6.3　切片 57
        3.7　字符串类型 58
        3.7.1　字符串字面量 58
        3.7.2　字节串 59
        3.7.3　内存中的字符串 60
        3.7.4　String 61
        3.7.5　使用字符串 62
        3.7.6　其他类似字符串的类型 62
        3.8　类型别名 63
        3.9　前路展望 63
        第4章　所有权与移动 64
        4.1　所有权 65
        4.2　移动 70
        4.2.1　更多移动类操作 74
        4.2.2　移动与控制流 75
        4.2.3　移动与索引内容 75
        4.3　Copy类型：关于移动的例外情况 77
        4.4　Rc与Arc：共享所有权 80
        第5章　引用 83
        5.1　对值的引用 84
        5.2　使用引用 86
        5.2.1　Rust引用与C++引用 87
        5.2.2　对引用变量赋值 88
        5.2.3　对引用进行引用 88
        5.2.4　比较引用 89
        5.2.5　引用永不为空 89
        5.2.6　借用任意表达式结果值的引用 89
        5.2.7　对切片和特型对象的引用 90
        5.3　引用安全 90
        5.3.1　借用局部变量 91
        5.3.2　将引用作为函数参数 93
        5.3.3　把引用传给函数 95
        5.3.4　返回引用 95
        5.3.5　包含引用的结构体 96
        5.3.6　不同的生命周期参数 98
        5.3.7　省略生命周期参数 100
        5.4　共享与可变 101
        5.5　应对复杂对象关系 107
        第6章　表达式 109
        6.1　表达式语言 109
        6.2　优先级与结合性 110
        6.3　块与分号 112
        6.4　声明 113
        6.5　if与match 115
        6.5.1　if let 117
        6.5.2　循环 117
        6.6　循环中的控制流 119
        6.7　return表达式 120
        6.8　为什么Rust中会有loop 121
        6.9　函数与方法调用 122
        6.10　字段与元素 123
        6.11　引用运算符 124
        6.12　算术运算符、按位运算符、比较运算符和逻辑运算符 125
        6.13　赋值 125
        6.14　类型转换 126
        6.15　闭包 127
        6.16　前路展望 127
        第7章　错误处理 128
        7.1　panic 128
        7.1.1　展开调用栈 129
        7.1.2　中止 130
        7.2　Result 130
        7.2.1　捕获错误 131
        7.2.2　Result类型别名 132
        7.2.3　打印错误 132
        7.2.4　传播错误 134
        7.2.5　处理多种Error类型 135
        7.2.6　处理“不可能发生”的错误 136
        7.2.7　忽略错误 138
        7.2.8　处理main()中的错误 138
        7.2.9　声明自定义错误类型 139
        7.2.10　为什么是Result 140
        第8章　crate与模块 141
        8.1　crate 141
        8.1.1　版本 144
        8.1.2　创建配置文件 145
        8.2　模块 145
        8.2.1　嵌套模块 146
        8.2.2　单独文件中的模块 147
        8.2.3　路径与导入 149
        8.2.4　标准库预导入 152
        8.2.5　公开use声明 152
        8.2.6　公开结构体字段 152
        8.2.7　静态变量与常量 153
        8.3　将程序变成库 153
        8.4　src/bin目录 155
        8.5　属性 156
        8.6　测试与文档 158
        8.6.1　集成测试 161
        8.6.2　文档 161
        8.6.3　文档测试 163
        8.7　指定依赖项 166
        8.7.1　版本 166
        8.7.2　Cargo.lock 167
        8.8　将crate发布到crates.io 168
        8.9　工作空间 170
        8.10　更多好资源 170
        第9章　结构体 172
        9.1　具名字段型结构体 172
        9.2　元组型结构体 175
        9.3　单元型结构体 175
        9.4　结构体布局 176
        9.5　用impl定义方法 177
        9.5.1　以Box、Rc或Arc形式传入self 179
        9.5.2　类型关联函数 179
        9.6　关联常量 180
        9.7　泛型结构体 181
        9.8　带生命周期参数的泛型结构体 183
        9.9　带常量参数的泛型结构体 183
        9.10　让结构体类型派生自某些公共特型 185
        9.11　内部可变性 186
        第 10章　枚举与模式 190
        10.1　枚举 191
        10.1.1　带数据的枚举 193
        10.1.2　内存中的枚举 194
        10.1.3　用枚举表示富数据结构 194
        10.1.4　泛型枚举 196
        10.2　模式 198
        10.2.1　模式中的字面量、变量和通配符 201
        10.2.2　元组型模式与结构体型模式 202
        10.2.3　数组型模式与切片型模式 203
        10.2.4　引用型模式 204
        10.2.5　匹配守卫 206
        10.2.6　匹配多种可能性 206
        10.2.7　使用@模式绑定 207
        10.2.8　模式能用在哪里 207
        10.2.9　填充二叉树 209
        10.3　大局观 210
        第 11章　特型与泛型 211
        11.1　使用特型 213
        11.1.1　特型对象 214
        11.1.2　泛型函数与类型参数 215
        11.1.3　使用哪一个 219
        11.2　定义与实现特型 220
        11.2.1　默认方法 221
        11.2.2　特型与其他人的类型 222
        11.2.3　特型中的Self 224
        11.2.4　子特型 225
        11.2.5　类型关联函数 226
        11.3　完全限定的方法调用 227
        11.4　定义类型之间关系的特型 228
        11.4.1　关联类型（或迭代器的工作原理） 229
        11.4.2　泛型特型（或运算符重载的工作原理） 231
        11.4.3　impl Trait 232
        11.4.4　关联常量 234
        11.5　逆向工程求限界 235
        11.6　以特型为基础 238
        第 12章　运算符重载 239
        12.1　算术运算符与按位运算符 240
        12.1.1　一元运算符 242
        12.1.2　二元运算符 243
        12.1.3　复合赋值运算符 244
        12.2　相等性比较 245
        12.3　有序比较 247
        12.4　Index与IndexMut 250
        12.5　其他运算符 252
        第 13章　实用工具特型 253
        13.1　Drop 254
        13.2　Sized 256
        13.3　Clone 259
        13.4　Copy 260
        13.5　Deref与DerefMut 260
        13.6　Default 263
        13.7　AsRef与AsMut 264
        13.8　Borrow与BorrowMut 266
        13.9　From与Into 267
        13.10　TryFrom与TryInto 270
        13.11　ToOwned 271
        13.12　Borrow与ToOwned的实际运用：谦卑的Cow 271
        第 14章　闭包 273
        14.1　捕获变量 274
        14.1.1　借用值的闭包 275
        14.1.2　“窃取”值的闭包 275
        14.2　函数与闭包的类型 277
        14.3　闭包性能 279
        14.4　闭包与安全 280
        14.4.1　“杀死”闭包 280
        14.4.2　FnOnce 281
        14.4.3　FnMut 282
        14.4.4　对闭包的Copy与Clone 284
        14.5　回调 285
        14.6　高效地使用闭包 288
        第 15章　迭代器 290
        15.1　Iterator特型与IntoIterator特型 291
        15.2　创建迭代器 292
        15.2.1　iter方法与iter_mut方法 293
        15.2.2　IntoIterator的实现 293
        15.2.3　from_fn与successors 295
        15.2.4　drain方法 296
        15.2.5　其他迭代器源 297
        15.3　迭代器适配器 298
        15.3.1　map与filter 298
        15.3.2　filter_map与flat_map 300
        15.3.3　flatten 302
        15.3.4　take与take_while 304
        15.3.5　skip与skip_while 305
        15.3.6　peekable 305
        15.3.7　fuse 306
        15.3.8　可逆迭代器与rev 307
        15.3.9　inspect 308
        15.3.10　chain 309
        15.3.11　enumerate 309
        15.3.12　zip 310
        15.3.13　by_ref 310
        15.3.14　cloned与copied 311
        15.3.15　cycle 312
        15.4　消耗迭代器 313
        15.4.1　简单累加：count、sum和product 313
        15.4.2　min与max 313
        15.4.3　max_by与min_by 314
        15.4.4　max_by_key与min_by_key 314
        15.4.5　对条目序列进行比较 315
        15.4.6　any与all 315
        15.4.7　position、rposition和ExactSizeIterator 316
        15.4.8　fold与rfold 316
        15.4.9　try_fold与try_rfold 317
        15.4.10　nth与nth_back 318
        15.4.11　last 319
        15.4.12　find、rfind和find_map 319
        15.4.13　构建集合：collect与FromIterator 320
        15.4.14　Extend特型 322
        15.4.15　partition 322
        15.4.16　for_each与try_for_each 323
        15.5　实现自己的迭代器 324
        第 16章　集合 328
        16.1　概述 329
        16.2　Vec&lt;T> 330
        16.2.1　访问元素 331
        16.2.2　迭代 332
        16.2.3　扩大向量与收缩向量 332
        16.2.4　联结 336
        16.2.5　拆分 336
        16.2.6　交换 339
        16.2.7　填充 339
        16.2.8　排序与搜索 339
        16.2.9　比较切片 341
        16.2.10　随机元素 341
        16.2.11　Rust中不存在失效型错误 342
        16.3　VecDeque&lt;T> 343
        16.4　BinaryHeap&lt;T> 344
        16.5　HashMap&lt;K, V>与BTreeMap&lt;K, V> 346
        16.5.1　条目 349
        16.5.2　对Map进行迭代 351
        16.6　HashSet&lt;T>与BTreeSet&lt;T> 351
        16.6.1　对Set进行迭代 352
        16.6.2　当相等的值不完全相同时 353
        16.6.3　针对整个Set的运算 353
        16.7　哈希 354
        16.8　使用自定义哈希算法 355
        16.9　在标准集合之外 357
        第 17章　字符串与文本 358
        17.1　一些Unicode背景知识 358
        17.1.1　ASCII、Latin-1和Unicode 359
        17.1.2　UTF-8编码 359
        17.1.3　文本方向性 361
        17.2　字符（char） 361
        17.2.1　字符分类 361
        17.2.2　处理数字 362
        17.2.3　字符大小写转换 363
        17.2.4　与整数之间的转换 364
        17.3　String与str 364
        17.3.1　创建字符串值 365
        17.3.2　简单探查 366
        17.3.3　追加文本与插入文本 366
        17.3.4　移除文本与替换文本 368
        17.3.5　搜索与迭代的约定 368
        17.3.6　搜索文本的模式 369
        17.3.7　搜索与替换 370
        17.3.8　遍历文本 371
        17.3.9　修剪 373
        17.3.10　字符串的大小写转换 374
        17.3.11　从字符串中解析出其他类型 374
        17.3.12　将其他类型转换为字符串 374
        17.3.13　借用其他类似文本的类型 375
        17.3.14　以UTF-8格式访问文本 376
        17.3.15　从UTF-8数据生成文本 376
        17.3.16　推迟分配 377
        17.3.17　把字符串当作泛型集合 379
        17.4　格式化各种值 379
        17.4.1　格式化文本值 380
        17.4.2　格式化数值 381
        17.4.3　格式化其他类型 383
        17.4.4　格式化值以进行调试 383
        17.4.5　格式化指针以进行调试 384
        17.4.6　按索引或名称引用参数 385
        17.4.7　动态宽度与动态精度 386
        17.4.8　格式化自己的类型 386
        17.4.9　在自己的代码中使用格式化语言 388
        17.5　正则表达式 389
        17.5.1　Regex的基本用法 389
        17.5.2　惰性构建正则表达式值 390
        17.6　规范化 391
        17.6.1　规范化形式 392
        17.6.2　unicode-normalization crate 393
        第 18章　输入与输出 395
        18.1　读取器与写入器 396
        18.1.1　读取器 397
        18.1.2　缓冲读取器 398
        18.1.3　读取行 399
        18.1.4　收集行 401
        18.1.5　写入器 402
        18.1.6　文件 403
        18.1.7　寻址 404
        18.1.8　其他读取器与写入器类型 404
        18.1.9　二进制数据、压缩和序列化 406
        18.2　文件与目录 407
        18.2.1　OsStr与Path 408
        18.2.2　Path与PathBuf的方法 409
        18.2.3　访问文件系统的函数 411
        18.2.4　读取目录 412
        18.2.5　特定于平台的特性 413
        18.3　网络 414
        第 19章　并发 417
        19.1　分叉与合并并行 418
        19.1.1　启动与联结 420
        19.1.2　跨线程错误处理 422
        19.1.3　跨线程共享不可变数据 422
        19.1.4　rayon 424
        19.1.5　重温曼德博集 426
        19.2　通道 427
        19.2.1　发送值 429
        19.2.2　接收值 431
        19.2.3　运行管道 432
        19.2.4　通道的特性与性能 434
        19.2.5　线程安全：Send与Sync 435
        19.2.6　绝大多数迭代器能通过管道传给通道 437
        19.2.7　除管道之外的用法 438
        19.3　共享可变状态 439
        19.3.1　什么是互斥锁 439
        19.3.2　Mutex&lt;T> 440
        19.3.3　mut与互斥锁 442
        19.3.4　为什么互斥锁不是“银弹” 443
        19.3.5　死锁 443
        19.3.6　“中毒”的互斥锁 444
        19.3.7　使用互斥锁的多消费者通道 444
        19.3.8　读/写锁（RwLock&lt;T>） 445
        19.3.9　条件变量（Condvar） 446
        19.3.10　原子化类型 447
        19.3.11　全局变量 448
        19.4　在Rust中编写并发代码的一点儿经验 451
        第 20章　异步编程 452
        20.1　从同步到异步 453
        20.1.1　Future 455
        20.1.2　异步函数与await表达式 456
        20.1.3　从同步代码调用异步函数：block_on 458
        20.1.4　启动异步任务 460
        20.1.5　异步块 464
        20.1.6　从异步块构建异步函数 466
        20.1.7　在线程池中启动异步任务 467
        20.1.8　你的Future实现Send了吗 467
        20.1.9　长时间运行的计算：yield_now与spawn_blocking 470
        20.1.10　对几种异步设计进行比较 471
        20.1.11　一个真正的异步HTTP客户端 471
        20.2　异步客户端与服务器 472
        20.2.1　Error类型与Result类型 474
        20.2.2　协议 474
        20.2.3　获取用户输入：异步流 475
        20.2.4　发送数据包 477
        20.2.5　接收数据包：更多异步流 478
        20.2.6　客户端的main函数 480
        20.2.7　服务器的main函数 481
        20.2.8　处理聊天连接：异步互斥锁 482
        20.2.9　群组表：同步互斥锁 484
        20.2.10　聊天组：tokio的广播通道 485
        20.3　原始Future与执行器：Future什么时候值得再次轮询 488
        20.3.1　调用唤醒器：spawn_blocking 489
        20.3.2　实现block_on 491
        20.4　固定（Pin） 493
        20.4.1　Future生命周期的两个阶段 493
        20.4.2　固定指针 496
        20.4.3　Unpin特型 497
        20.5　什么时候要用异步代码 498
        第 21章　宏 500
        21.1　宏基础 501
        21.1.1　宏展开的基础 502
        21.1.2　意外后果 503
        21.1.3　重复 505
        21.2　内置宏 507
        21.3　调试宏 508
        21.4　构建json!宏 509
        21.4.1　片段类型 510
        21.4.2　宏中的递归 513
        21.4.3　将特型与宏一起使用 514
        21.4.4　作用域界定与卫生宏 516
        21.4.5　导入宏和导出宏 518
        21.5　在匹配过程中避免语法错误 519
        21.6　超越macro_rules! 520
        第 22章　不安全代码 522
        22.1　不安全因素来自哪里 523
        22.2　不安全块 524
        22.3　示例：高效的ASCII字符串类型 525
        22.4　不安全函数 527
        22.5　不安全块还是不安全函数 528
        22.6　未定义行为 529
        22.7　不安全特型 531
        22.8　裸指针 532
        22.8.1　安全地解引用裸指针 534
        22.8.2　示例：RefWithFlag 535
        22.8.3　可空指针 537
        22.8.4　类型大小与对齐方式 537
        22.8.5　指针运算 538
        22.8.6　移动入和移动出内存 539
        22.8.7　示例：GapBuffer 542
        22.8.8　不安全代码中的panic安全性 548
        22.9　用联合体重新解释内存 549
        22.10　匹配联合体 551
        22.11　借用联合体 551
        第 23章　外部函数 552
        23.1　寻找共同的数据表示 552
        23.2　声明外部函数与变量 556
        23.3　使用库中的函数 557
        23.4　libgit2的裸接口 560
        23.5　libgit2的安全接口 566
        23.6　结论 575
        作者介绍 576
        封面介绍 576
     · · · · · ·     (收起)"
36457109,程序员的README,8.6,(95人评价),[美] 克里斯·里科米尼（Chris Riccomini）、[美] 德米特里·里亚博伊（Dmitriy Ryaboy） / 付裕 / 人民邮电出版社 / 2023-7-10 / 79.8,对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填...,https://book.douban.com/subject/36457109/,https://img9.doubanio.com/view/subject/s/public/s34570616.jpg,79.8,9787115599438,"对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新...(展开全部)





对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新入行的工程师在开始工作之前都能阅读的书。","付裕
译者","第1 章 前面的旅程 1
        1.1 你的目的地 1
        1.2 你的旅程地图 2
        1.2.1 新手营 3
        1.2.2 试炼之河 5
        1.2.3 贡献者之角 5
        1.2.4 运维之海 6
        1.2.5 胜任之湾 6
        1.3 前进！ 7
        第2 章 步入自觉阶段 8
        2.1 学习如何学习 9
        2.1.1 前置学习 9
        2.1.2 在实践中学习 9
        2.1.3 运行实例代码 11
        2.1.4 阅读 11
        2.1.5 观看讲座 13
        2.1.6 适度地参加会议和聚会 14
        2.1.7 跟班学习并同有经验的工程师结对 15
        2.1.8 用副业项目实践 16
        2.2 提出问题 17
        2.2.1 动手调查一下 17
        2.2.2 设置一个时间限制 17
        2.2.3 写下全过程 18
        2.2.4 别打扰别人 19
        2.2.5 多用“非打扰式”交流 20
        2.2.6 批量处理你的同步请求 20
        2.3 克服成长的障碍 21
        2.3.1 冒充者综合征 21
        2.3.2 邓宁-克鲁格效应 22
        2.4 行为准则 23
        2.5 升级加油站 23
        第3 章 玩转代码 25
        3.1 软件的熵 26
        3.2 技术债 26
        3.3 变更代码 29
        3.3.1 善于利用现有代码 30
        3.3.2 过手的代码要比之前更干净 32
        3.3.3 做渐变式的修改 33
        3.3.4 对重构要务实 33
        3.3.5 善用IDE 34
        3.3.6 请使用VCS 的最佳实践 34
        3.4 避“坑”指南 35
        3.4.1 保守一些的技术选型 36
        3.4.2 不要特立独行 39
        3.4.3 不要只分叉而不向上游提交修改 40
        3.4.4 克制重构的冲动 40
        3.5 行为准则 42
        3.6 升级加油站 42
        第4 章 编写可维护的代码 44
        4.1 防御式编程 45
        4.1.1 避免空值 45
        4.1.2 保持变量不可变 46
        4.1.3 使用类型提示和静态类型检查器 46
        4.1.4 验证输入 47
        4.1.5 善用异常 49
        4.1.6 异常要有精确含义 50
        4.1.7 早抛晚捕 51
        4.1.8 智能重试 52
        4.1.9 构建幂等系统 53
        4.1.10 及时释放资源 53
        4.2 关于日志的使用 54
        4.2.1 给日志分级 55
        4.2.2 日志的原子性 56
        4.2.3 关注日志性能 57
        4.2.4 不要记录敏感数据 59
        4.3 系统监控 59
        4.3.1 使用标准的监控组件 60
        4.3.2 测量一切 63
        4.4 跟踪器 64
        4.5 配置相关注意事项 64
        4.5.1 配置无须新花样 65
        4.5.2 记录并校验所有的配置 66
        4.5.3 提供默认值 67
        4.5.4 给配置分组 67
        4.5.5 将配置视为代码 67
        4.5.6 保持配置文件清爽 68
        4.5.7 不要编辑已经部署的配置 68
        4.6 工具集 68
        4.7 行为准则 70
        4.8 升级加油站 71
        第5 章 依赖管理 72
        5.1 依赖管理基础知识 73
        5.1.1 语义化版本 74
        5.1.2 传递依赖 75
        5.2 相依性地狱 76
        5.3 避免相依性地狱 80
        5.3.1 隔离依赖项 80
        5.3.2 按需添加依赖项 81
        5.3.3 指定依赖项的版本 82
        5.3.4 依赖范围最小化 84
        5.3.5 保护自己免受循环依赖的影响 84
        5.4 行为准则 85
        5.5 升级加油站 85
        第6 章 测试 87
        6.1 测试的多种用途 87
        6.2 测试类型 88
        6.3 测试工具 91
        6.3.1 模拟库 91
        6.3.2 测试框架 92
        6.3.3 代码质量工具 93
        6.4 自己动手编写测试 95
        6.4.1 编写干净的测试 95
        6.4.2 避免过度测试 96
        6.5 测试中的确定性 98
        6.5.1 种子随机数生成器 99
        6.5.2 不要在单元测试中调用远程系统 99
        6.5.3 采用注入式时间戳 99
        6.5.4 避免使用休眠和超时 102
        6.5.5 记得关闭网络套接字和文件句柄 102
        6.5.6 绑定到0 端口 103
        6.5.7 生成唯一的文件路径和数据库位置 103
        6.5.8 隔离并清理剩余的测试状态 103
        6.5.9 不要依赖测试顺序 104
        6.6 行为准则 105
        6.7 升级加油站 105
        第7 章 代码评审 107
        7.1 为什么需要评审代码? 107
        7.2 当你的代码被评审时 109
        7.2.1 准备工作 109
        7.2.2 用评审草案降低风险 110
        7.2.3 提交评审请勿触发测试 111
        7.2.4 预排大体量的代码修改 111
        7.2.5 不要太在意 112
        7.2.6 保持同理心，但不要容忍粗鲁 113
        7.2.7 保持主动 113
        7.3 评审别人的代码时 114
        7.3.1 分流评审请求 114
        7.3.2 给评审预留时间 114
        7.3.3 理解修改的意图 115
        7.3.4 提供全面的反馈 115
        7.3.5 要承认优点 116
        7.3.6 区分问题、建议和挑剔 116
        7.3.7 不要只做橡皮图章 117
        7.3.8 不要只局限于使用网页版的评审工具 118
        7.3.9 不要忘记评审测试代码 118
        7.3.10 推动决断 118
        7.4 行为准则 119
        7.5 升级加油站 120
        第8 章 软件交付 121
        8.1 软件交付流程 121
        8.2 分支策略 122
        8.3 构建环节 125
        8.3.1 打包需要带版本号 126
        8.3.2 将不同的资源单独打包 127
        8.4 发布环节 129
        8.4.1 请勿只想着发布 129
        8.4.2 将包发布到仓库 130
        8.4.3 保持版本不变性 131
        8.4.4 频繁发布 131
        8.4.5 对发布计划保持透明 132
        8.4.6 撰写变更日志和发行说明 132
        8.5 部署环节 133
        8.5.1 自动部署 133
        8.5.2 部署的原子性 134
        8.5.3 独立地部署应用 134
        8.6 展开环节 136
        8.6.1 系统监控 137
        8.6.2 特性开关 137
        8.6.3 熔断器 138
        8.6.4 并行的服务版本梯队 139
        8.6.5 摸黑启动 141
        8.7 行为准则 143
        8.8 升级加油站 144
        第9 章 On-Call 146
        9.1 On-Call 的工作方式 147
        9.2 On-Call 技能包 148
        9.2.1 随时响应 148
        9.2.2 保持专注 148
        9.2.3 确定工作优先级 149
        9.2.4 清晰的沟通 150
        9.2.5 跟踪你的工作 151
        9.3 事故处理 152
        9.3.1 分流 153
        9.3.2 协同 154
        9.3.3 应急方案 155
        9.3.4 解决方案 157
        9.3.5 后续行动 159
        9.4 提供支持 162
        9.5 不要逞英雄 164
        9.6 行为准则 165
        9.7 升级加油站 165
        第10 章 技术设计流程 167
        10.1 技术设计的V 形结构 168
        10.2 关于设计的思考 169
        10.2.1 定义问题 170
        10.2.2 着手调查 171
        10.2.3 进行实验 172
        10.2.4 给些时间 173
        10.3 撰写设计文档 174
        10.3.1 文档持续变更 174
        10.3.2 了解撰写文档的目的 175
        10.3.3 学会写作 176
        10.3.4 保证文档是最新的 176
        10.4 使用设计文档模板 177
        10.4.1 概要 178
        10.4.2 现状与背景 178
        10.4.3 变更的目的 178
        10.4.4 需求 179
        10.4.5 潜在的解决方案 179
        10.4.6 建议的解决方案 180
        10.4.7 设计与架构 180
        10.4.8 测试计划 181
        10.4.9 发布计划 181
        10.4.10 遗留的问题 181
        10.4.11 附录 181
        10.5 协作设计 182
        10.5.1 理解你的团队的设计评审流程 182
        10.5.2 不要让人惊讶 183
        10.5.3 用设计讨论来进行头脑风暴 183
        10.5.4 为设计出力 184
        10.6 行为准则 185
        10.7 升级加油站 185
        第11 章 构建可演进的架构 187
        11.1 理解复杂性 188
        11.2 可演进的设计 189
        11.2.1 你不是真的需要 189
        11.2.2 最小惊讶原则 191
        11.2.3 封装专业领域知识 193
        11.3 可演进的API 193
        11.3.1 保持API 小巧 194
        11.3.2 公开定义良好的服务端API 194
        11.3.3 保持API 变更的兼容性 195
        11.3.4 API 版本化 198
        11.4 可持续的数据管理 199
        11.4.1 数据库隔离 199
        11.4.2 使用schema 201
        11.4.3 schema 自动化迁移 203
        11.4.4 保持schema 的兼容性 206
        11.5 行为准则 207
        11.6 升级加油站 208
        第12 章 敏捷计划 210
        12.1 敏捷宣言 210
        12.2 敏捷计划的框架 211
        12.3 Scrum 框架 212
        12.3.1 用户故事 213
        12.3.2 任务分解 214
        12.3.3 故事点 214
        12.3.4 消化积压 216
        12.3.5 冲刺计划 216
        12.4 站会 217
        12.5 评审机制 218
        12.6 回顾会 219
        12.7 路线图 220
        12.8 行为准则 221
        12.9 升级加油站 222
        第13 章 与管理者合作 223
        13.1 管理者是做什么的 223
        13.2 沟通、目标与成长 224
        13.2.1 一对一面谈 225
        13.2.2 PPP 227
        13.2.3 OKR 229
        13.2.4 绩效考核 230
        13.3 向上管理 232
        13.3.1 接收反馈 232
        13.3.2 给予反馈 233
        13.3.3 讨论你的目标 235
        13.3.4 事情不顺时要采取行动 236
        13.4 行为准则 238
        13.5 升级加油站 239
        第14 章 职业生涯规划 241
        14.1 迈向资深之路 241
        14.2 职业生涯建议 242
        14.2.1 T 型人才 242
        14.2.2 参加工程师训练营 243
        14.2.3 主导你自己的晋升 244
        14.2.4 换工作需谨慎 246
        14.2.5 自我调节 247
        14.3 结尾寄语 248
     · · · · · ·     (收起)"
35503091,C语言程序设计：现代方法（第2版•修订版）,9.2,(114人评价),[美] K.N.金 / 吕秀锋、黄倩 / 图灵丨人民邮电出版社 / 2021-7 / 129.80元,"◎ 本书特色
近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分
哈佛、麻省理工、斯坦福等诸多名校C语言教材
基于C1X标准全新升级
浙江大...",https://book.douban.com/subject/35503091/,https://img9.doubanio.com/view/subject/s/public/s33927414.jpg,129.80元,9787115565198,"◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超...(展开全部)





◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超过95%的大学用C语言作为入门编程语言，但也因此把C语言当作一种学习编程的教学媒介语言来教，使得学生只学到了其中的基础部分，而对C语言近30年的发展及其在工业中的应用所知甚少。本书是难得的真正讲述C语言的教材，覆盖了C99、C11、C18标准的内容。本书非常适合今后会用C语言来做嵌入式系统、设备驱动和操作系统等产品开发的人士学习。在浙江大学，我们在工程实践课程中使用了本书的上一个版本，收获了良好的教学效果。 ——翁恺，浙江大学计算机学院教授 书如其名，本书以一种崭新的视角和通俗易懂的方式，来向读者介绍C语言的“现代方法”，聚焦程序设计的核心问题和方法，给C语言这门经久不衰、老而弥坚的语言赋予了崭新的面貌。本书介绍了C99和C1X的许多新特性，而且编排方式方便读者查阅。本书用现代的视角来解读C语言，每章后面的“问与答”也很贴心，适时地解答了读者在阅读过程中可能会遇到的很多疑难问题。本书内容特别适合具备一定语言基础，想深入了解C语言精髓的读者，我相信这本书一定会受到读者的欢迎，成为C语言爱好者提升内功的一本武林秘笈。 ——苏小红，哈尔滨工业大学教授、博士生导师，省级教学名师 本书讨论了C语言的所有特性，从C89一直贯穿到C18。内容足够新，也足够全面，这就是它的突出特色。 ——吴咏炜，Boolan首席咨询师 本书是C语言程序设计的经典图书，本次修订版增加了C1X的内容，并就C1X与之前的C89、C99进行了比对，做到了与时俱进。本书更是新增了第28章，重点介绍了C1X的多线程特性，相信对读者会有巨大的帮助。读者通过阅读本书，可深入理解C89、C99和C1X的演进，并进一步思考C语言为什么这么演进，这对提高自身的思维能力以及对软件工程问题的认知都会有帮助。 ——宋宝华，资深Linux专家",作者简介 K. N. 金（K. N. King） 世界知名的计算机程序设计教育家。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院和佐治亚州立大学。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide和Java Programming: From the Beginning。 译者简介 吕秀锋 曾任教于北京理工大学软件学院，讲授过多门计算机课程，包括“计算机基础（双语）”“C语言程序设计（双语）”“数据结构”“程序设计开发与实践”。 黄倩 河海大学计算机科学与技术系主任，兼任中国人工智能学会深度学习专委会委员、中国计算机学会多媒体技术专委会委员。博士毕业于中国科学院计算技术研究所，译有《编程珠玑（第2版）》等。,"第1章 C语言概述
        第2章 C语言基本概念
        第3章 格式化输入/输出
        第4章 表达式
        第5章 选择语句
        第6章 循环
        第7章 基本类型
        第8章 数组
        第9章 函数
        第10章 程序结构
        第11章 指针
        第12章 指针和数组
        第13章 字符串
        第14章 预处理器
        第15章 编写大型程序
        第16章 结构、联合和枚举
        第17章 指针的高级应用
        第18章 声明
        第19章 程序设计
        第20章 底层程序设计
        第21章 标准库
        第22章 输入/输出
        第23章 库对数值和字符数据的支持
        第24章 错误处理
        第25章 国际化特性
        第26章 其他库函数
        第27章 C99对数学计算的新增支持
        第28章 C1X新增的多线程和原子操作支持
        附录A C语言运算符
        附录B C1X与C99的比较
        附录C C99与C89的比较
        附录D C89与经典C的比较
        附录E 标准库函数
        附录F ASCII字符集
        延伸阅读
        索引
     · · · · · ·     (收起)"
1998341,计算机系统要素,9.1,(269人评价),[美] Noam Nisan、[美] Shimon Schocken / 周维、宋磊、陈曦 / 电子工业出版社 / 2007-01-01 / 45.00元,本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，...,https://book.douban.com/subject/1998341/,https://img9.doubanio.com/view/subject/s/public/s2207295.jpg,45.00元,9787121033360,"本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统...(展开全部)





本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统所必需的工具和资料，以及用于12个项目的200个测试程序。 全书内容广泛、涉猎全面，适合计算机及相关专业本科生、研究生、技术开发人员、教师以及技术爱好者参考和学习。","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
    · · · · · ·
    (更多)","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
        1.1.3 实际硬件结构
        1.1.4 硬件描述语言（HDL）
        1.1.5 硬件仿真
        1.2 规范详述
        1.2.1 Nand门
        1.2.2 基本逻辑门
        1.2.3 多位基本门
        1.2.4 多通道逻辑门
        1.3 实现
        1.4 观点
        1.5 项目
        第2章 布尔运算
        2.1 背景知识
        2.2 规范详述
        2.2.1 加法器
        2.2.2 算术逻辑单元（ALU）
        2.3 实现
        2.4 观点
        2.5 项目
        第3章 时序逻辑
        3.1 背景知识
        3.2 规范详述
        3.2.1 D触发器
        3.2.2 寄存器
        3.2.3 存储
        3.2.4 计数器
        3.3 实现
        3.4 观点
        3.5 项目
        第4章 机器语言
        4.1 背景知识
        4.1.1 机器
        4.1.2 语言
        4.1.3 命令
        4.2 Hack机器语言规范详述
        4.2.1 概述
        4.2.2 A-指令
        4.2.3 C-指令
        4.2.4 符号
        4.2.5 输入/输出处理
        4.2.6 语法规约和文件格式
        4.3 观点
        4.4 项目
        第5章 计算机体系结构
        5.1 背景知识
        5.1.1 存储程序概念
        5.1.2 冯?诺依曼结构
        5.1.3 内存
        5.1.4 中央处理器
        5.1.5 寄存器
        5.1.6 输入和输出
        5.2 Hack硬件平台规范详述
        5.2.1 概述
        5.2.2 中央处理器（CPU）
        5.2.3 指令内存
        5.2.4 数据内存
        5.2.5 计算机
        5.3 实现
        5.3.1 中央处理器
        5.3.2 内存
        5.3.3 计算机
        5.4 观点
        5.5 项目
        第6章 汇编编译器
        第7章 虚拟机Ⅰ：堆栈运算
        第8章 虚拟机Ⅱ：程序控制
        第9章 高级语言
        第10章 编译器Ⅰ：语法分析
        第11章 编译器Ⅱ：代码生成
        第12章 操作系统
        第13章 后记：发掘更多乐趣
        附录A： 硬件描述语言（HDL）
        附录B： 测试脚本语言
        索引
     · · · · · ·     (收起)"
35972849,代码大全2（纪念版）,9.3,(62人评价),[美] 史蒂夫·麦康奈尔(Steve McConnell) / 陈玉毅、陈军、杨志昂、洪佳、徐东伟、王国良、徐毅、李虎 / 清华大学出版社 / 2022-7-7 / 256.00,"《软件开发》杂志Jolt大奖
大而全，洞悉软件构建精髓
优而先，兼顾行业实践研究
奠定硬核技术领导力的经典
庸常变身卓越的实用性指导
《代码大全2》是著名科...",https://book.douban.com/subject/35972849/,https://img3.doubanio.com/view/subject/s/public/s34276333.jpg,256.00,9787302583646,"《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序...(展开全部)





《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。无论是什么背景的读者，阅读本书都有助于在更短的时间内、更容易地写出更好、更简洁、更优雅的程序。","史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现...(展开全部)




史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现象级科技类图书缔造者 • 会做（编程）又会教的一线程序员 • 《软件开发》杂志震撼图书大奖（两次） • 《软件开发》杂志生产力大奖（两次） •   西雅图大学杰出校友奖 • 《普吉特海湾商业期刊》40 UNDER 40杰出青年奖 •  波音和微软等公司顾问 •  ACM（计算机学会）金牌核心奖章得主 •  IEEE Software杂志主编 •  惠特曼文理学院优秀毕业生，PBK会员","第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界　003
        第2章　通过隐喻更充分地理解软件开发　009
        第3章　谋定而后动：前期准备　023
        第4章　关键的构建决策　057
        第II部分高质量的代码
        第5章　软件构建的设计　069
        第6章　可以工作的类　121
        第7章　高质量的子程序　157
        第8章　防御式编程　187
        第9章　伪代码编程过程　215
        第Ⅲ部分变量
        第10章　变量使用中的常规问题　239
        第11章　变量名称的威力　263
        第12章　基本数据类型　295
        第13章　不常见的数据类型　323
        第Ⅳ部分语句
        第14章　直线型代码的组织　353
        第15章　使用条件语句　361
        第16章　控制循环　373
        第17章　不常见的控制结构　395
        第18章　表驱动法　417
        第19章　常规控制问题　437
        第Ⅴ部分代码改进
        第20章　软件质量概述　469
        第21章　协同构建　483
        第22章　开发人员测试　503
        第23章　调试　541
        第24章　重构　569
        第25章　代码调优策略　591
        第26章　代码调优技术　613
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响　651
        第28章　管理构建　663
        第29章　集成　693
        第30章　编程工具　715
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格　733
        第32章　自文档代码　781
        第33章　个人性格　821
        第34章　关于软件匠艺　837
        第35章　更多信息来源　853
        详细目录
        第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界	003
        1.1什么是软件构建	003
        1.2软件构建为何如此重要	006
        1.3如何阅读本书	008
        第2章　通过隐喻更充分地
        理解软件开发	009
        2.1隐喻的重要性	009
        2.2如何使用软件隐喻	012
        2.3常见的软件隐喻	013
        第3章　谋定而后动：前期准备	023
        3.1前期准备的重要性	024
        3.2确定要开发什么类型的软件	030
        3.3定义问题的先决条件	034
        3.4需求的先决条件	036
        3.5架构的先决条件	041
        3.6前期准备所花费的时间	052
        第4章　关键的构建决策	057
        4.1编程语言的选择	057
        4.2编程约定	062
        4.3判断个人处于技术浪潮中的哪个阶段	062
        4.4选择重要的构建实践	065
        第II部分高质量的代码
        第5章　软件构建的设计	069
        5.1设计挑战	070
        5.2关键设计概念	073
        5.3设计构建基块：启发式方法	083
        5.4设计实践	107
        5.5点评各种流行的方法论	115
        第6章　可以工作的类	121
        6.1类的基础：抽象数据类型(ADT)	122
        6.2良好的类接口	129
        6.3设计和实现问题	139
        6.4创建类的理由	149
        6.5语言特定问题	153
        6.6超越类：包	153
        第7章　高质量的子程序	157
        7.1创建子程序的正当理由	160
        7.2子程序级别的设计	165
        7.3好的子程序名称	169
        7.4一个子程序应该有多长	171
        7.5如何使用子程序参数	173
        7.6函数使用中的特别注意事项	180
        7.7宏子程序和内联子程序	182
        第8章　防御式编程	187
        8.1保护程序，
        使其免受无效输入的影响	188
        8.2断言	189
        8.3错误处理技术	194
        8.4异常	198
        8.5隔离程序，使之包容
        由错误造成的损害	203
        8.6调试辅助代码	205
        8.7确定在生产代码中
        保留多少防御式代码	209
        8.8对防御式编程采取防御的姿态	211
        第9章　伪代码编程过程	215
        9.1类和子程序构建步骤总结	215
        9.2面向专家的伪代码	218
        9.3使用PPP构建子程序	220
        9.4PPP的替代方案	233
        第Ⅲ部分变量
        第10章　变量使用中的常规问题	239
        10.1数据扫盲	240
        10.2简化变量声明	241
        10.3变量初始化指南	242
        10.4作用域	247
        10.5持久性	254
        10.6绑定时间	255
        10.7数据类型和控制结构之间的关系	257
        10.8每个变量只有一个用途	258
        第11章　变量名称的威力	263
        11.1选择好名称的注意事项	263
        11.2特定数据类型的命名	269
        11.3命名规范的威力	275
        11.4非正式的命名规范	276
        11.5前缀的标准化	283
        11.6创建可读的短名称	286
        11.7变量名称避坑指南	289
        第12章　基本数据类型	295
        12.1一般的数字	296
        12.2整型	297
        12.3浮点型	299
        12.4字符和字符串	302
        12.5布尔变量	305
        12.6枚举类型	307
        12.7具名常量	312
        12.8数组	314
        12.9创建自定义类型(类型别名)	316
        第13章　不常见的数据类型	323
        13.1结构体	323
        13.2指针	327
        13.3全局数据	340
        第Ⅳ部分语句
        第14章　直线型代码的组织	353
        14.1顺序攸关的语句	353
        14.2顺序无关的语句	356
        第15章　使用条件语句	361
        15.1if语句	361
        15.2case语句	367
        第16章　控制循环	373
        16.1选择循环类型	373
        16.2控制循环	379
        16.3轻松创建循环：由内而外 	391
        16.4循环和数组的对应关系	393
        第17章　不常见的控制结构	395
        17.1子程序中的多个返回点	395
        17.2递归	397
        17.3goto语句	402
        17.4众说纷纭，谈谈不常见的控制结构	413
        第18章　表驱动法	417
        18.1表驱动法使用总则	417
        18.2直接访问表	419
        18.3索引访问表	431
        18.4阶梯访问表	433
        18.5表查询的其他示例	436
        第19章　常规控制问题	437
        19.1布尔表达式	437
        19.2复合语句(语句块)	448
        19.3空语句	449
        19.4驾驭深层嵌套	451
        19.5编程基础：结构化编程	460
        19.6控制结构与复杂度	462
        第Ⅴ部分代码改进
        第20章　软件质量概述	469
        20.1软件质量的特性	469
        20.2改进软件质量的技术	472
        20.3质量保证技术的相对效能	475
        20.4何时进行质量保证	479
        20.5软件质量的普遍原理	479
        第21章　协同构建	483
        21.1协同开发实践概述	484
        21.2结对编程	487
        21.3正式审查	489
        21.4其他类型的协同开发实践	496
        第22章　开发人员测试	503
        22.1开发者测试
        对软件质量所起的作用	504
        22.2开发人员测试的推荐方法	507
        22.3一些测试技巧	509
        22.4典型错误 	522
        22.5测试支持工具	528
        22.6改进测试	534
        22.7维护测试记录 	535
        第23章　调试	541
        23.1调试问题概述	541
        23.2发现缺陷	546
        23.3修复缺陷	557
        23.4调试中的心理因素	560
        23.5那些显而易见和
        不太明显的调试工具	563
        第24章　重构	569
        24.1软件演变的类型	570
        24.2重构简介	571
        24.3特定的重构	577
        24.4安全重构	585
        24.5重构策略	587
        第25章　代码调优策略	591
        25.1性能概述	592
        25.2代码调优简介	595
        25.3各式各样的臃肿和蜜糖	601
        25.4度量	607
        25.5迭代	608
        25.6代码调优方法总结	609
        第26章　代码调优技术	613
        26.1逻辑	614
        26.2循环	619
        26.3数据变换	628
        26.4表达式	633
        26.5子程序	642
        26.6用低级语言重新编码	643
        26.7改得越多，越不会有大的改观	646
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响	651
        27.1沟通和规模	651
        27.2项目规模的范围	652
        27.3项目规模对错误的影响	653
        27.4项目规模对生产力的影响	655
        27.5项目规模对开发活动的影响	656
        第28章　管理构建	663
        28.1鼓励良好的编码实践	664
        28.2配置管理	666
        28.3评估构建进度表	673
        28.4度量	679
        28.5以人为本，善待每一位程序员	683
        28.6向上管理	689
        第29章　集成	693
        29.1集成方法的重要性	693
        29.2集成的频率，阶段式还是增量式	695
        29.3增量式集成策略	698
        29.4每日构建和冒烟测试	707
        第30章　编程工具	715
        30.1设计工具	716
        30.2源代码工具	716
        30.3可执行码工具	721
        30.4面向工具的环境	726
        30.5自己动手写编程工具	726
        30.6工具的幻境	728
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格	733
        31.1基本理论	734
        31.2布局技术	741
        31.3布局风格	743
        31.4控制结构的布局	750
        31.5单条语句的布局	757
        31.6注释的布局	768
        31.7子程序的布局	771
        31.8类的布局	772
        第32章　自文档代码	781
        32.1外部文档	781
        32.2编程风格即文档	782
        32.3注释，还是不注释	785
        32.4高效注释的关键	788
        32.5注释的技术	795
        32.6IEEE标准	815
        第33章　个人性格	821
        33.1个人性格与本书主题有关	822
        33.2聪明与谦卑	823
        33.3好奇心	824
        33.4理性诚实	827
        33.5沟通与合作	830
        33.6创造力与规范	830
        33.7懒惰	831
        33.8没有想象中那么重要的性格因素	832
        33.9习惯	833
        第34章　关于软件匠艺	837
        34.1征服复杂性	837
        34.2优选开发过程	839
        34.3编写程序时，先考虑人，
        再考虑机器	840
        34.4深入语言去编程，
        而不是用语言来编程	842
        34.5借助于规范来保持专注	843
        34.6面向问题域编程	844
        34.7 当心落石	846
        34.8迭代，迭代，迭代，
        重要的事情说三遍	848
        34.9警惕编程中的执念	849
        试验	851
        第35章　更多信息来源	853
        35.1与软件构建相关的信息	853
        35.2软件构建之外的话题	854
        35.3出版物	856
        35.4软件开发者的阅读计划	857
        35.5加入专业组织	859
        参考文献	861
     · · · · · ·     (收起)"
35520512,深入浅出Pandas,8.6,(97人评价),李庆辉 / 机械工业出版社 / 2021-7-10 / 99.00,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。
这是一本全面覆盖了Pandas使用者的普遍需求和...",https://book.douban.com/subject/35520512/,https://img9.doubanio.com/view/subject/s/public/s33944495.jpg,99.00,9787111685456,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 ...(展开全部)





如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 第三部分（第6～9章） 数据形式变化 讲解了Pandas的分组聚合操作、合并操作、对比操作、数据透视、转置、归一化、标准化等，以及如何利用多层索引对数据进行升降维。 第四部分（第10～12章） 数据清洗 讲解了缺失值和重复值的识别、删除、填充，数据的替换、格式转换，文本的提取、连接、匹配、切分、替换、格式化、虚拟变量化等，以及分类数据的应用场景和操作方法。 第五部分（第13～14章）时序数据分析 讲解了Pandas中对于各种时间类型数据的处理和分析，以及在时序数据处理中经常使用的窗口计算。 第六部分（第15～16章） 可视化 讲解了Pandas的样式功能如何让数据表格更有表现力，以及Pandas的绘图功能如何让数据自己说话。 第七部分（第17章） 实战案例 介绍了从需求到代码的思考过程，如何利用链式编程思想提高代码编写和数据分析效率，以及数据分析的基本方法与需要掌握的数据分析工具和技术栈，此外还从数据处理和数据分析两个角度给出了大量的应用案例及代码详解。",李庆辉，数据产品专家，某电商公司数据产品团队负责人，擅长通过数据治理、数据分析、数据化运营提升公司的数据应用水平。 精通 Python 数据科学及 Python Web 开发，曾独立开发公司的自动化数据分析平台，参与教育部“1+X”数据分析（Python）职业技能等级标准评审。 中国人工智能学会会员，企业数字化、数据产品和数据分析讲师，在个人网站“盖若”上编写的技术和产品教程广受欢迎。,"前言
        第一部分 Pandas入门
        第1章 Pandas简介及快速入门2
        1.1 Pandas是什么2
        1.1.1 Python简介2
        1.1.2 Python的应用3
        1.1.3 为什么不选择R4
        1.1.4 Pandas简介4
        1.1.5 Pandas的使用人群5
        1.1.6 Pandas的基本功能5
        1.1.7 Pandas的学习方法6
        1.1.8 小结6
        1.2 环境搭建及安装6
        1.2.1 Python环境安装7
        1.2.2 Anaconda简介7
        1.2.3 安装miniconda8
        1.2.4 多Python版本环境9
        1.2.5 安装编辑器10
        1.2.6 Jupyter Notebook10
        1.2.7 用pip安装三方库11
        1.2.8 安装Jupyter Notebook12
        1.2.9 启动Jupyter Notebook12
        1.2.10 使用Jupyter Notebook13
        1.2.11 安装Pandas14
        1.2.12 小结14
        1.3 Pandas快速入门14
        1.3.1 安装导入14
        1.3.2 准备数据集15
        1.3.3 读取数据15
        1.3.4 查看数据16
        1.3.5 验证数据17
        1.3.6 建立索引17
        1.3.7 数据选取18
        1.3.8 排序19
        1.3.9 分组聚合19
        1.3.10 数据转换20
        1.3.11 增加列21
        1.3.12 统计分析21
        1.3.13 绘图21
        1.3.14 导出24
        1.3.15 小结24
        1.4 本章小结24
        第2章 数据结构25
        2.1 数据结构概述25
        2.1.1 什么是数据25
        2.1.2 什么是数据结构26
        2.1.3 小结26
        2.2 Python的数据结构26
        2.2.1 数字27
        2.2.2 字符串27
        2.2.3 布尔型28
        2.2.4 列表29
        2.2.5 元组30
        2.2.6 字典30
        2.2.7 集合31
        2.2.8 小结32
        2.3 NumPy32
        2.3.1 NumPy简介33
        2.3.2 数据结构33
        2.3.3 创建数据34
        2.3.4 数据类型34
        2.3.5 数组信息35
        2.3.6 统计计算35
        2.3.7 小结35
        2.4 Pandas的数据结构35
        2.4.1 Series36
        2.4.2 DataFrame36
        2.4.3 索引37
        2.4.4 小结38
        2.5 Pandas生成数据38
        2.5.1 导入Pandas38
        2.5.2 创建数据38
        2.5.3 生成Series40
        2.5.4 生成DataFrame41
        2.5.5 小结43
        2.6 Pandas的数据类型43
        2.6.1 数据类型查看43
        2.6.2 常见数据类型44
        2.6.3 数据检测44
        2.6.4 小结45
        2.7 本章小结45
        第二部分 Pandas数据分析基础
        第3章 Pandas数据读取与输出48
        3.1 数据读取48
        3.1.1 CSV文件49
        3.1.2 Excel49
        3.1.3 JSON 50
        3.1.4 HTML50
        3.1.5 剪贴板51
        3.1.6 SQL51
        3.1.7 小结52
        3.2 读取CSV52
        3.2.1 语法52
        3.2.2 数据内容53
        3.2.3 分隔符53
        3.2.4 表头54
        3.2.5 列名54
        3.2.6 索引54
        3.2.7 使用部分列54
        3.2.8 返回序列55
        3.2.9 表头前缀55
        3.2.10 处理重复列名55
        3.2.11 数据类型55
        3.2.12 引擎55
        3.2.13 列数据处理56
        3.2.14 真假值转换56
        3.2.15 跳过指定行56
        3.2.16 读取指定行57
        3.2.17 空值替换57
        3.2.18 保留默认空值57
        3.2.19 日期时间解析58
        3.2.20 文件处理59
        3.2.21 符号60
        3.2.22 小结61
        3.3 读取Excel61
        3.3.1 语法61
        3.3.2 文件内容62
        3.3.3 表格62
        3.3.4 表头62
        3.3.5 列名62
        3.3.6 其他62
        3.3.7 小结63
        3.4 数据输出63
        3.4.1 CSV63
        3.4.2 Excel63
        3.4.3 HTML64
        3.4.4 数据库（SQL）64
        3.4.5 Markdown65
        3.4.6 小结65
        3.5 本章小结65
        第4章 Pandas基础操作66
        4.1 索引操作66
        4.1.1 认识索引66
        4.1.2 建立索引67
        4.1.3 重置索引68
        4.1.4 索引类型68
        4.1.5 索引对象69
        4.1.6 索引的属性70
        4.1.7 索引的操作70
        4.1.8 索引重命名72
        4.1.9 修改索引内容72
        4.1.10 小结73
        4.2 数据的信息73
        4.2.1 查看样本73
        4.2.2 数据形状74
        4.2.3 基础信息74
        4.2.4 数据类型74
        4.2.5 行列索引内容75
        4.2.6 其他信息75
        4.2.7 小结75
        4.3 统计计算76
        4.3.1 描述统计76
        4.3.2 数学统计77
        4.3.3 统计函数78
        4.3.4 非统计计算79
        4.3.5 小结80
        4.4 位置计算80
        4.4.1 位置差值diff()80
        4.4.2 位置移动shift()81
        4.4.3 位置序号rank()81
        4.4.4 小结82
        4.5 数据选择82
        4.5.1 选择列83
        4.5.2 切片[]83
        4.5.3 按轴标签.loc84
        4.5.4 按数字索引.iloc86
        4.5.5 取具体值.at/.iat86
        4.5.6 获取数据.get86
        4.5.7 数据截取.truncate87
        4.5.8 索引选择器87
        4.5.9 小结87
        4.6 本章小结88
        第5章 Pandas高级操作89
        5.1 复杂查询89
        5.1.1 逻辑运算89
        5.1.2 逻辑筛选数据91
        5.1.3 函数筛选92
        5.1.4 比较函数92
        5.1.5 查询df.query()93
        5.1.6 筛选df.filter()93
        5.1.7 按数据类型查询93
        5.1.8 小结94
        5.2 数据类型转换94
        5.2.1 推断类型94
        5.2.2 指定类型95
        5.2.3 类型转换astype()95
        5.2.4 转为时间类型96
        5.2.5 小结96
        5.3 数据排序96
        5.3.1 索引排序97
        5.3.2 数值排序98
        5.3.3 混合排序100
        5.3.4 按值大小排序101
        5.3.5 小结101
        5.4 添加修改101
        5.4.1 修改数值101
        5.4.2 替换数据103
        5.4.3 填充空值103
        5.4.4 修改索引名104
        5.4.5 增加列104
        5.4.6 插入列df.insert()105
        5.4.7 指定列df.assign()106
        5.4.8 执行表达式df.eval()108
        5.4.9 增加行109
        5.4.10 追加合并109
        5.4.11 删除110
        5.4.12 删除空值111
        5.4.13 小结111
        5.5 高级过滤111
        5.5.1 df.where()111
        5.5.2 np.where()113
        5.5.3 df.mask()115
        5.5.4 df.lookup()116
        5.5.5 小结116
        5.6 数据迭代116
        5.6.1 迭代Series116
        5.6.2 df.iterrows()117
        5.6.3 df.itertuples()117
        5.6.4 df.items()118
        5.6.5 按列迭代119
        5.6.6 小结119
        5.7 函数应用120
        5.7.1 pipe()120
        5.7.2 apply()121
        5.7.3 applymap()123
        5.7.4 map()124
        5.7.5 agg()124
        5.7.6 transform()125
        5.7.7 copy()126
        5.7.8 小结126
        5.8 本章小结126
        第三部分 数据形式变化
        第6章 Pandas分组聚合128
        6.1 概述128
        6.1.1 原理128
        6.1.2 groupby语法129
        6.1.3 DataFrame应用分组130
        6.1.4 Series应用分组131
        6.1.5 小结131
        6.2 分组131
        6.2.1 分组对象131
        6.2.2 按标签分组132
        6.2.3 表达式132
        6.2.4 函数分组133
        6.2.5 多种方法混合134
        6.2.6 用pipe调用分组方法134
        6.2.7 分组器Grouper135
        6.2.8 索引136
        6.2.9 排序136
        6.2.10 小结136
        6.3 分组对象的操作136
        6.3.1 选择分组137
        6.3.2 迭代分组138
        6.3.3 选择列139
        6.3.4 应用函数apply()139
        6.3.5 管道方法pipe()142
        6.3.6 转换方法transform()142
        6.3.7 筛选方法filter()144
        6.3.8 其他功能145
        6.3.9 小结146
        6.4 聚合统计146
        6.4.1 描述统计146
        6.4.2 统计函数147
        6.4.3 聚合方法agg()147
        6.4.4 时序重采样方法resample()149
        6.4.5 组内头尾值150
        6.4.6 组内分位数150
        6.4.7 组内差值151
        6.4.8 小结151
        6.5 数据分箱151
        6.5.1 定界分箱pd.cut()152
        6.5.2 等宽分箱pd.qcut()152
        6.5.3 小结154
        6.6 分组可视化154
        6.6.1 绘图方法plot()154
        6.6.2 直方图hist()155
        6.6.3 箱线图boxplot()156
        6.6.4 小结157
        6.7 本章小结158
        第7章 Pandas数据合并与对比159
        7.1 数据追加df.append159
        7.1.1 基本语法159
        7.1.2 相同结构160
        7.1.3 不同结构161
        7.1.4 忽略索引161
        7.1.5 重复内容162
        7.1.6 追加序列162
        7.1.7 追加字典163
        7.1.8 小结163
        7.2 数据连接pd.concat163
        7.2.1 基本语法163
        7.2.2 简单连接164
        7.2.3 按列连接164
        7.2.4 合并交集165
        7.2.5 与序列合并165
        7.2.6 指定索引166
        7.2.7 多文件合并166
        7.2.8 目录文件合并167
        7.2.9 小结167
        7.3 数据合并pd.merge167
        7.3.1 基本语法168
        7.3.2 连接键168
        7.3.3 索引连接169
        7.3.4 多连接键169
        7.3.5 连接方法170
        7.3.6 连接指示170
        7.3.7 小结171
        7.4 按元素合并171
        7.4.1 df.combine_first()171
        7.4.2 df.combine()172
        7.4.3 df.update()173
        7.4.4 小结173
        7.5 数据对比df.compare173
        7.5.1 简单对比174
        7.5.2 对齐方式174
        7.5.3 显示相同值174
        7.5.4 保持形状175
        7.5.5 小结175
        7.6 本章小结175
        第8章 Pandas多层索引177
        8.1 概述177
        8.1.1 什么是多层索引177
        8.1.2 通过分组产生多层索引178
        8.1.3 由序列创建多层索引179
        8.1.4 由元组创建多层索引179
        8.1.5 可迭代对象的笛卡儿积180
        8.1.6 将DataFrame转为多层索引对象180
        8.1.7 小结180
        8.2 多层索引操作181
        8.2.1 生成数据181
        8.2.2 索引信息181
        8.2.3 查看层级182
        8.2.4 索引内容182
        8.2.5 排序183
        8.2.6 其他操作183
        8.2.7 小结183
        8.3 数据查询183
        8.3.1 查询行183
        8.3.2 查询列184
        8.3.3 行列查询185
        8.3.4 条件查询185
        8.3.5 用pd.IndexSlice索引数据186
        8.3.6 df.xs()186
        8.3.7 小结186
        8.4 本章小结186
        第9章 Pandas数据重塑与透视187
        9.1 数据透视187
        9.1.1 整理透视187
        9.1.2 整理透视操作188
        9.1.3 聚合透视189
        9.1.4 聚合透视操作190
        9.1.5 聚合透视高级操作191
        9.1.6 小结192
        9.2 数据堆叠192
        9.2.1 理解堆叠193
        9.2.2 堆叠操作df.stack()194
        9.2.3 解堆操作df.unstack()195
        9.2.4 小结195
        9.3 交叉表195
        9.3.1 基本语法196
        9.3.2 生成交叉表196
        9.3.3 归一化197
        9.3.4 指定聚合方法198
        9.3.5 汇总198
        9.3.6 小结199
        9.4 数据转置df.T199
        9.4.1 理解转置199
        9.4.2 转置操作200
        9.4.3 类型变化200
        9.4.4 轴交换df.swapaxes()201
        9.4.5 小结201
        9.5 数据融合201
        9.5.1 基本语法201
        9.5.2 融合操作202
        9.5.3 标识和值203
        9.5.4 指定名称204
        9.5.5 小结204
        9.6 虚拟变量204
        9.6.1 语法结构204
        9.6.2 生成虚拟变量205
        9.6.3 列前缀205
        9.6.4 从DataFrame生成206
        9.6.5 小结207
        9.7 因子化207
        9.7.1 基本方法207
        9.7.2 排序208
        9.7.3 缺失值208
        9.7.4 枚举类型208
        9.7.5 小结208
        9.8 爆炸列表208
        9.8.1 基本功能209
        9.8.2 DataFrame的爆炸209
        9.8.3 非列表格式210
        9.8.4 小结210
        9.9 本章小结210
        第四部分 数据清洗
        第10章 Pandas数据清洗212
        10.1 缺失值的认定212
        10.1.1 缺失值类型212
        10.1.2 缺失值判断213
        10.1.3 缺失值统计214
        10.1.4 缺失值筛选214
        10.1.5 NA标量215
        10.1.6 时间数据中的缺失值216
        10.1.7 整型数据中的缺失值216
        10.1.8 插入缺失值217
        10.1.9 小结217
        10.2 缺失值的操作217
        10.2.1 缺失值填充217
        10.2.2 插值填充219
        10.2.3 缺失值删除220
        10.2.4 缺失值参与计算221
        10.2.5 小结223
        10.3 数据替换223
        10.3.1 指定值替换223
        10.3.2 使用替换方式223
        10.3.3 字符替换223
        10.3.4 缺失值替换224
        10.3.5 数字替换224
        10.3.6 数据修剪225
        10.3.7 小结226
        10.4 重复值及删除数据226
        10.4.1 重复值识别226
        10.4.2 删除重复值228
        10.4.3 删除数据229
        10.4.4 小结229
        10.5 NumPy格式转换230
        10.5.1 转换方法230
        10.5.2 DataFrame转为ndarray230
        10.5.3 Series转为ndarray231
        10.5.4 df.to_records()231
        10.5.5 np.array读取231
        10.5.6 小结232
        10.6 本章小结232
        第11章 Pandas文本处理233
        11.1 数据类型233
        11.1.1 文本数据类型233
        11.1.2 类型转换234
        11.1.3 类型异同234
        11.1.4 小结235
        11.2 字符的操作235
        11.2.1 .str访问器235
        11.2.2 文本格式236
        11.2.3 文本对齐236
        11.2.4 计数和编码236
        11.2.5 格式判定237
        11.2.6 小结237
        11.3 文本高级处理237
        11.3.1 文本分隔237
        11.3.2 字符分隔展开238
        11.3.3 文本切片选择239
        11.3.4 文本划分240
        11.3.5 文本替换241
        11.3.6 指定替换241
        11.3.7 重复替换242
        11.3.8 文本连接243
        11.3.9 文本查询244
        11.3.10 文本包含245
        11.3.11 文本提取246
        11.3.12 提取虚拟变量247
        11.3.13 小结248
        11.4 本章小结248
        第12章 Pandas分类数据249
        12.1 分类数据249
        12.1.1 创建分类数据249
        12.1.2 pd.Categorical()251
        12.1.3 CategoricalDtype对象251
        12.1.4 类型转换252
        12.1.5 小结253
        12.2 分类的操作253
        12.2.1 修改分类253
        12.2.2 追加新分类254
        12.2.3 删除分类254
        12.2.4 顺序255
        12.2.5 小结256
        12.3 本章小结256
        第五部分 时序数据分析
        第13章 Pandas窗口计算258
        13.1 窗口计算258
        13.1.1 理解窗口计算258
        13.1.2 移动窗口259
        13.1.3 扩展窗口259
        13.1.4 指数加权移动260
        13.1.5 小结260
        13.2 窗口操作260
        13.2.1 计算方法260
        13.2.2 基本语法261
        13.2.3 移动窗口使用262
        13.2.4 统计方法263
        13.2.5 agg()264
        13.2.6 apply()264
        13.2.7 扩展窗口265
        13.2.8 小结266
        13.3 本章小结266
        第14章 Pandas时序数据267
        14.1 固定时间267
        14.1.1 时间的表示267
        14.1.2 创建时间点268
        14.1.3 时间的属性269
        14.1.4 时间的方法270
        14.1.5 时间缺失值271
        14.1.6 小结272
        14.2 时长数据272
        14.2.1 创建时间差272
        14.2.2 时长的加减274
        14.2.3 时长的属性275
        14.2.4 时长索引275
        14.2.5 小结275
        14.3 时间序列275
        14.3.1 时序索引275
        14.3.2 创建时序数据276
        14.3.3 数据访问277
        14.3.4 类型转换279
        14.3.5 按格式转换281
        14.3.6 时间访问器.dt282
        14.3.7 时长数据访问器284
        14.3.8 时序数据移动284
        14.3.9 频率转换285
        14.3.10 小结286
        14.4 时间偏移286
        14.4.1 DateOffset对象286
        14.4.2 偏移别名287
        14.4.3 移动偏移289
        14.4.4 应用偏移289
        14.4.5 偏移参数290
        14.4.6 相关查询290
        14.4.7 与时序的计算291
        14.4.8 锚定偏移292
        14.4.9 自定义工作时间294
        14.4.10 小结296
        14.5 时间段297
        14.5.1 Period对象297
        14.5.2 属性方法297
        14.5.3 时间段的计算298
        14.5.4 时间段索引299
        14.5.5 数据查询300
        14.5.6 相关类型转换301
        14.5.7 小结302
        14.6 时间操作302
        14.6.1 时区转换302
        14.6.2 时间的格式化303
        14.6.3 时间重采样304
        14.6.4 上采样306
        14.6.5 重采样聚合307
        14.6.6 时间类型间转换307
        14.6.7 超出时间戳范围时间308
        14.6.8 区间间隔309
        14.6.9 小结311
        14.7 本章小结312
        第六部分 可视化
        第15章 Pandas样式314
        15.1 内置样式314
        15.1.1 样式功能314
        15.1.2 Styler对象315
        15.1.3 空值高亮315
        15.1.4 极值高亮316
        15.1.5 背景渐变317
        15.1.6 条形图318
        15.1.7 小结320
        15.2 显示格式320
        15.2.1 语法结构320
        15.2.2 常用方法320
        15.2.3 综合运用321
        15.2.4 小结321
        15.3 样式高级操作322
        15.3.1 样式配置操作322
        15.3.2 表格CSS样式323
        15.3.3 应用函数324
        15.3.4 样式复用325
        15.3.5 样式清除325
        15.3.6 导出Excel326
        15.3.7 生成HTML326
        15.3.8 小结327
        15.4 本章小结327
        第16章 Pandas可视化328
        16.1 plot()方法328
        16.1.1 plot()概述328
        16.1.2 plot()基础方法329
        16.1.3 图形类型331
        16.1.4 x轴和y轴331
        16.1.5 图形标题332
        16.1.6 字体大小332
        16.1.7 线条样式333
        16.1.8 背景辅助线334
        16.1.9 图例334
        16.1.10 图形大小334
        16.1.11 色系335
        16.1.12 绘图引擎336
        16.1.13 Matplotlib的其他参数337
        16.1.14 图形叠加337
        16.1.15 颜色的表示337
        16.1.16 解决图形中的中文乱码问题338
        16.1.17 小结340
        16.2 常用可视化图形340
        16.2.1 折线图plot.line340
        16.2.2 饼图plot.pie342
        16.2.3 柱状图plot.bar345
        16.2.4 直方图plot.hist348
        16.2.5 箱形图plot.box351
        16.2.6 面积图plot.area353
        16.2.7 散点图plot.scatter354
        16.2.8 六边形分箱图plot.hexbin356
        16.2.9 小结357
        16.3 本章小结357
        第七部分 实战案例
        第17章 Pandas实战案例360
        17.1 实战思想360
        17.1.1 链式方法360
        17.1.2 代码思路362
        17.1.3 分析方法366
        17.1.4 分析流程368
        17.1.5 分析工具368
        17.1.6 小结369
        17.2 数据处理案例370
        17.2.1 剧组表格道具370
        17.2.2 当月最后一个星期三371
        17.2.3 同组数据转为同一行372
        17.2.4 相关性最强的两个变量373
        17.2.5 全表最大值的位置375
        17.2.6 编写年会抽奖程序376
        17.2.7 北京各区无新增新冠肺炎确诊病例天数377
        17.2.8 生成SQL378
        17.2.9 圣诞节的星期分布379
        17.2.10 试验三天中恰有两天下雨的概率381
        17.2.11 计算平均打卡上班时间382
        17.2.12 小结383
        17.3 综合案例383
        17.3.1 中国经济发展分析383
        17.3.2 新冠肺炎疫情分析387
        17.3.3 利用爬虫获取房价390
        17.3.4 全国城市房价分析392
        17.3.5 客服对话文本分析396
        17.3.6 RFM用户分层399
        17.3.7 自动邮件报表404
        17.3.8 鸢尾花品种预测407
        17.3.9 小结410
        17.4 本章小结410
     · · · · · ·     (收起)"
35768338,Vue.js设计与实现,9.6,(197人评价),霍春阳 / 人民邮电出版社 / 2022-2-10 / 119.8,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章...,https://book.douban.com/subject/35768338/,https://img9.doubanio.com/view/subject/s/public/s34120804.jpg,119.8,9787115583864,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章，分为六篇，主要内容包括：框架设计概览、响应系统、渲染器、组件化、编译器和服务端渲染等。通过阅读本书，对Vue.js 2/3具有上手经验的开发人员能够进一步理解Vue.js框架的实现细节，没有Vue.js使用经验但对框架设计感兴趣的前端开发人员，能够快速掌握Vue.js的设计原理。,霍春阳（HcySunYang） Vue.js官方团队成员，专注于Web研发领域，是Vue.js 3的核心贡献者之一，Vue.js文档生成工具Vuese的作者，技术社区活跃者，曾撰写大量颇受好评的技术博客。,"序
        前言
        第　1章 权衡的艺术　2
        1．1　命令式和声明式　2
        1．2　性能与可维护性的权衡　3
        1．3　虚拟DOM的性能到底如何　4
        1．4　运行时和编译时　8
        1．5　总结　11
        第　2章 框架设计的核心要素　12
        2．1　提升用户的开发体验　12
        2．2　控制框架代码的体积　14
        2．3　框架要做到良好的Tree-Shaking　15
        2．4　框架应该输出怎样的构建产物　17
        2．5　特性开关　19
        2．6　错误处理　21
        2．7　良好的TypeScript类型支持　23
        2．8　总结　25
        第3章　Vue．js 3的设计思路　27
        3．1　声明式地描述UI　27
        3．2　初识渲染器　29
        3．3　组件的本质　32
        3．4　模板的工作原理　34
        3．5　Vue．js是各个模块组成的有机整体　36
        3．6　总结　37
        第4章　响应系统的作用与实现　40
        4．1　响应式数据与副作用函数　40
        4．2　响应式数据的基本实现　41
        4．3　设计一个完善的响应系统　43
        4．4　分支切换与cleanup　50
        4．5　嵌套的effect与effect栈　55
        4．6　避免无限递归循环　59
        4．7　调度执行　60
        4．8　计算属性computed与lazy　64
        4．9　watch的实现原理　71
        4．10　立即执行的watch与回调执行时机　75
        4．11　过期的副作用　77
        4．12　总结　82
        第5章　非原始值的响应式方案　84
        5．1　理解Proxy和Reflect　84
        5．2　JavaScript对象及Proxy的工作原理　88
        5．3　如何代理Object　92
        5．4　合理地触发响应　102
        5．5　浅响应与深响应　108
        5．6　只读和浅只读　110
        5．7　代理数组　113
        5．7．1　数组的索引与 length　114
        5．7．2　遍历数组　119
        5．7．3　数组的查找方法　124
        5．7．4　隐式修改数组长度的原型方法　129
        5．8　代理Set和Map　132
        5．8．1　如何代理Set和Map　133
        5．8．2　建立响应联系　137
        5．8．3　避免污染原始数据　140
        5．8．4　处理forEach　143
        5．8．5　迭代器方法　147
        5．8．6　values与keys方法　152
        5．9　总结　155
        第6章　原始值的响应式方案　158
        6．1　引入ref的概念　158
        6．2　响应丢失问题　160
        6．3　自动脱ref　164
        6．4　总结　166
        第7章　渲染器的设计　170
        7．1　渲染器与响应系统的结合　170
        7．2　渲染器的基本概念　172
        7．3　自定义渲染器　175
        7．4　总结　179
        第8章　挂载与更新　180
        8．1　挂载子节点和元素的属性　180
        8．2　HTML Attributes与DOM Properties　182
        8．3　正确地设置元素属性　184
        8．4　class的处理　189
        8．5　卸载操作　192
        8．6　区分vnode的类型　195
        8．7　事件的处理　196
        8．8　事件冒泡与更新时机问题　201
        8．9　更新子节点　204
        8．10　文本节点和注释节点　209
        8．11　Fragment　212
        8．12　总结　215
        第9章　简单Diff算法　218
        9．1　减少DOM操作的性能开销　218
        9．2　DOM复用与key的作用　221
        9．3　找到需要移动的元素　225
        9．4　如何移动元素　228
        9．5　添加新元素　233
        9．6　移除不存在的元素　238
        9．7　总结　241
        第　10章 双端Diff算法　242
        10．1　双端比较的原理　242
        10．2　双端比较的优势　252
        10．3　非理想状况的处理方式　255
        10．4　添加新元素　263
        10．5　移除不存在的元素　268
        10．6　总结　270
        第　11章 快速Diff算法　271
        11．1　相同的前置元素和后置元素　271
        11．2　判断是否需要进行DOM移动操作　279
        11．3　如何移动元素　288
        11．4　总结　296
        第　12章 组件的实现原理　298
        12．1　渲染组件　298
        12．2　组件状态与自更新　301
        12．3　组件实例与组件的生命周期　304
        12．4　props与组件的被动更新　306
        12．5　setup函数的作用与实现　311
        12．6　组件事件与emit的实现　314
        12．7　插槽的工作原理与实现　316
        12．8　注册生命周期　318
        12．9　总结　320
        第　13章 异步组件与函数式组件　322
        13．1　异步组件要解决的问题　322
        13．2　异步组件的实现原理　324
        13．2．1　封装defineAsyncComponent函数　324
        13．2．2　超时与Error组件　325
        13．2．3　延迟与Loading组件　328
        13．2．4　重试机制　331
        13．3　函数式组件　333
        13．4　总结　335
        第　14章 内建组件和模块　337
        14．1　KeepAlive组件的实现原理　337
        14．1．1　组件的激活与失活　337
        14．1．2　include和exclude　342
        14．1．3　缓存管理　343
        14．2　Teleport组件的实现原理　346
        14．2．1　Teleport组件要解决的问题　346
        14．2．2　实现Teleport组件　347
        14．3　Transition组件的实现原理　350
        14．3．1　原生DOM的过渡　351
        14．3．2　实现Transition组件　356
        14．4　总结　360
        第　15章 编译器核心技术概览　364
        15．1　模板DSL的编译器　364
        15．2　parser的实现原理与状态机　368
        15．3　构造AST　374
        15．4　AST的转换与插件化架构　383
        15．4．1　节点的访问　383
        15．4．2　转换上下文与节点操作　387
        15．4．3　进入与退出　392
        15．5　将模板AST转为JavaScript AST　396
        15．6　代码生成　402
        15．7　总结　407
        第　16章 解析器　409
        16．1　文本模式及其对解析器的影响　409
        16．2　递归下降算法构造模板AST　413
        16．3　状态机的开启与停止　419
        16．4　解析标签节点　426
        16．5　解析属性　430
        16．6　解析文本与解码HTML实体　436
        16．6．1　解析文本　436
        16．6．2　解码命名字符引用　438
        16．6．3　解码数字字符引用　445
        16．7　解析插值与注释　449
        16．8　总结　451
        第　17章 编译优化　453
        17．1　动态节点收集与补丁标志　453
        17．1．1　传统Diff算法的问题　453
        17．1．2　Block与PatchFlags　454
        17．1．3　收集动态节点　457
        17．1．4　渲染器的运行时支持　459
        17．2　Block树　461
        17．2．1　带有v-if指令的节点　462
        17．2．2　带有v-for指令的节点　464
        17．2．3　Fragment的稳定性　465
        17．3　静态提升　466
        17．4　预字符串化　468
        17．5　缓存内联事件处理函数　469
        17．6　v-once　470
        17．7　总结　471
        第　18章 同构渲染　474
        18．1　CSR、SSR以及同构渲染　474
        18．2　将虚拟DOM渲染为HTML字符串　478
        18．3　将组件渲染为HTML字符串　484
        18．4　客户端激活的原理　489
        18．5　编写同构的代码　494
        18．5．1　组件的生命周期　494
        18．5．2　使用跨平台的API　496
        18．5．3　只在某一端引入模块　496
        18．5．4　避免交叉请求引起的状态污染　497
        18．5．5　组件　498
        18．6　总结　499
     · · · · · ·     (收起)"
33450010,动手学深度学习,9.3,(552人评价),阿斯顿·张（Aston Zhang）、李沐（Mu Li）、[美] 扎卡里·C. 立顿（Zachary C. Lipton）、[德] 亚历山大·J. 斯莫拉（Alexander J. Smola） / 人民邮电出版社 / 2019-6 / 85.00元,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的...,https://book.douban.com/subject/33450010/,https://img9.doubanio.com/view/subject/s/public/s32322795.jpg,85.00元,9787115490841,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的 Jupyter记事本，它将文字、公式、图像、代码和运行结果结合在了一起。此外，读者还可以访问并参与书中内容的讨论。 全书的内容分为3个部分：第一部分介绍深度学习的背景，提供预备知识，并包括深度学习最基础的概念和技术；第二部分描述深度学习计算的重要组成部分，还解释近年来令深度学习在多个领域大获成功的卷积神经网络和循环神经网络；第三部分评价优化算法，检验影响深度学习计算性能的重要因素，并分别列举深度学习在计算机视觉和自然语言处理中的重要应用。 本书同时覆盖深度学习的方法和实践，主要面向在校大学生、技术人员和研究人员。阅读本书需要读者了解基本的Python编程或附录中描述的线性代数、微分和概率基础。,"阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、Ne...(展开全部)




阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、NeurIPS、AISTATS、CVPR、KDD 、WSDM、OSDI）上发表过论文。 扎卡里·C. 立顿（Zachary C. Lipton） 亚马逊应用科学家，美国卡内基梅隆大学助理教授，美国加州大学圣迭戈分校博士。他专注于机器学习算法及其社会影响的研究，特别是在时序数据与序列决策上的深度学习。这类工作有着广泛的应用场景，包括医疗诊断、对话系统和产品推荐。他创立了博客“Approximately Correct”（approximatelycorrect.com）。 亚历山大·J. 斯莫拉（Alexander J. Smola） 亚马逊副总裁/ 杰出科学家，德国柏林工业大学计算机科学博士。他曾在澳大利亚国立大学、美国加州大学伯克利分校和卡内基梅隆大学任教。他发表了超过200 篇学术论文，并著有5 本书，其论文及书被引用超过10 万次。他的研究兴趣包括深度学习、贝叶斯非参数、核方法、统计建模和可扩展算法。","对本书的赞誉
        前言
        如何使用本书
        资源与支持
        主要符号表
        第1 章　深度学习简介… ………………… 1
        1.1　起源…………………………………………… 2
        1.2　发展…………………………………………… 4
        1.3　成功案例……………………………………… 6
        1.4　特点………………………………………… 7
        小结…………………………………………… 8
        练习…………………………………………… 8
        第2 章　预备知识… ……………………… 9
        2.1　获取和运行本书的代码……………………… 9
        2.1.1　获取代码并安装运行环境 … ……… 9
        2.1.2　更新代码和运行环境 … …………… 11
        2.1.3　使用GPU版的MXNet … ………… 11
        小结……………………………………………12
        练习……………………………………………12
        2.2　数据操作… ……………………………… 12
        2.2.1　创建NDArray ………………………12
        2.2.2　运算 …………………………………14
        2.2.3　广播机制 ……………………………16
        2.2.4　索引 …………………………………17
        2.2.5　运算的内存开销 ……………………17
        2.2.6　NDArray和NumPy相互变换………18
        小结……………………………………………19
        练习……………………………………………19
        2.3　自动求梯度… …………………………… 19
        2.3.1　简单例子 … …………………………19
        2.3.2　训练模式和预测模式 …………… 20
        2.3.3　对Python控制流求梯度 … …… 20
        小结……………………………………………21
        练习……………………………………………21
        2.4　查阅文档… ……………………………… 21
        2.4.1　查找模块里的所有函数和类 … ……21
        2.4.2　查找特定函数和类的使用 ……… 22
        2.4.3　在MXNet网站上查阅 …………… 23
        小结………………………………………… 24
        练习………………………………………… 24
        第3 章　深度学习基础… ……………… 25
        3.1　线性回归…………………………………… 25
        3.1.1　线性回归的基本要素 … ………… 25
        3.1.2　线性回归的表示方法 … ………… 28
        小结………………………………………… 30
        练习………………………………………… 30
        3.2　线性回归的从零开始实现… …………… 30
        3.2.1　生成数据集 … …………………… 30
        3.2.2　读取数据集 ……………………… 32
        3.2.3　初始化模型参数 ………………… 32
        3.2.4　定义模型 ………………………… 33
        3.2.5　定义损失函数 …………………… 33
        3.2.6　定义优化算法 …………………… 33
        3.2.7　训练模型 ………………………… 33
        小结………………………………………… 34
        练习………………………………………… 34
        3.3　线性回归的简洁实现… ………………… 35
        3.3.1　生成数据集 … …………………… 35
        3.3.2　读取数据集 ……………………… 35
        3.3.3　定义模型 ………………………… 36
        3.3.4　初始化模型参数 ………………… 36
        3.3.5　定义损失函数 …………………… 37
        3.3.6　定义优化算法 …………………… 37
        3.3.7　训练模型 ………………………… 37
        小结………………………………………… 38
        练习………………………………………… 38
        3.4　softmax回归… ………………………… 38
        3.4.1　分类问题 … ……………………… 38
        3.4.2　softmax回归模型… …………… 39
        3.4.3　单样本分类的矢量计算表达式…… 40
        3.4.4　小批量样本分类的矢量计算表达式 …………………………… 40
        3.4.5　交叉熵损失函数 ……………………41
        3.4.6　模型预测及评价 ………………… 42
        小结………………………………………… 42
        练习………………………………………… 42
        3.5　图像分类数据集（Fashion-MNIST）… ……………… 42
        3.5.1　获取数据集 … …………………… 42
        3.5.2　读取小批量 ……………………… 44
        小结………………………………………… 45
        练习………………………………………… 45
        3.6　softmax回归的从零开始实现… ……… 45
        3.6.1　读取数据集 … …………………… 45
        3.6.2　初始化模型参数 ………………… 45
        3.6.3　实现softmax运算 … …………… 46
        3.6.4　定义模型 ………………………… 46
        3.6.5　定义损失函数 …………………… 47
        3.6.6　计算分类准确率 ………………… 47
        3.6.7　训练模型 ………………………… 48
        3.6.8　预测… …………………………… 48
        小结………………………………………… 49
        练习………………………………………… 49
        3.7　softmax回归的简洁实现… …………… 49
        3.7.1　读取数据集 … …………………… 49
        3.7.2　定义和初始化模型 ……………… 50
        3.7.3　softmax和交叉熵损失函数 … … 50
        3.7.4　定义优化算法 …………………… 50
        3.7.5　训练模型 ………………………… 50
        小结………………………………………… 50
        练习………………………………………… 50
        3.8　多层感知机… …………………………… 51
        3.8.1　隐藏层 … ……………………………51
        3.8.2　激活函数 ………………………… 52
        3.8.3　多层感知机 ……………………… 55
        小结………………………………………… 55
        练习………………………………………… 55
        3.9　多层感知机的从零开始实现… ………… 56
        3.9.1　读取数据集 … …………………… 56
        3.9.2　定义模型参数 …………………… 56
        3.9.3　定义激活函数 …………………… 56
        3.9.4　定义模型 ………………………… 56
        3.9.5　定义损失函数 …………………… 57
        3.9.6　训练模型 ………………………… 57
        小结………………………………………… 57
        练习………………………………………… 57
        3.10　多层感知机的简洁实现………………… 57
        3.10.1　定义模型 ………………………… 58
        3.10.2　训练模型 … …………………… 58
        小结………………………………………… 58
        练习………………………………………… 58
        3.11　模型选择、欠拟合和过拟合… ………… 58
        3.11.1　训练误差和泛化误差 …………… 59
        3.11.2　模型选择 ………………………… 59
        3.11.3　欠拟合和过拟合 ………………… 60
        3.11.4　多项式函数拟合实验 ……………61
        小结………………………………………… 65
        练习………………………………………… 65
        3.12　权重衰减………………………………… 65
        3.12.1　方法 ……………………………… 65
        3.12.2　高维线性回归实验 … ………… 66
        3.12.3　从零开始实现 … ……………… 66
        3.12.4　简洁实现 … …………………… 68
        小结………………………………………… 70
        练习………………………………………… 70
        3.13　丢弃法…………………………………… 70
        3.13.1　方法 ……………………………… 70
        3.13.2　从零开始实现 … …………………71
        3.13.3　简洁实现 … …………………… 73
        小结………………………………………… 74
        练习………………………………………… 74
        3.14　正向传播、反向传播和计算图………… 74
        3.14.1　正向传播 ……………………… 74
        3.14.2　正向传播的计算图 … ………… 75
        3.14.3　反向传播 … …………………… 75
        3.14.4　训练深度学习模型 … ………… 76
        小结………………………………………… 77
        练习………………………………………… 77
        3.15　数值稳定性和模型初始化……………… 77
        3.15.1　衰减和爆炸 ……………………… 77
        3.15.2　随机初始化模型参数 … ……… 78
        小结………………………………………… 78
        练习………………………………………… 79
        3.16　实战Kaggle比赛：房价预测… ……… 79
        3.16.1　Kaggle比赛 … ………………… 79
        3.16.2　读取数据集 … ………………… 80
        3.16.3　预处理数据集 … …………………81
        3.16.4　训练模型 … …………………… 82
        3.16.5　k 折交叉验证 …………………… 82
        3.16.6　模型选择 … …………………… 83
        3.16.7　预测并在Kaggle提交结果… … 84
        小结………………………………………… 85
        练习………………………………………… 85
        第4 章　深度学习计算… ……………… 86
        4.1　模型构造………………………………… 86
        4.1.1　继承Block类来构造模型 … …… 86
        4.1.2　Sequential类继承自Block类…………………………… 87
        4.1.3　构造复杂的模型… ……………… 88
        小结………………………………………… 89
        练习………………………………………… 90
        4.2　模型参数的访问、初始化和共享… …… 90
        4.2.1　访问模型参数 … ………………… 90
        4.2.2　初始化模型参数 ………………… 92
        4.2.3　自定义初始化方法 ……………… 93
        4.2.4　共享模型参数 …………………… 94
        小结………………………………………… 94
        练习………………………………………… 94
        4.3　模型参数的延后初始化… ……………… 95
        4.3.1　延后初始化 … …………………… 95
        4.3.2　避免延后初始化 ………………… 96
        小结………………………………………… 96
        练习………………………………………… 97
        4.4　自定义层… ……………………………… 97
        4.4.1　不含模型参数的自定义层 … …… 97
        4.4.2　含模型参数的自定义层 ………… 98
        小结………………………………………… 99
        练习………………………………………… 99
        4.5　读取和存储… …………………………… 99
        4.5.1　读写NDArray… ………………… 99
        4.5.2　读写Gluon模型的参数… ……… 100
        小结………………………………………… 101
        练习………………………………………… 101
        4.6　GPU计算………………………………… 101
        4.6.1　计算设备 … ……………………… 102
        4.6.2　NDArray的GPU计算…………… 102
        4.6.3　Gluon的GPU计算 ……………… 104
        小结………………………………………… 105
        练习………………………………………… 105
        第5 章　卷积神经网络… ……………… 106
        5.1　二维卷积层………………………………… 106
        5.1.1　二维互相关运算 … ……………… 106
        5.1.2　二维卷积层 … …………………… 107
        5.1.3　图像中物体边缘检测 … ………… 108
        5.1.4　通过数据学习核数组 … ………… 109
        5.1.5　互相关运算和卷积运算 … ……… 109
        5.1.6　特征图和感受野… ……………… 110
        小结………………………………………… 110
        练习………………………………………… 110
        5.2　填充和步幅… …………………………… 111
        5.2.1　填充 … …………………………… 111
        5.2.2　步幅 ……………………………… 112
        小结………………………………………… 113
        练习………………………………………… 113
        5.3　多输入通道和多输出通道… …………… 114
        5.3.1　多输入通道 … …………………… 114
        5.3.2　多输出通道… …………………… 115
        5.3.3　1×1卷积层 ……………………… 116
        小结………………………………………… 117
        练习………………………………………… 117
        5.4　池化层… ………………………………… 117
        5.4.1　二维最大池化层和平均池化层 … ………………………… 117
        5.4.2　填充和步幅 ……………………… 119
        5.4.3　多通道 …………………………… 120
        小结………………………………………… 120
        练习………………………………………… 121
        5.5　卷积神经网络（LeNet）… …………… 121
        5.5.1　LeNet模型 … …………………… 121
        5.5.2　训练模型… ……………………… 122
        小结………………………………………… 124
        练习………………………………………… 124
        5.6　深度卷积神经网络（AlexNet）… …… 124
        5.6.1　学习特征表示 … ………………… 125
        5.6.2　AlexNet… ……………………… 126
        5.6.3　读取数据集 ……………………… 127
        5.6.4　训练模型 ………………………… 128
        小结………………………………………… 128
        练习………………………………………… 129
        5.7　使用重复元素的网络（VGG）………… 129
        5.7.1　VGG块 …………………………… 129
        5.7.2　VGG网络 … …………………… 129
        5.7.3　训练模型… ……………………… 130
        小结………………………………………… 131
        练习………………………………………… 131
        5.8　网络中的网络（NiN）… ……………… 131
        5.8.1　NiN块 … ………………………… 131
        5.8.2　NiN模型 … ……………………… 132
        5.8.3　训练模型… ……………………… 133
        小结………………………………………… 134
        练习………………………………………… 134
        5.9　含并行连结的网络（GoogLeNet）…… 134
        5.9.1　Inception块 ……………………… 134
        5.9.2　GoogLeNet模型 … …………… 135
        5.9.3　训练模型 ………………………… 137
        小结………………………………………… 137
        练习………………………………………… 137
        5.10　批量归一化……………………………… 138
        5.10.1　批量归一化层 ………………… 138
        5.10.2　从零开始实现 … ……………… 139
        5.10.3　使用批量归一化层的LeNet … … 140
        5.10.4　简洁实现 … …………………… 141
        小结………………………………………… 142
        练习………………………………………… 142
        5.11　残差网络（ResNet） ……………… 143
        5.11.1　残差块 …………………………… 143
        5.11.2　ResNet模型… ………………… 145
        5.11.3　训练模型………………………… 146
        小结………………………………………… 146
        练习………………………………………… 146
        5.12　稠密连接网络（DenseNet）………… 147
        5.12.1　稠密块 …………………………… 147
        5.12.2　过渡层 … ……………………… 148
        5.12.3　DenseNet模型 ………………… 148
        5.12.4　训练模型 … …………………… 149
        小结………………………………………… 149
        练习………………………………………… 149
        第6 章　循环神经网络… ……………… 150
        6.1　语言模型………………………………… 150
        6.1.1　语言模型的计算 … ……………… 151
        6.1.2　n 元语法 … ……………………… 151
        小结………………………………………… 152
        练习………………………………………… 152
        6.2　循环神经网络… ………………………… 152
        6.2.1　不含隐藏状态的神经网络 … …… 152
        6.2.2　含隐藏状态的循环神经网络… … 152
        6.2.3　应用：基于字符级循环神经网络的语言模型 … ……………………… 154
        小结………………………………………… 155
        练习………………………………………… 155
        6.3　语言模型数据集（歌词）…… 155
        6.3.1　读取数据集 … …………………… 155
        6.3.2　建立字符索引 …………………… 156
        6.3.3　时序数据的采样 ………………… 156
        小结………………………………………… 158
        练习………………………………………… 159
        6.4　循环神经网络的从零开始实现… ……… 159
        6.4.1　one-hot向量 … ………………… 159
        6.4.2　初始化模型参数 ………………… 160
        6.4.3　定义模型 ………………………… 160
        6.4.4　定义预测函数 …………………… 161
        6.4.5　裁剪梯度 ………………………… 161
        6.4.6　困惑度 …………………………… 162
        6.4.7　定义模型训练函数 ……………… 162
        6.4.8　训练模型并创作歌词 …………… 163
        小结………………………………………… 164
        练习………………………………………… 164
        6.5　循环神经网络的简洁实现… …………… 165
        6.5.1　定义模型 … ……………………… 165
        6.5.2　训练模型 ………………………… 166
        小结………………………………………… 168
        练习………………………………………… 168
        6.6　通过时间反向传播… …………………… 168
        6.6.1　定义模型 … ……………………… 168
        6.6.2　模型计算图 ……………………… 169
        6.6.3　方法 ……………………………… 169
        小结………………………………………… 170
        练习………………………………………… 170
        6.7　门控循环单元（GRU）………………… 170
        6.7.1　门控循环单元 … ………………… 171
        6.7.2　读取数据集 ……………………… 173
        6.7.3　从零开始实现 …………………… 173
        6.7.4　简洁实现 ………………………… 175
        小结………………………………………… 176
        练习………………………………………… 176
        6.8　长短期记忆（LSTM）… ……………… 176
        6.8.1　长短期记忆 … …………………… 176
        6.8.2　读取数据集 ……………………… 179
        6.8.3　从零开始实现 …………………… 179
        6.8.4　简洁实现 ………………………… 181
        小结………………………………………… 181
        练习………………………………………… 182
        6.9　深度循环神经网络… …………………… 182
        小结………………………………………… 183
        练习………………………………………… 183
        6.10　双向循环神经网络……………………… 183
        小结………………………………………… 184
        练习………………………………………… 184
        第7 章　优化算法… …………………… 185
        7.1　优化与深度学习…………………………… 185
        7.1.1　优化与深度学习的关系 … ……… 185
        7.1.2　优化在深度学习中的挑战 … …… 186
        小结………………………………………… 188
        练习………………………………………… 189
        7.2　梯度下降和随机梯度下降… …………… 189
        7.2.1　一维梯度下降 … ………………… 189
        7.2.2　学习率 …………………………… 190
        7.2.3　多维梯度下降 …………………… 191
        7.2.4　随机梯度下降 …………………… 193
        小结………………………………………… 194
        练习………………………………………… 194
        7.3　小批量随机梯度下降… ………………… 194
        7.3.1　读取数据集 … …………………… 195
        7.3.2　从零开始实现 …………………… 196
        7.3.3　简洁实现 ………………………… 198
        小结………………………………………… 199
        练习………………………………………… 199
        7.4　动量法… …………………………………200
        7.4.1　梯度下降的问题 … ……………… 200
        7.4.2　动量法 …………………………… 201
        ·6·　目　　录
        7.4.3　从零开始实现 …………………… 203
        7.4.4　简洁实现 ………………………… 205
        小结………………………………………… 205
        练习………………………………………… 205
        7.5　AdaGrad算法……………………………206
        7.5.1　算法 … …………………………… 206
        7.5.2　特点 ……………………………… 206
        7.5.3　从零开始实现 …………………… 208
        7.5.4　简洁实现 ………………………… 209
        小结………………………………………… 209
        练习………………………………………… 209
        7.6　RMSProp算法… ………………………209
        7.6.1　算法 … …………………………… 210
        7.6.2　从零开始实现 …………………… 211
        7.6.3　简洁实现 ………………………… 212
        小结………………………………………… 212
        练习………………………………………… 212
        7.7　AdaDelta算法… ……………………… 212
        7.7.1　算法… …………………………… 212
        7.7.2　从零开始实现 …………………… 213
        7.7.3　简洁实现 ………………………… 214
        小结………………………………………… 214
        练习………………………………………… 214
        7.8　Adam算法… …………………………… 215
        7.8.1　算法 … …………………………… 215
        7.8.2　从零开始实现 …………………… 216
        7.8.3　简洁实现 ………………………… 216
        小结………………………………………… 217
        练习………………………………………… 217
        第8 章　计算性能… …………………… 218
        8.1　命令式和符号式混合编程… …………… 218
        8.1.1　混合式编程取两者之长 … ……… 220
        8.1.2　使用HybridSequential类构造模型 … …………………………… 220
        8.1.3　使用HybridBlock类构造模型… …………………………… 222
        小结………………………………………… 224
        练习………………………………………… 224
        8.2　异步计算… ………………………………224
        8.2.1　MXNet中的异步计算 …………… 224
        8.2.2　用同步函数让前端等待计算结果 … …………………………… 226
        8.2.3　使用异步计算提升计算性能 …… 226
        8.2.4　异步计算对内存的影响 ………… 227
        小结………………………………………… 229
        练习………………………………………… 229
        8.3　自动并行计算… …………………………229
        8.3.1　CPU和GPU的并行计算 … …… 230
        8.3.2　计算和通信的并行计算 ………… 231
        小结………………………………………… 231
        练习………………………………………… 231
        8.4　多GPU计算……………………………… 232
        8.4.1　数据并行 … ……………………… 232
        8.4.2　定义模型 ………………………… 233
        8.4.3　多GPU之间同步数据 … ……… 234
        8.4.4　单个小批量上的多GPU训练 … …………………………… 236
        8.4.5　定义训练函数 …………………… 236
        8.4.6　多GPU训练实验 … …………… 237
        小结………………………………………… 237
        练习………………………………………… 237
        8.5　多GPU计算的简洁实现………………… 237
        8.5.1　多GPU上初始化模型参数……… 238
        8.5.2　多GPU训练模型 … …………… 239
        小结………………………………………… 241
        练习………………………………………… 241
        第9 章　计算机视觉… ………………… 242
        9.1　图像增广…………………………………242
        9.1.1　常用的图像增广方法 … ………… 243
        9.1.2　使用图像增广训练模型 … ……… 246
        小结………………………………………… 250
        练习………………………………………… 250
        9.2　微调… ……………………………………250
        热狗识别 … ……………………………… 251
        小结………………………………………… 255
        练习………………………………………… 255
        目　　录　·7·
        9.3　目标检测和边界框… ……………………255
        边界框 … ………………………………… 256
        小结………………………………………… 257
        练习………………………………………… 257
        9.4　锚框… …………………………………… 257
        9.4.1　生成多个锚框… ………………… 257
        9.4.2　交并比 …………………………… 259
        9.4.3　标注训练集的锚框 ……………… 260
        9.4.4　输出预测边界框… ……………… 263
        小结………………………………………… 265
        练习………………………………………… 265
        9.5　多尺度目标检测… ………………………265
        小结………………………………………… 268
        练习………………………………………… 268
        9.6　目标检测数据集（皮卡丘）… …………268
        9.6.1　获取数据集 … …………………… 269
        9.6.2　读取数据集… …………………… 269
        9.6.3　图示数据 ………………………… 270
        小结………………………………………… 270
        练习………………………………………… 271
        9.7　单发多框检测（SSD）… ……………… 271
        9.7.1　定义模型… ……………………… 271
        9.7.2　训练模型 ………………………… 275
        9.7.3　预测目标 ………………………… 277
        小结………………………………………… 278
        练习………………………………………… 278
        9.8　区域卷积神经网络（R-CNN）系列……280
        9.8.1　R-CNN … ……………………… 280
        9.8.2　Fast R-CNN …………………… 281
        9.8.3　Faster R-CNN ………………… 283
        9.8.4　Mask R-CNN … ……………… 284
        小结………………………………………… 285
        练习………………………………………… 285
        9.9　语义分割和数据集… ……………………285
        9.9.1　图像分割和实例分割 … ………… 285
        9.9.2　Pascal VOC2012语义分割数据集 … ………………………… 286
        小结………………………………………… 290
        练习………………………………………… 290
        9.10　全卷积网络（FCN）… ………………290
        9.10.1　转置卷积层 …………………… 291
        9.10.2　构造模型 … …………………… 292
        9.10.3　初始化转置卷积层……………… 294
        9.10.4　读取数据集 … ………………… 295
        9.10.5　训练模型………………………… 296
        9.10.6　预测像素类别…………………… 296
        小结………………………………………… 297
        练习………………………………………… 297
        9.11　样式迁移… ………………………………298
        9.11.1　方法 ……………………………… 298
        9.11.2　读取内容图像和样式图像……… 299
        9.11.3　预处理和后处理图像 ………… 300
        9.11.4　抽取特征 ……………………… 301
        9.11.5　定义损失函数 ………………… 302
        9.11.6　创建和初始化合成图像 ……… 303
        9.11.7　训练模型………………………… 304
        小结………………………………………… 306
        练习………………………………………… 306
        9.12　实战Kaggle比赛：图像
        分类（CIFAR-10）……………………306
        9.12.1　获取和整理数据集 ……………… 307
        9.12.2　图像增广 … …………………… 310
        9.12.3　读取数据集 … ………………… 310
        9.12.4　定义模型………………………… 311
        9.12.5　定义训练函数 … ……………… 312
        9.12.6　训练模型 … …………………… 312
        9.12.7　对测试集分类并在Kaggle
        提交结果 … …………………… 313
        小结………………………………………… 313
        练习………………………………………… 313
        9.13　实战Kaggle比赛：狗的品种
        识别（ImageNet Dogs）…………… 314
        9.13.1　获取和整理数据集 …………… 315
        9.13.2　图像增广 … …………………… 316
        9.13.3　读取数据集 … ………………… 317
        9.13.4　定义模型 … …………………… 318
        9.13.5　定义训练函数 … ……………… 318
        9.13.6　训练模型 … …………………… 319
        ·8·　目　　录
        9.13.7　对测试集分类并在Kaggle提交结果 … …………………… 319
        小结………………………………………… 320
        练习………………………………………… 320
        第10 章　自然语言处理………………… 321
        10.1　词嵌入（word2vec）………………… 321
        10.1.1　为何不采用one-hot向量… …… 321
        10.1.2　跳字模型 ………………………… 322
        10.1.3　连续词袋模型 …………………… 323
        小结………………………………………… 325
        练习………………………………………… 325
        10.2　近似训练…………………………………325
        10.2.1　负采样 …………………………… 325
        10.2.2　层序softmax …………………… 326
        小结………………………………………… 327
        练习………………………………………… 328
        10.3　word2vec的实现………………………328
        10.3.1　预处理数据集 …………………… 328
        10.3.2　负采样 … ……………………… 331
        10.3.3　读取数据集 … ………………… 331
        10.3.4　跳字模型 … …………………… 332
        10.3.5　训练模型 … …………………… 333
        10.3.6　应用词嵌入模型 … …………… 335
        小结………………………………………… 336
        练习………………………………………… 336
        10.4　子词嵌入（fastText）… ……………336
        小结………………………………………… 337
        练习………………………………………… 337
        10.5　全局向量的词嵌入（GloVe）…………337
        10.5.1　GloVe模型 …………………… 338
        10.5.2　从条件概率比值理解GloVe模型……………………… 339
        小结………………………………………… 340
        练习………………………………………… 340
        10.6　求近义词和类比词………………………340
        10.6.1　使用预训练的词向量 ………… 340
        10.6.2　应用预训练词向量 … ………… 341
        小结………………………………………… 343
        练习………………………………………… 343
        10.7　文本情感分类：使用循环神经网络…… 343
        10.7.1　文本情感分类数据集 ………… 343
        10.7.2　使用循环神经网络的模型……… 345
        小结………………………………………… 347
        练习………………………………………… 347
        10.8　文本情感分类：使用卷积神经网络（textCNN）… …………………347
        10.8.1　一维卷积层 … ………………… 348
        10.8.2　时序最大池化层 … …………… 349
        10.8.3　读取和预处理IMDb数据集 … ……………………… 350
        10.8.4　textCNN模型 … ……………… 350
        小结………………………………………… 353
        练习………………………………………… 353
        10.9　编码器-解码器（seq2seq）…………353
        10.9.1　编码器 ………………………… 354
        10.9.2　解码器 … ……………………… 354
        10.9.3　训练模型………………………… 355
        小结………………………………………… 355
        练习………………………………………… 355
        10.10　 束搜索… ………………………………355
        10.10.1　贪婪搜索 … …………………… 356
        10.10.2　穷举搜索 ……………………… 357
        10.10.3　束搜索 ………………………… 357
        小结………………………………………… 358
        练习………………………………………… 358
        10.11　注意力机制… …………………………358
        10.11.1　计算背景变量 … ……………… 359
        10.11.2　更新隐藏状态 … ……………… 360
        10.11.3　发展… ………………………… 361
        小结………………………………………… 361
        练习………………………………………… 361
        10.12　机器翻译… …………………………… 361
        10.12.1　读取和预处理数据集… ……… 361
        10.12.2　含注意力机制的编码器-解码器 … …………… 363
        10.12.3　训练模型 ……………………… 365
        10.12.4　预测不定长的序列… ………… 367
        10.12.5　评价翻译结果 ………………… 367
        小结………………………………………… 369
        练习………………………………………… 369
        附录A　数学基础… …………………… 370
        附录B　使用 Jupyter 记事本… ……… 376
        附录C　使用 AWS 运行代码…………… 381
        附录D　GPU 购买指南………………… 388
        附录E　如何为本书做贡献… ………… 391
        附录F　d2lzh 包索引…………………… 395
        附录G　中英文术语对照表… ………… 397
        参考文献………………………………… 402
        索引……………………………………… 407
     · · · · · ·     (收起)"
26349607,MATLAB之父:编程实践(中译本),9.3,(20人评价),[ MEI ] Cleve Moler / 薛定宇 / 北京航空航天大学出版社 / 2014-3-1 / 39.9,《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Compu...,https://book.douban.com/subject/26349607/,https://img9.doubanio.com/view/subject/s/public/s28031915.jpg,39.9,9787512414655,"《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求...(展开全部)





《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求式的好奇精神。强烈的好奇心，是克利夫给人留下的最深印象，大到人文历史风土人情，小到会议讲座礼尚往来，他都保持着一种童真般的好奇。这种强烈的好奇心也可以从这本书涉猎广泛的内容中得到体会―― 矩阵、历法、谷歌网页排名、音乐、天体运行、分形图、生命进化、数独等等包罗万象。 这些精彩的内容连同生动文笔都在薛定宇老师的译本中得到了很好的体现。薛老师自己的书在读者中享有很高声誉，我最早拜读的就是他写的自动控制领域经典的教材《控制系统计算机辅助设计―― MATLAB 语言与应用》，结构严谨，思维缜密，内容翔实。这种风格在此书中文版的翻译中与原文达到了奇妙融合，使读者在领略克利夫的独特思路时逻辑清晰，而且兴趣盎然，一定是一次非常愉快的阅读体验。 《MATLAB 之父：编程实践》是北京航空航天大学出版社与迈斯沃克公司在图书合作方面的一个杰作，是迈斯沃克公司近两年中国图书计划中最重要的一个项目。《MATLAB之父：编程实践》一书也获得国内最大的MATLAB/Simulink技术交流平台——MATLAB中文论坛的鼎力推荐,MATLAB中文论坛的“MATLAB读书频道”为本书提供了专门版块供读者交流，以期共同进步。","作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国...(展开全部)




作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国家工程院院士，并获多项荣誉，包括瑞典林学平大学荣誉学位，加拿大滑铁卢大学荣誉数学博士学位，丹麦科技大学荣誉博士等。Cleve还获得IEEE计算机学会的2012年计算机先驱奖。","写在前面
        译者的话
        前言
        第1章迭代（Iteration）1
        第2章斐波那契数（FibonacciNumbers）15
        第3章日历与时钟（CalendarsandClocks）29
        第4章矩阵（Matrices）39
        第5章线性方程组（LinearEquations）53
        第6章蕨型叶分形（FractalFern）63
        第7章谷歌的网页排名值（GooglePageRank）71
        第8章指数函数（ExponentialFunction）85
        第9章T形积木（TPuzzle）99
        第10章幻方问题（MagicSquares）107
        第11章井字棋的魅力（TicTacToeMagic）123
        第12章生命游戏（GameofLife）131
        第13章曼德勃罗集（MandelbrotSet）141
        第14章数独（Sudoku）159
        第15章常微分方程（OrdinaryDifferentialEquations）173
        第16章捕食者与猎物模型（Predator-PreyModel）185
        第17章轨道（Orbits）191
        第18章浅水方程（ShallowWaterEquations）207
        第19章摩尔斯电码（MorseCode）211
        第20章音乐（Music）227
     · · · · · ·     (收起)"
35602582,现代C++语言核心特性解析,8.9,(46人评价),谢丙堃 / 人民邮电出版社 / 2021-10,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还...,https://book.douban.com/subject/35602582/,https://img3.doubanio.com/view/subject/s/public/s33999027.jpg,,9787115564177,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理，让读者能够知其然也知其所以然。本书适合出于工作需要而学习 C++ 新特性的 C++ 从业者，也适合对 C++ 新特性有浓烈兴趣的 C++ 爱好者。而对 C++ 入门者来说，也有必要在有一定的 C++ 基础后阅读本书，通过本书来进一步学习 C++ 的核心特性。本书的多媒体版本已由“盛格塾”以微信小程序方式推出，包含作者的语音讲解、插图、PPT 和示例代码。读者可以在手机上学习，也可以在线提问，与老师和其他同学互动。,谢丙堃，从事 C++ 开发工作十余年，先后在数家知名互联网公司担任 C++ 高级开发工程师、技术专家和技术经理。他也是 C++ 语言的爱好者，热衷于研究 C++ 语言的新特性以及 C++ 模板元编程技术。,"第1章　新基础类型（C++11～C++20） 1
        1.1 整数类型long long 1
        1.2 新字符类型char16_t和char32_t 4
        1.2.1 字符集和编码方法 4
        1.2.2 使用新字符类型char16_t和char32_t 5
        1.2.3 wchar_t存在的问题 6
        1.2.4 新字符串连接 7
        1.2.5 库对新字符类型的支持 7
        1.3 char8_t字符类型 8
        1.4 总结 8
        第2章　内联和嵌套命名空间（C++11～C++20） 9
        2.1 内联命名空间的定义和使用 9
        2.2 嵌套命名空间的简化语法 11
        2.3 总结 13
        第3章　auto占位符（C++11～C++17） 14
        3.1 重新定义的auto关键字 14
        3.2 推导规则 16
        3.3 什么时候使用auto 18
        3.4 返回类型推导 20
        3.5 lambda表达式中使用auto类型推导 20
        3.6 非类型模板形参占位符 21
        3.7 总结 22
        第4章　decltype说明符（C++11～C++17） 23
        4.1 回顾typeof和typeid 23
        4.2 使用decltype说明符 24
        4.3 推导规则 27
        4.4 cv限定符的推导 29
        4.5 decltype(auto) 30
        4.6 decltype(auto)作为非类型模板形参占位符 31
        4.7 总结 32
        第5章　函数返回类型后置（C++11） 33
        5.1 使用函数返回类型后置声明函数 33
        5.2 推导函数模板返回类型 34
        5.3 总结 36
        第6章　右值引用（C++11 C++17 C++20） 37
        6.1 左值和右值 37
        6.2 左值引用 39
        6.3 右值引用 40
        6.4 右值的性能优化空间 42
        6.5 移动语义 43
        6.6 值类别 47
        6.7 将左值转换为右值 48
        6.8 万能引用和引用折叠 50
        6.9 完美转发 52
        6.10 针对局部变量和右值引用的隐式移动操作 55
        6.11 总结 57
        第7章　lambda表达式（C++11～C++20） 58
        7.1 lambda表达式语法 58
        7.2 捕获列表 60
        7.2.1 作用域 60
        7.2.2 捕获值和捕获引用 61
        7.2.3 特殊的捕获方法 64
        7.3 lambda表达式的实现原理 65
        7.4 无状态lambda表达式 68
        7.5 在STL中使用lambda表达式 68
        7.6 广义捕获 69
        7.7 泛型lambda表达式 72
        7.8 常量lambda表达式和捕获*this 72
        7.9 捕获[=, this] 73
        7.10 模板语法的泛型lambda表达式 74
        7.11 可构造和可赋值的无状态lambda表达式 76
        7.12 总结 77
        第8章　非静态数据成员默认初始化（C++11 C++20） 78
        8.1 使用默认初始化 78
        8.2 位域的默认初始化 79
        8.3 总结 80
        第9章　列表初始化（C++11 C++20） 81
        9.1 回顾变量初始化 81
        9.2 使用列表初始化 82
        9.3 std::initializer_list详解 84
        9.4 使用列表初始化的注意事项 86
        9.4.1 隐式缩窄转换问题 86
        9.4.2 列表初始化的优先级问题 87
        9.5 指定初始化 88
        9.6 总结 90
        第10章　默认和删除函数（C++11） 91
        10.1 类的特殊成员函数 91
        10.2 显式默认和显式删除 95
        10.3 显式删除的其他用法 98
        10.4 explicit和=delete 99
        10.5 总结 100
        第11章　非受限联合类型（C++11） 101
        11.1 联合类型在C++中的局限性 101
        11.2 使用非受限联合类型 102
        11.3 总结 106
        第12章　委托构造函数（C++11） 107
        12.1 冗余的构造函数 107
        12.2 委托构造函数 110
        12.3 委托模板构造函数 114
        12.4 捕获委托构造函数的异常 115
        12.5 委托参数较少的构造函数 116
        12.6 总结 117
        第13章　继承构造函数（C++11） 118
        13.1 继承关系中构造函数的困局 118
        13.2 使用继承构造函数 119
        13.3 总结 123
        第14章　强枚举类型（C++11 C++17 C++20） 124
        14.1 枚举类型的弊端 124
        14.2 使用强枚举类型 129
        14.3 列表初始化有底层类型枚举对象 131
        14.4 使用using打开强枚举类型 133
        14.5 总结 135
        第15章　扩展的聚合类型（C++17 C++20） 136
        15.1 聚合类型的新定义 136
        15.2 聚合类型的初始化 137
        15.3 扩展聚合类型的兼容问题 139
        15.4 禁止聚合类型使用用户声明的构造函数 140
        15.5 使用带小括号的列表初始化聚合类型对象 142
        15.6 总结 143
        第16章　override和final说明符（C++11） 144
        16.1 重写、重载和隐藏 144
        16.2 重写引发的问题 145
        16.3 使用override说明符 145
        16.4 使用final说明符 146
        16.5 override和final说明符的特别之处 148
        16.6 总结 148
        第17章　基于范围的for循环（C++11 C++17 C++20） 149
        17.1 烦琐的容器遍历 149
        17.2 基于范围的for循环语法 150
        17.3 begin和end函数不必返回相同类型 151
        17.4 临时范围表达式的陷阱 152
        17.5 实现一个支持基于范围的for循环的类 153
        17.6 总结 155
        第18章　支持初始化语句的if和switch（C++17） 156
        18.1 支持初始化语句的if 156
        18.2 支持初始化语句的switch 159
        18.3 总结 160
        第19章　static_assert声明 161
        19.1 运行时断言 161
        19.2 静态断言的需求 162
        19.3 静态断言 163
        19.4 单参数static_assert 164
        19.5 总结 165
        第20章　结构化绑定（C++17 C++20） 166
        20.1 使用结构化绑定 166
        20.2 深入理解结构化绑定 169
        20.3 结构化绑定的3种类型 171
        20.3.1 绑定到原生数组 171
        20.3.2 绑定到结构体和类对象 172
        20.3.3 绑定到元组和类元组的对象 173
        20.4 实现一个类元组类型 175
        20.5 绑定的访问权限问题 178
        20.6 总结 179
        第21章　noexcept关键字（C++11 C++17 C++20） 180
        21.1 使用noexcept代替throw 180
        21.2 用noexcept来解决移动构造问题 183
        21.3 noexcept和throw() 185
        21.4 默认使用noexcept的函数 186
        21.5 使用noexcept的时机 189
        21.6 将异常规范作为类型的一部分 190
        21.7 总结 192
        第22章　类型别名和别名模板（C++11 C++14） 193
        22.1 类型别名 193
        22.2 别名模板 194
        22.3 总结 196
        第23章　指针字面量nullptr（C++11） 197
        23.1 零值整数字面量 197
        23.2 nullptr关键字 198
        23.3 总结 201
        第24章　三向比较（C++20） 202
        24.1 “太空飞船”（spaceship）运算符 202
        24.2 三向比较的返回类型 202
        24.2.1 std::strong_ordering 203
        24.2.2 std::weak_ordering 204
        24.2.3 std::partial_ordering 205
        24.3 对基础类型的支持 206
        24.4 自动生成的比较运算符函数 207
        24.5 兼容旧代码 210
        24.6 总结 211
        第25章　线程局部存储（C++11） 212
        25.1 操作系统和编译器对线程局部存储的支持 212
        25.2 thread_local说明符 213
        25.3 总结 217
        第26章　扩展的inline说明符（C++17） 218
        26.1 定义非常量静态成员变量的问题 218
        26.2 使用inline说明符 219
        26.3 总结 220
        第27章　常量表达式（C++11～C++20） 221
        27.1 常量的不确定性 221
        27.2 constexpr值 224
        27.3 constexpr函数 225
        27.4 constexpr构造函数 228
        27.5 对浮点的支持 230
        27.6 C++14标准对常量表达式函数的增强 230
        27.7 constexpr lambdas表达式 233
        27.8 constexpr的内联属性 235
        27.9 if constexpr 236
        27.10 允许constexpr虚函数 240
        27.11 允许在constexpr函数中出现Try-catch 244
        27.12 允许在constexpr中进行平凡的默认初始化 244
        27.13 允许在constexpr中更改联合类型的有效成员 245
        27.14 使用consteval声明立即函数 246
        27.15 使用constinit检查常量初始化 247
        27.16 判断常量求值环境 248
        27.17 总结 252
        第28章　确定的表达式求值顺序（C++17） 253
        28.1 表达式求值顺序的不确定性 253
        28.2 表达式求值顺序详解 254
        28.3 总结 255
        第29章　字面量优化（C++11～C++17） 257
        29.1 十六进制浮点字面量 257
        29.2 二进制整数字面量 258
        29.3 单引号作为整数分隔符 258
        29.4 原生字符串字面量 259
        29.5 用户自定义字面量 261
        29.6 总结 267
        第30章　alignas和alignof（C++11 C++17） 268
        30.1 不可忽视的数据对齐问题 268
        30.2 C++11标准之前控制数据对齐的方法 270
        30.3 使用alignof运算符 272
        30.4 使用alignas说明符 273
        30.5 其他关于对齐字节长度的支持 276
        30.6 C++17中使用new分配指定对齐字节长度的对象 278
        30.7 总结 279
        第31章　属性说明符和标准属性（C++11～C++20） 280
        31.1 GCC的属性语法 280
        31.2 MSVC的属性语法 281
        31.3 标准属性说明符语法 282
        31.4 使用using打开属性的命名空间 283
        31.5 标准属性 283
        31.5.1 noreturn 284
        31.5.2 carries_dependency 286
        31.5.3 deprecated 286
        31.5.4 fallthrough 287
        31.5.5 nodiscard 288
        31.5.6 maybe_unused 290
        31.5.7 likely和unlikely 290
        31.5.8 no_unique_address 291
        31.6 总结 293
        第32章　新增预处理器和宏（C++17 C++20） 294
        32.1 预处理器__has_include 294
        32.2 特性测试宏 295
        32.2.1 属性特性测试宏 295
        32.2.2 语言功能特性测试宏 295
        32.2.3 标准库功能特性测试宏 297
        32.3 新增宏__VA_OPT__ 301
        32.4 总结 302
        第33章　协程（C++20） 303
        33.1 协程的使用方法 303
        33.2 协程的实现原理 308
        33.2.1 co_await运算符原理 308
        33.2.2 co_yield运算符原理 313
        33.2.3 co_return运算符原理 317
        33.2.4 promise_type的其他功能 319
        33.3 总结 320
        第34章　基础特性的其他优化（C++11～C++20） 321
        34.1 显式自定义类型转换运算符（C++11） 321
        34.2 关于std::launder()（C++17） 325
        34.3 返回值优化（C++11～C++17） 326
        34.4 允许按值进行默认比较（C++20） 333
        34.5 支持new表达式推导数组长度（C++20） 334
        34.6 允许数组转换为未知范围的数组（C++20） 335
        34.7 在delete运算符函数中析构对象（C++20） 336
        34.8 调用伪析构函数结束对象声明周期（C++20） 337
        34.9 修复const和默认复制构造函数不匹配造成无法编译的问题（C++20） 338
        34.10 不推荐使用volatile的情况（C++20） 339
        34.11 不推荐在下标表达式中使用逗号运算符（C++20） 340
        34.12 模块（C++20） 340
        34.13 总结 341
        第35章　可变参数模板（C++11 C++17 C++20） 342
        35.1 可变参数模板的概念和语法 342
        35.2 形参包展开 344
        35.3 sizeof...运算符 352
        35.4 可变参数模板的递归计算 353
        35.5 折叠表达式 354
        35.6 一元折叠表达式中空参数包的特殊处理 357
        35.7 using声明中的包展开 358
        35.8 lambda表达式初始化捕获的包展开 359
        35.9 总结 361
        第36章　typename优化（C++17 C++20） 362
        36.1 允许使用typename声明模板形参 362
        36.2 减少typename使用的必要性 363
        36.3 总结 365
        第37章　模板参数优化（C++11 C++17 C++20） 366
        37.1 允许常量求值作为所有非类型模板的实参 366
        37.2 允许局部和匿名类型作为模板实参 368
        37.3 允许函数模板的默认模板参数 369
        37.4 函数模板添加到ADL查找规则 370
        37.5 允许非类型模板形参中的字面量类类型 371
        37.6 扩展的模板参数匹配规则 373
        37.7 总结 374
        第38章　类模板的模板实参推导（C++17 C++20） 375
        38.1 通过初始化构造推导类模板的模板实参 375
        38.2 拷贝初始化优先 377
        38.3 lambda类型的用途 378
        38.4 别名模板的类模板实参推导 380
        38.5 聚合类型的类模板实参推导 380
        38.6 总结 382
        第39章　用户自定义推导指引（C++17） 383
        39.1 使用自定义推导指引推导模板实例 383
        39.2 聚合类型类模板的推导指引 386
        39.3 总结 387
        第40章　SFINAE（C++11） 388
        40.1 替换失败和编译错误 388
        40.2 SFINAE规则详解 389
        40.3 总结 394
        第41章　概念和约束（C++20） 395
        41.1 使用std::enable_if约束模板 395
        41.2 概念的背景介绍 396
        41.3 使用concept和约束表达式定义概念 397
        41.4 requires子句和约束检查顺序 398
        41.5 原子约束 401
        41.6 requires表达式 403
        41.6.1 简单要求 404
        41.6.2 类型要求 405
        41.6.3 复合要求 405
        41.6.4 嵌套要求 406
        41.7 约束可变参数模板 407
        41.8 约束类模板特化 408
        41.9 约束auto 409
        41.10 总结 410
        第42章　模板特性的其他优化（C++11 C++14） 411
        42.1 外部模板（C++11） 411
        42.2 连续右尖括号的解析优化（C++11） 413
        42.3 friend声明模板形参（C++11） 415
        42.4 变量模板（C++14） 417
        42.5 explicit(bool) 419
        42.6 总结 423
        附录   特性章节对照表 424
     · · · · · ·     (收起)"
36303408,深度学习入门2,9.7,(32人评价),[日]斋藤康毅 / 郑明智 / 人民邮电出版社 / 2023-3 / 129.80元,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。
手把手带你创建深度学习框架，直击现代深度学习框架本质！
◎ 编辑推荐
• 简明易懂，讲...",https://book.douban.com/subject/36303408/,https://img3.doubanio.com/view/subject/s/public/s34476102.jpg,129.80元,9787115607515,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，...(展开全部)





“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，本书旨在揭开这些技术和机制的神秘面纱，帮助读者正确理解技术，体会它们的有趣之处。为此，本书会带领读者从零开始创建一个深度学习框架——DeZero。 DeZero 是本书原创的框架，它用最少的代码实现了现代深度学习框架的功能。本书分60 个步骤来完成这个框架，在此过程中，读者会加深对PyTorch、TensorFlow 和Chainer 等现代深度学习框架的理解，看清深度学习框架的本质。 本书沿袭《深度学习入门：基于Python 的理论与实现》的风格，语言通俗，代码简洁，讲解详细。在自制框架的过程中，读者还能进一步巩固Python 编程和软件开发相关的知识。 本书适合对深度学习框架感兴趣的读者阅读。",斋藤康毅 1984年生于日本长崎县，东京工业大学毕业，并完成东京大学研究生院课程。目前在某企业从事人工智能相关的研究和开发工作。著有《深度学习入门：基于Python的理论与实现》，同时也是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。,"前言
        第1阶段 自动微分 1
        步骤1 作为“箱子”的变量  3
        1.1 什么是变量  3
        1.2 实现Variable类  4
        1.3 （补充）NumPy的多维数组    6
        步骤2 创建变量的函数     8
        2.1 什么是函数      8
        2.2 Function类的实现   9
        2.3 使用Function类     10
        步骤3 函数的连续调用       13
        3.1 Exp函数的实现     13
        3.2 函数的连续调用     14
        步骤4 数值微分       16
        4.1 什么是导数       16
        4.2 数值微分的实现     17
        4.3 复合函数的导数     20
        4.4 数值微分存在的问题      21
        步骤5 反向传播的理论知识       22
        5.1 链式法则        22
        5.2 反向传播的推导      23
        5.3 用计算图表示       25
        步骤6 手动进行反向传播        27
        6.1 Variable类的功能扩展       27
        6.2 Function类的功能扩展       28
        6.3 Square类和Exp类的功能扩展      28
        6.4 反向传播的实现      29
        步骤7 反向传播的自动化        32
        7.1 为反向传播的自动化创造条件      33
        7.2 尝试反向传播       36
        7.3 增加backward方法       38
        步骤8 从递归到循环        40
        8.1 现在的Variable类       40
        8.2 使用循环实现       41
        8.3 代码验证        42
        步骤9 让函数更易用        43
        9.1 作为Python函数使用       43
        9.2 简化backward方法       45
        9.3 只支持ndarray       46
        步骤10 测试         50
        10.1 Python的单元测试       50
        10.2 square函数反向传播的测试      52
        10.3 通过梯度检验来自动测试      53
        10.4 测试小结       54
        第2阶段 用自然的代码表达       59
        步骤11 可变长参数（正向传播篇)       61
        11.1 修改Function类       62
        11.2 Add类的实现      64
        步骤12 可变长参数（改进篇)        65
        12.1 第1项改进：使函数更容易使用      65
        12.2 第2项改进：使函数更容易实现      67
        12.3 add函数的实现       69
        步骤13 可变长参数（反向传播篇)       70
        13.1 支持可变长参数的Add类的反向传播     70
        13.2 修改Variable类       71
        13.3 Square类的实现      73
        步骤14 重复使用同一个变量        75
        14.1 问题的原因 76
        14.2 解决方案       77
        14.3 重置导数       79
        步骤15 复杂的计算图（理论篇）81
        15.1 反向传播的正确顺序       82
        15.2 当前的DeZero        84
        15.3 函数的优先级      87
        步骤16 复杂的计算图（实现篇）88
        16.1 增加“辈分”变量      88
        16.2 按照“辈分”顺序取出元素     90
        16.3 Variable类的backward       92
        16.4 代码验证       93
        步骤17 内存管理和循环引用        97
        17.1 内存管理       97
        17.2 引用计数方式的内存管理      98
        17.3 循环引用      100
        17.4 weakref模块      102
        17.5 代码验证      104
        步骤18 减少内存使用量的模式      106
        18.1 不保留不必要的导数      106
        18.2 回顾Function类      109
        18.3 使用Confifig类进行切换      110
        18.4 模式的切换      111
        18.5 使用with语句切换    112
        步骤19 让变量更易用       116
        19.1 命名变量      116
        19.2 实例变量ndarray      117
        19.3 len函数和print函数      119
        步骤20 运算符重载（1）122
        20.1 Mul类的实现      122
        20.2 运算符重载      125
        步骤21 运算符重载（2）128
        21.1 与ndarray一起使用     128
        21.2 与flfloat和int一起使用    130
        21.3 问题1：左项为flfloat或int的情况    131
        21.4 问题2：左项为ndarray实例的情况   133
        步骤22 运算符重载（3）134
        22.1 负数       135
        22.2 减法       136
        22.3 除法       138
        22.4 幂运算       139
        步骤23 打包         141
        23.1 文件结构      142
        23.2 将代码移到核心类     142
        23.3 运算符重载      144
        23.4 实际的_ _init_ _.py文件     146
        23.5 导入dezero       147
        步骤24 复杂函数的求导        149
        24.1 Sphere函数       150
        24.2 matyas函数       151
        24.3 GoldsteinPrice函数      152
        第3阶段 实现高阶导数         161
        步骤25 计算图的可视化（1） 163
        25.1 安装Graphviz       163
        25.2 使用DOT语言描述图形     165
        25.3 指定节点属性     165
        25.4 连接节点      167
        步骤26 计算图的可视化（2）169
        26.1 可视化代码的使用示例      169
        26.2 从计算图转换为DOT语言    171
        26.3 从DOT语言转换为图像     174
        26.4 代码验证      176
        步骤27 泰勒展开的导数        178
        27.1 sin函数的实现       178
        27.2 泰勒展开的理论知识      179
        27.3 泰勒展开的实现     180
        27.4 计算图的可视化     182
        步骤28 函数优化        184
        28.1 Rosenbrock函数      184
        28.2 求导       185
        28.3 梯度下降法的实现     186
        步骤29 使用牛顿法进行优化（手动计算）190
        29.1 使用牛顿法进行优化的理论知识    191
        29.2 使用牛顿法实现优化      195
        步骤30 高阶导数（准备篇） 197
        30.1 确认工作①：Variable实例变量    197
        30.2 确认工作②：Function类     199
        30.3 确认工作③：Variable类的反向传播    201
        步骤31 高阶导数（理论篇） 204
        31.1 在反向传播时进行的计算     204
        31.2 创建反向传播的计算图的方法    206
        步骤32 高阶导数（实现篇） 209
        32.1 新的DeZero       209
        32.2 函数类的反向传播     210
        32.3 实现更有效的反向传播（增加模式控制代码）211
        32.4 修改_ _init_ _.py      213
        步骤33 使用牛顿法进行优化（自动计算） 215
        33.1 求二阶导数      215
        33.2 使用牛顿法进行优化      217
        步骤34 sin函数的高阶导数        219
        34.1 sin函数的实现       219
        34.2 cos函数的实现      220
        34.3 sin函数的高阶导数      221
        步骤35 高阶导数的计算图       225
        35.1 tanh函数的导数     226
        35.2 tanh函数的实现     226
        35.3 高阶导数的计算图可视化     227
        步骤36 DeZero的其他用途        234
        36.1 double backprop的用途     234
        36.2 深度学习研究中的应用示例     236
        第4阶段 创建神经网络         243
        步骤37 处理张量        245
        37.1 对各元素进行计算     245
        37.2 使用张量时的反向传播      247
        37.3 使用张量时的反向传播（补充内容）249
        步骤38 改变形状的函数        254
        38.1 reshape函数的实现      254
        38.2 从Variable对象调用reshape    258
        38.3 矩阵的转置      259
        38.4 实际的transpose函数（补充内容）262
        步骤39 求和的函数        264
        39.1 sum函数的反向传播      264
        39.2 sum函数的实现      266
        39.3 axis和keepdims      268
        步骤40 进行广播的函数        272
        40.1 broadcast_to函数和sum_to函数    272
        40.2 DeZero的broadcast_to函数和sum_to函数  275
        40.3 支持广播      277
        步骤41 矩阵的乘积        280
        41.1 向量的内积和矩阵的乘积     280
        41.2 检查矩阵的形状     282
        41.3 矩阵乘积的反向传播      282
        步骤42 线性回归        288
        42.1 玩具数据集      288
        42.2 线性回归的理论知识      289
        42.3 线性回归的实现     291
        42.4 DeZero的mean_squared_error函数（补充内容）  295
        步骤43 神经网络        298
        43.1 DeZero中的linear函数      298
        43.2 非线性数据集     301
        43.3 激活函数和神经网络      302
        43.4 神经网络的实现     303
        步骤44 汇总参数的层       307
        44.1 Parameter类的实现     307
        44.2 Layer类的实现      309
        44.3 Linear类的实现      312
        44.4 使用Layer实现神经网络    314
        步骤45 汇总层的层        316
        45.1 扩展Layer类      316
        45.2 Model类      319
        45.3 使用Model来解决问题      321
        45.4 MLP类      323
        步骤46 通过Optimizer更新参数      325
        46.1 Optimizer类      325
        46.2 SGD类的实现       326
        46.3 使用SGD类来解决问题     327
        46.4 SGD以外的优化方法     328
        步骤47 softmax函数和交叉熵误差      331
        47.1 用于切片操作的函数      331
        47.2 softmax函数      334
        47.3 交叉熵误差      337
        步骤48 多分类       340
        48.1 螺旋数据集      340
        48.2 用于训练的代码     341
        步骤49 Dataset类和预处理        346
        49.1 Dataset类的实现     346
        49.2 大型数据集的情况     348
        49.3 数据的连接      349
        49.4 用于训练的代码     350
        49.5 数据集的预处理     351
        步骤50 用于取出小批量数据的DataLoader     354
        50.1 什么是迭代器     354
        50.2 使用DataLoader      358
        50.3 accuracy函数的实现      359
        50.4 螺旋数据集的训练代码      360
        步骤51 MINST的训练       363
        51.1 MNIST数据集       364
        51.2 训练MNIST       366
        51.3 改进模型      368
        第5阶段 DeZero高级挑战      377
        步骤52 支持GPU        379
        52.1 CuPy的安装和使用方法     379
        52.2 cuda模块      382
        52.3 向Variable / Layer / DataLoader类添加代码   383
        52.4 函数的相应修改     386
        52.5 在GPU上训练MNIST      388
        步骤53 模型的保存和加载       391
        53.1 NumPy的save函数和load函数     391
        53.2 Layer类参数的扁平化    394
        53.3 Layer类的save函数和load函数     395
        步骤54 Dropout和测试模式       398
        54.1 什么是Dropout      398
        54.2 Inverted Dropout     401
        54.3 增加测试模式     401
        54.4 Dropout的实现      402
        步骤55 CNN的机制（1） 404
        55.1 CNN的网络结构      404
        55.2 卷积运算      405
        55.3 填充       407
        55.4 步幅       408
        55.5 输出大小的计算方法      409
        步骤56 CNN的机制（2）411
        56.1 三阶张量      411
        56.2 结合方块进行思考     412
        56.3 小批量处理      414
        56.4 池化层       415
        步骤57 conv2d函数和pooling函数     418
        57.1 使用im2col展开     418
        57.2 conv2d函数的实现      420
        57.3 Conv2d层的实现      425
        57.4 pooling函数的实现      426
        步骤58 具有代表性的CNN（VGG16）429
        58.1 VGG16的实现      429
        58.2 已训练的权重数据     431
        58.3 使用已训练的VGG16     435
        步骤59 使用RNN处理时间序列数据      438
        59.1 RNN层的实现       438
        59.2 RNN模型的实现      442
        59.3 切断连接的方法     445
        59.4 正弦波的预测     446
        步骤60 LSTM与数据加载器       451
        60.1 用于时间序列数据的数据加载器    451
        60.2 LSTM层的实现      453
        附录A inplace运算（步骤14的补充内容）463
        A.1 问题确认        463
        A.2 关于复制和覆盖        464
        A.3 DeZero的反向传播        465
        附录B 实现get_item函数（步骤47的补充内容）466
        附录C 在Google Colaboratory上运行      469
        后 记         473
        参考文献          477
     · · · · · ·     (收起)"
35863224,C++20高级编程(第5版),8.4,(195人评价),[比]马克·格雷戈勒（Marc Gregoire） / 程序喵大人、惠惠、墨梵 / 清华大学出版社 / 2022-4 / 228,"拥抱C++的深度和复杂性，挖掘更多可能
众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉...",https://book.douban.com/subject/35863224/,https://img3.doubanio.com/view/subject/s/public/s34341252.jpg,228,9787302602132,"拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函...(展开全部)





拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函数等 ● 深入讨论新的C++20标准库功能，例如文本格式化、范围、原子智能指针、同步原语、日期、时区等","Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Win...(展开全部)




Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Windows和Linux平台上开发24×7运行的C++程序，例如KNX/EIB家庭自动化监控软件。除了C/C++之外，Marc还喜欢C#。 2007年4月，他凭借Visual C++方面的专业技能，获得了微软年度MVP称号。 Marc还是比利时C++用户组(www.becpp.org)的创始人，是C++ Standard Library Quick Reference 第1版和第2版(Apress)的共同作者，以及多家出版社出版的多种书籍的技术编辑，是C++大会CppCon的活跃演讲者。","第I部分  专业的C++简介
        第1章  C++和标准库速成   3
        1.1  C++速成   3
        1.1.1  小程序“Hello World”   4
        1.1.2  名称空间   7
        1.1.3  字面量   9
        1.1.4  变量   9
        1.1.5  运算符   12
        1.1.6  枚举类型   14
        1.1.7  结构体   16
        1.1.8  条件语句   17
        1.1.9  条件运算符   19
        1.1.10  逻辑比较运算符   20
        1.1.11  三向比较运算符   21
        1.1.12  函数   22
        1.1.13  属性   23
        1.1.14  C风格的数组   26
        1.1.15  std::array   27
        1.1.16  std::vector   28
        1.1.17  std::pair   28
        1.1.18  std::optional   29
        1.1.19  结构化绑定   30
        1.1.20  循环   30
        1.1.21  初始化列表   31
        1.1.22  C++中的字符串   32
        1.1.23  作为面向对象语言的C++   32
        1.1.24  作用域解析   35
        1.1.25  统一初始化   36
        1.1.26  指针和动态内存   39
        1.1.27  const的用法   43
        1.1.28  constexpr关键字   45
        1.1.29  consteval关键字   46
        1.1.30  引用   47
        1.1.31  const_cast()   55
        1.1.32  异常   56
        1.1.33  类型别名   56
        1.1.34  类型定义   57
        1.1.35  类型推断   58
        1.1.36  标准库   60
        1.2  第一个大型的C++程序   61
        1.2.1  雇员记录系统   61
        1.2.2  Employee类   61
        1.2.3  Database类   64
        1.2.4  用户界面   67
        1.2.5  评估程序   69
        1.3  本章小结   69
        1.4  练习   69
        第2章  使用string和string_view   71
        2.1  动态字符串   71
        2.1.1  C风格字符串   71
        2.1.2  字符串字面量   73
        2.1.3  C++ std::string类   75
        2.1.4  数值转换   78
        2.1.5  std::string_view类   81
        2.1.6  非标准字符串   84
        2.2  字符串格式化   84
        2.2.1  格式说明符   85
        2.2.2  格式说明符错误   87
        2.2.3  支持自定义类型   87
        2.3  本章小结   90
        2.4  练习   90
        第3章  编码风格   91
        3.1  良好外观的重要性   91
        3.1.1  事先考虑   91
        3.1.2  良好风格的元素   92
        3.2  为代码编写文档   92
        3.2.1  使用注释的原因   92
        3.2.2  注释的风格   96
        3.3  分解   99
        3.3.1  通过重构分解   100
        3.3.2  通过设计分解   101
        3.3.3  本书中的分解   101
        3.4  命名   101
        3.4.1  选择恰当的名称   101
        3.4.2  命名约定   102
        3.5  使用具有风格的语言特性   103
        3.5.1  使用常量   104
        3.5.2  使用引用代替指针   104
        3.5.3  使用自定义异常   104
        3.6  格式   105
        3.6.1  关于大括号对齐的争论   105
        3.6.2  关于空格和圆括号的争论   106
        3.6.3  空格、制表符、换行符   106
        3.7  风格的挑战   107
        3.8  本章小结   107
        3.9  练习   107
        第II部分  专业的C++软件设计
        第4章  设计专业的C++程序   113
        4.1  程序设计概述   113
        4.2  程序设计的重要性   114
        4.3  C++设计   116
        4.4  C++设计的两个原则   116
        4.4.1  抽象   116
        4.4.2  重用   118
        4.5  重用现有代码   119
        4.5.1  关于术语的说明   119
        4.5.2  决定是否重用代码   120
        4.5.3  重用代码的指导原则   121
        4.6  设计一个国际象棋程序   127
        4.6.1  需求   127
        4.6.2  设计步骤   127
        4.7  本章小结   132
        4.8  练习   133
        第5章  面向对象设计   135
        5.1  过程化的思考方式   135
        5.2  面向对象思想   136
        5.2.1  类   136
        5.2.2  组件   136
        5.2.3  属性   136
        5.2.4  行为   137
        5.2.5  综合考虑   137
        5.3  生活在类的世界里   138
        5.3.1  过度使用类   138
        5.3.2  过于通用的类   139
        5.4  类之间的关系   139
        5.4.1  “有一个”关系   139
        5.4.2  “是一个”关系(继承)   140
        5.4.3  “有一个”与“是一个”的
        区别   142
        5.4.4  not-a关系   144
        5.4.5  层次结构   145
        5.4.6  多重继承   146
        5.4.7  混入类   147
        5.5  本章小结   147
        5.6  练习   148
        第6章  设计可重用代码   149
        6.1  重用哲学   149
        6.2  如何设计可重用代码   150
        6.2.1  使用抽象   150
        6.2.2  构建理想的重用代码   151
        6.2.3  设计有用的接口   157
        6.2.4  设计成功的抽象   162
        6.2.5  SOLID原则   162
        6.3  本章小结   163
        6.4  练习   163
        第III部分  C++编码方法
        第7章  内存管理   167
        7.1  使用动态内存   167
        7.1.1  如何描绘内存   168
        7.1.2  分配和释放   169
        7.1.3  数组   170
        7.1.4  使用指针   177
        7.2  数组-指针的对偶性   178
        7.2.1  数组就是指针   178
        7.2.2  并非所有指针都是数组   180
        7.3  底层内存操作   180
        7.3.1  指针运算   180
        7.3.2  自定义内存管理   181
        7.3.3  垃圾回收   181
        7.3.4  对象池   182
        7.4  常见的内存陷阱   182
        7.4.1  数据缓冲区分配不足以及
        内存访问越界   182
        7.4.2  内存泄漏   183
        7.4.3  双重释放和无效指针   186
        7.5  智能指针   186
        7.5.1  unique_ptr   187
        7.5.2  shared_ptr   190
        7.5.3  weak_ptr   193
        7.5.4  向函数传递参数   193
        7.5.5  从函数中返回   194
        7.5.6  enable_shared_from_this   194
        7.5.7  过时的、移除的auto_ptr   195
        7.6  本章小结   195
        7.7  练习   195
        第8章  类和对象   197
        8.1  电子表格示例介绍   197
        8.2  编写类   198
        8.2.1  类定义   198
        8.2.2  定义方法   200
        8.2.3  使用对象   203
        8.3  对象的生命周期   205
        8.3.1  创建对象   205
        8.3.2  销毁对象   219
        8.3.3  对象赋值   220
        8.3.4  编译器生成的拷贝构造函数和
        拷贝赋值运算符   223
        8.3.5  复制和赋值的区别   223
        8.4  本章小结   224
        8.5  练习   225
        第9章  精通类和对象   227
        9.1  友元   227
        9.2  对象中的动态内存分配   228
        9.2.1  Spreadsheet类   228
        9.2.2  使用析构函数释放内存   231
        9.2.3  处理复制和赋值   231
        9.2.4  使用移动语义处理移动   237
        9.2.5  零规则   246
        9.3  与方法有关的更多内容   246
        9.3.1  static方法   246
        9.3.2  const方法   247
        9.3.3  方法重载   248
        9.3.4  内联方法   251
        9.3.5  默认参数   252
        9.4  不同的数据成员类型   252
        9.4.1  静态数据成员   253
        9.4.2  const static数据成员   254
        9.4.3  引用数据成员   255
        9.5  嵌套类   256
        9.6  类内的枚举类型   257
        9.7  运算符重载   258
        9.7.1  示例：为SpreadsheetCell
        实现加法   258
        9.7.2  重载算术运算符   261
        9.7.3  重载比较运算符   262
        9.7.4  创建具有运算符重载的类型   266
        9.8  创建稳定的接口   266
        9.9  本章小结   270
        9.10  练习   270
        第10章  揭秘继承技术   271
        10.1  使用继承构建类   271
        10.1.1  扩展类   272
        10.1.2  重写方法   275
        10.2  使用继承重用代码   282
        10.2.1  WeatherPrediction类   282
        10.2.2  在派生类中添加功能   283
        10.2.3  在派生类中替换功能   284
        10.3  利用父类   285
        10.3.1  父类构造函数   285
        10.3.2  父类的析构函数   286
        10.3.3  使用父类方法   287
        10.3.4  向上转型和向下转型   289
        10.4  继承与多态性   290
        10.4.1  回到电子表格   290
        10.4.2  设计多态性的电子表格
        单元格   291
        10.4.3  SpreadsheetCell基类   291
        10.4.4  独立的派生类   293
        10.4.5  利用多态性   294
        10.4.6  考虑将来   295
        10.5  多重继承   296
        10.5.1  从多个类继承   296
        10.5.2  名称冲突和歧义基类   297
        10.6  有趣而晦涩的继承问题   300
        10.6.1  修改重写方法的返回类型   300
        10.6.2  派生类中添加虚基类方法的
        重载   301
        10.6.3  继承的构造函数   302
        10.6.4  重写方法时的特殊情况   306
        10.6.5  派生类中的复制构造函数和
        赋值运算符   312
        10.6.6  运行期类型工具   313
        10.6.7  非public继承   314
        10.6.8  虚基类   315
        10.7  类型转换   316
        10.7.1  static_cast()   316
        10.7.2  reinterpret_cast()   317
        10.7.3  std::bit_cast()   318
        10.7.4  dynamic_cast()   318
        10.7.5  类型转换小结   319
        10.8  本章小结   319
        10.9  练习   320
        第11章  零碎的工作   321
        11.1  模块   321
        11.1.1  模块接口文件   322
        11.1.2  模块实现文件   324
        11.1.3  从实现中分离接口   325
        11.1.4  可见性和可访问性   326
        11.1.5  子模块   326
        11.1.6  模块划分   327
        11.1.7  头文件单元   329
        11.2  头文件   330
        11.2.1  重复定义   330
        11.2.2  循环依赖   330
        11.2.3  查询头文件是否存在   331
        11.3  核心语言特性的特性测试宏   331
        11.4  STATIC关键字   332
        11.4.1  静态数据成员和方法   332
        11.4.2  静态链接   332
        11.4.3  函数中的静态变量   334
        11.4.4  非局部变量的初始化顺序   335
        11.4.5  非局部变量的销毁顺序   335
        11.5  C的实用工具   335
        11.5.1  变长参数列表   336
        11.5.2  预处理器宏   337
        11.6  本章小结   338
        11.7  练习   338
        第12章  利用模板编写泛型代码   341
        12.1  模板概述   341
        12.2  类模板   342
        12.2.1  编写类模板   342
        12.2.2  编译器处理模板的原理   349
        12.2.3  将模板代码分布到多个
        文件中   350
        12.2.4  模板参数   351
        12.2.5  方法模板   355
        12.2.6  类模板的特化   359
        12.2.7  从类模板派生   361
        12.2.8  继承还是特化   362
        12.2.9  模板别名   362
        12.3  函数模板   363
        12.3.1  函数模板的重载   364
        12.3.2  类模板的友元函数模板   365
        12.3.3  对模板参数推导的更多介绍   366
        12.3.4  函数模板的返回类型   367
        12.4  简化函数模板的语法   368
        12.5  变量模板   369
        12.6  概念   369
        12.6.1  语法   369
        12.6.2  约束表达式   370
        12.6.3  预定义的标准概念   372
        12.6.4  类型约束的auto   372
        12.6.5  类型约束和函数模板   373
        12.6.6  类型约束和类模板   375
        12.6.7  类型约束和类方法   375
        12.6.8  类型约束和模板特化   376
        12.7  本章小结   376
        12.8  练习   377
        第13章  C++ I/O揭秘   379
        13.1  使用流   379
        13.1.1  流的含义   380
        13.1.2  流的来源和目的地   381
        13.1.3  流式输出   381
        13.1.4  流式输入   386
        13.1.5  对象的输入输出   392
        13.1.6  自定义的操作算子   393
        13.2  字符串流   393
        13.3  文件流   394
        13.3.1  文本模式与二进制模式   395
        13.3.2  通过seek()和tell()在文件中
        转移   395
        13.3.3  将流链接在一起   397
        13.4  双向I/O   398
        13.5  文件系统支持库   399
        13.5.1  路径   399
        13.5.2  目录条目   401
        13.5.3  辅助函数   401
        13.5.4  目录遍历   401
        13.6  本章小结   402
        13.7  练习   403
        第14章  错误处理   405
        14.1  错误与异常   405
        14.1.1  异常的含义   405
        14.1.2  C++中异常的优点   406
        14.1.3  建议   407
        14.2  异常机制   407
        14.2.1  抛出和捕获异常   408
        14.2.2  异常类型   410
        14.2.3  按const引用捕获异常对象   411
        14.2.4  抛出并捕获多个异常   411
        14.2.5  未捕获的异常   414
        14.2.6  noexcept说明符   415
        14.2.7  noexcept(expression)说明符   415
        14.2.8  noexcept(expression)运算符   415
        14.2.9  抛出列表   416
        14.3  异常与多态性   416
        14.3.1  标准异常层次结构   416
        14.3.2  在类层次结构中捕获异常   418
        14.3.3  编写自己的异常类   419
        14.3.4  源码位置   421
        14.3.5  日志记录的源码位置   422
        14.3.6  异常的源码位置   422
        14.3.7  嵌套异常   423
        14.4 重新抛出异常   425
        14.5  堆栈的释放与清理   426
        14.5.1  使用智能指针   427
        14.5.2  捕获、清理并重新抛出   428
        14.6  常见的错误处理问题   428
        14.6.1  内存分配错误   428
        14.6.2  构造函数中的错误   430
        14.6.3  构造函数的function-try-blocks   432
        14.6.4  析构函数中的错误   435
        14.7  本章小结   435
        14.8  练习   435
        第15章  C++运算符重载   437
        15.1  运算符重载概述   437
        15.1.1  重载运算符的原因   438
        15.1.2  运算符重载的限制   438
        15.1.3  运算符重载的选择   438
        15.1.4  不应重载的运算符   440
        15.1.5  可重载运算符小结   440
        15.1.6  右值引用   443
        15.1.7  优先级和结合性   444
        15.1.8  关系运算符   444
        15.2  重载算术运算符   445
        15.2.1  重载一元负号和一元正号
        运算符   445
        15.2.2  重载递增和递减运算符   446
        15.3  重载按位运算符和二元逻辑
        运算符   446
        15.4  重载插入运算符和提取运算符   447
        15.5  重载下标运算符   448
        15.5.1  通过operator[]提供只读访问   451
        15.5.2  非整数数组索引   452
        15.6  重载函数调用运算符   452
        15.7  重载解除引用运算符   453
        15.7.1  实现operator*   454
        15.7.2  实现operator->   455
        15.7.3  operator.*和operator ->*的
        含义   455
        15.8  编写转换运算符   456
        15.8.1  auto运算符   456
        15.8.2  使用显式转换运算符解决
        多义性问题   457
        15.8.3  用于布尔表达式的转换   457
        15.9  重载内存分配和内存释放
        运算符   459
        15.9.1  new和delete的工作原理   459
        15.9.2  重载operator new和
        operator delete   461
        15.9.3  显式地删除/默认化operator new
        和operator delete   463
        15.9.4  重载带有额外参数的operator new
        和operator delete   463
        15.9.5  重载带有内存大小参数的
        operator delete   464
        15.9.6  重载用户定义的字面量
        运算符   464
        15.9.7  cooked模式字面量运算符   465
        15.9.8  raw模式字面量运算符   465
        15.9.9  标准用户定义的字面量   466
        15.10  本章小结   466
        15.11  练习   466
        第16章  C++标准库概述   469
        16.1  编码原则   470
        16.1.1  使用模板   470
        16.1.2  使用运算符重载   470
        16.2  C++标准库概述   470
        16.2.1  字符串   470
        16.2.2  正则表达式   471
        16.2.3  I/O流   471
        16.2.4  智能指针   471
        16.2.5  异常   471
        16.2.6  数学工具   472
        16.2.7  时间和日期工具   473
        16.2.8  随机数   473
        16.2.9  初始化列表   474
        16.2.10  Pair和Tuple   474
        16.2.11  词汇类型   474
        16.2.12  函数对象   474
        16.2.13  文件系统   474
        16.2.14  多线程   475
        16.2.15  类型萃取   475
        16.2.16  标准整数类型   475
        16.2.17  标准库特性测试宏   475
        16.2.18  <version>   476
        16.2.19  源位置   476
        16.2.20  容器   476
        16.2.21  算法   482
        16.2.22  范围库   488
        16.2.23  标准库中还缺什么   488
        16.3  本章小结   489
        16.4  练习   489
        第17章  理解迭代器与范围库   491
        17.1  迭代器   491
        17.1.1  获取容器的迭代器   494
        17.1.2  迭代器萃取   495
        17.1.3  示例   495
        17.2  流迭代器   496
        17.2.1  输出流迭代器   497
        17.2.2  输入流迭代器   497
        17.3  迭代器适配器   498
        17.3.1  插入迭代器   498
        17.3.2  逆向迭代器   499
        17.3.3  移动迭代器   500
        17.4  范围   502
        17.4.1  基于范围的算法   502
        17.4.2  视图   504
        17.4.3  范围工厂   508
        17.5  本章小结   509
        17.6  练习   509
        第18章  标准库容器   511
        18.1  容器概述   511
        18.1.1  对元素的要求   512
        18.1.2  异常和错误检查   513
        18.2  顺序容器   514
        18.2.1  vector   514
        18.2.2  vector<bool>特化   531
        18.2.3  deque   532
        18.2.4  list   532
        18.2.5  forward_list   535
        18.2.6  array   537
        18.2.7  span   538
        18.3  容器适配器   540
        18.3.1  queue   540
        18.3.2  priority_queue   542
        18.3.3  stack   545
        18.4  有序关联容器   545
        18.4.1  pair工具类   545
        18.4.2  map   546
        18.4.3  multimap   554
        18.4.4  set   556
        18.4.5  multiset   558
        18.5  无序关联容器/哈希表   558
        18.5.1  哈希函数   559
        18.5.2  unordered_map   560
        18.5.3  unordered_multimap   563
        18.5.4  unordered_set/
        unordered_multiset   564
        18.6  其他容器   564
        18.6.1  标准C风格数组   564
        18.6.2  string   565
        18.6.3  流   566
        18.6.4  bitset   566
        18.7  本章小结   570
        18.8  练习   570
        第19章  函数指针，函数对象，lambda
        表达式   571
        19.1  函数指针   571
        19.2  指向方法(和数据成员)的指针   573
        19.3  函数对象   576
        19.3.1  编写第一个函数对象   576
        19.3.2  标准库中的函数对象   576
        19.4  lambda表达式   582
        19.4.1  语法   583
        19.4.2  lambda表达式作为参数   587
        19.4.3  泛型lambda表达式   587
        19.4.4  lambda捕获表达式   587
        19.4.5  模板化lambda表达式   588
        19.4.6  lambda表达式作为返回类型   589
        19.4.7  未计算上下文中的lambda
        表达式   589
        19.4.8  默认构造、拷贝和赋值   589
        19.5  调用   590
        19.6  本章小结   590
        19.7  练习   590
        第20章  掌握标准库算法   593
        20.1  算法概述   593
        20.1.1  find()和find_if()算法   594
        20.1.2  accumulate()算法   596
        20.1.3  在算法中使用移动语义   597
        20.1.4  算法回调   597
        20.2  算法详解   598
        20.2.1  非修改序列算法   598
        20.2.2  修改序列算法   603
        20.2.3  操作算法   611
        20.2.4  分区算法   613
        20.2.5  排序算法   614
        20.2.6  二分查找算法   615
        20.2.7  集合算法   616
        20.2.8  最小/最大算法   618
        20.2.9  并行算法   619
        20.2.10  约束算法   620
        20.2.11  数值处理算法   621
        20.3  本章小结   622
        20.4  练习   622
        第21章  字符串的本地化与正则表达式   625
        21.1  本地化   625
        21.1.1  宽字符   625
        21.1.2  本地化字符串字面量   626
        21.1.3  非西方字符集   626
        21.1.4  locale和facet   628
        21.1.5  转换   631
        21.2  正则表达式   632
        21.2.1  ECMAScript语法   632
        21.2.2  regex库   637
        21.2.3  regex_match()   638
        21.2.4  regex_search()   640
        21.2.5  regex_iterator   641
        21.2.6  regex_token_iterator   642
        21.2.7  regex_replace()   644
        21.3  本章小结   646
        21.4  练习   646
        第22章  日期和时间工具   647
        22.1  编译期有理数   647
        22.2  持续时间   649
        22.3  时钟   653
        22.4  时间点   655
        22.5  日期   656
        22.6  时区   658
        22.7  本章小结   659
        22.8  练习   659
        第23章  随机数工具   661
        23.1  C风格随机数生成器   661
        23.1.1  随机数引擎   662
        23.1.2  随机数引擎适配器   663
        23.1.3  预定义的随机数引擎和
        引擎适配器   664
        23.1.4  生成随机数   664
        23.1.5  随机数分布   666
        23.2  本章小结   668
        23.3  练习   669
        第24章  其他库工具   671
        24.1  variant   671
        24.2  any   673
        24.3  元组   674
        24.3.1  分解元组   676
        24.3.2  串联   677
        24.3.3  比较   677
        24.3.4  make_from_tuple()   678
        24.3.5  apply()   678
        24.4  本章小结   678
        24.5  练习   678
        第IV部分  掌握C++的高级特性
        第25章  自定义和扩展标准库   683
        25.1  分配器   683
        25.2  扩展标准库   684
        25.2.1  扩展标准库的原因   685
        25.2.2  编写标准库算法   685
        25.2.3  编写标准库容器   686
        25.2.4  将directed_graph实现为
        标准库容器   696
        25.2.5  添加分配器支持   712
        25.2.6  改善graph_node   716
        25.2.7  附加的标准库类似功能   717
        25.2.8  进一步改善   719
        25.2.9  其他容器类型   719
        25.3  本章小结   720
        25.4  练习   720
        第26章  高级模板   721
        26.1  深入了解模板参数   721
        26.1.1  深入了解模板类型参数   721
        26.1.2  template template参数介绍   724
        26.1.3  深入了解非类型模板参数   725
        26.2  类模板部分特例化   727
        26.3  通过重载模拟函数部分特例化   730
        26.4  模板递归   731
        26.4.1  N维网格：初次尝试   731
        26.4.2  真正的N维网格   732
        26.5  可变参数模板   734
        26.5.1  类型安全的变长参数列表   734
        26.5.2  可变数目的混入类   736
        26.5.3  折叠表达式   737
        26.6  模板元编程   739
        26.6.1  编译时阶乘   739
        26.6.2  循环展开   740
        26.6.3  打印元组   741
        26.6.4  类型trait   744
        26.6.5  模板元编程结论   752
        26.7  本章小结   752
        26.8  练习   752
        第27章  C++多线程编程   753
        27.1  多线程编程概述   754
        27.1.1  争用条件   755
        27.1.2  撕裂   756
        27.1.3  死锁   756
        27.1.4  伪共享   757
        27.2  线程   757
        27.2.1  通过函数指针创建线程   758
        27.2.2  通过函数对象创建线程   759
        27.2.3  通过lambda创建线程   760
        27.2.4  通过成员函数创建线程   760
        27.2.5  线程本地存储   761
        27.2.6  取消线程   761
        27.2.7  自动join线程   761
        27.2.8  从线程获得结果   762
        27.2.9  复制和重新抛出异常   762
        27.3  原子操作库   764
        27.3.1  原子操作   766
        27.3.2  原子智能指针   767
        27.3.3  原子引用   767
        27.3.4  使用原子类型   767
        27.3.5  等待原子变量   769
        27.4  互斥   770
        27.4.1  互斥体类   770
        27.4.2  锁   772
        27.4.3  std::call_once   774
        27.4.4  互斥体对象的用法示例   776
        27.5  条件变量   779
        27.5.1  虚假唤醒   780
        27.5.2  使用条件变量   780
        27.6  latch   781
        27.7  barrier   782
        27.8  semaphore   782
        27.9  future   783
        27.9.1  std::promise和std::future   784
        27.9.2  std::packaged_task   784
        27.9.3  std::async   785
        27.9.4  异常处理   786
        27.9.5  std::shared_future   786
        27.10  示例：多线程的Logger类   787
        27.11  线程池   791
        27.12  协程   792
        27.13  线程设计和最佳实践   793
        27.14  本章小结   794
        27.15  练习   794
        第V部分  C++软件工程
        第28章  充分利用软件工程方法   799
        28.1  过程的必要性   799
        28.2  软件生命周期模型   800
        28.2.1  瀑布模型   800
        28.2.2  生鱼片模型   802
        28.2.3  螺旋类模型   802
        28.2.4  敏捷   804
        28.3  软件工程方法论   805
        28.3.1  UP   805
        28.3.2  RUP   806
        28.3.3  Scrum   806
        28.3.4  极限编程   808
        28.3.5  软件分流   812
        28.4  构建自己的过程和方法   812
        28.4.1  对新思想采取开放态度   812
        28.4.2  提出新想法   812
        28.4.3  知道什么行得通、什么行不通   812
        28.4.4  不要逃避   813
        28.5  源代码控制   813
        28.6  本章小结   814
        28.7  练习   814
        第29章  编写高效的C++程序   817
        29.1  性能和效率概述   817
        29.1.1  提升效率的两种方式   818
        29.1.2  两种程序   818
        29.1.3  C++是不是低效的语言   818
        29.2  语言层次的效率   818
        29.2.1  高效地操纵对象   819
        29.2.2  预分配内存   823
        29.2.3  使用内联方法和函数   823
        29.3  设计层次的效率   823
        29.3.1  尽可能多地缓存   823
        29.3.2  使用对象池   824
        29.4  剖析   829
        29.4.1  使用gprof的剖析示例   829
        29.4.2  使用Visual C++ 2019的剖析示例   836
        29.5  本章小结   838
        29.6  练习   838
        第30章  熟练掌握测试技术   841
        30.1  质量控制   841
        30.1.1  谁负责测试   842
        30.1.2  bug的生命周期   842
        30.1.3  bug跟踪工具   843
        30.2  单元测试   844
        30.2.1  单元测试方法   844
        30.2.2  单元测试过程   845
        30.2.3  实际中的单元测试   848
        30.3  模糊测试   855
        30.4  高级测试   855
        30.4.1  集成测试   855
        30.4.2  系统测试   856
        30.4.3  回归测试   857
        30.5  用于成功测试的建议   857
        30.6  本章小结   858
        30.7  练习   858
        第31章  熟练掌握调试技术   859
        31.1  调试的基本定律   859
        31.2  bug分类学   860
        31.3  避免bug   860
        31.4  为bug做好规划   861
        31.4.1  错误日志   861
        31.4.2  调试跟踪   862
        31.4.3  断言   869
        31.4.4  崩溃转储   870
        31.5  调试技术   870
        31.5.1  重现bug   870
        31.5.2  调试可重复的bug   871
        31.5.3  调试不可重现的bug   871
        31.5.4  调试退化   872
        31.5.5  调试内存问题   872
        31.5.6  调试多线程程序   876
        31.5.7  调试示例：文章引用   876
        31.5.8  从ArticleCitations示例中总结出的教训   887
        31.6  本章小结   887
        31.7  练习   887
        第32章  使用设计技术和框架   889
        32.1  容易忘记的语法   890
        32.1.1  编写类   890
        32.1.2  派生类   891
        32.1.3  编写lambda表达式   892
        32.1.4  使用“复制和交换”惯用语法   892
        32.1.5  抛出和捕捉异常   893
        32.1.6  写入文件   894
        32.1.7  读取文件   894
        32.1.8  写入类模板   895
        32.1.9  约束模板参数   895
        32.2  始终存在更好的方法   896
        32.2.1  RAII   896
        32.2.2  双分派   898
        32.2.3  混入类   902
        32.3  面向对象的框架   904
        32.3.1  使用框架   904
        32.3.2  MVC范型   905
        32.4  本章小结   906
        32.5  练习   906
        第33章  应用设计模式   907
        33.1  依赖注入   908
        33.1.1  示例：日志机制   908
        33.1.2  依赖注入logger的实现   908
        33.1.3  使用依赖注入   909
        33.2  抽象工厂模式   910
        33.2.1  示例：模拟汽车工厂   910
        33.2.2  实现抽象工厂   911
        33.2.3  使用抽象工厂   912
        33.3  工厂方法模式   913
        33.3.1  示例：模拟第二个汽车工厂   913
        33.3.2  实现工厂   914
        33.3.3  使用工厂   915
        33.3.4  工厂的其他类型   917
        33.3.5  工厂的其他用法   917
        33.4  适配器模式   918
        33.4.1  示例：适配Logger类   918
        33.4.2  实现适配器   919
        33.4.3  使用适配器   920
        33.5  代理模式   920
        33.5.1  示例：隐藏网络连接问题   920
        33.5.2  实现代理   921
        33.5.3  使用代理   922
        33.6  迭代器模式   922
        33.7  观察者模式   923
        33.7.1  示例：从主题中暴露事件   923
        33.7.2  实现观察者   923
        33.7.3  使用观察者   924
        33.8  装饰器模式   925
        33.8.1  示例：在网页中定义样式   926
        33.8.2  装饰器的实现   926
        33.8.3  使用装饰器   927
        33.9  责任链模式   928
        33.9.1  示例：事件处理   928
        33.9.2  实现责任链   928
        33.9.3  使用责任链   929
        33.10  单例模式   930
        33.10.1  日志记录机制   931
        33.10.2  实现单例   931
        33.10.3  使用单例   933
        33.11  本章小结   933
        33.12  练习   933
        第34章  开发跨平台和跨语言的应用程序   935
        34.1  跨平台开发   935
        34.1.1  架构问题   935
        34.1.2  实现问题   938
        34.1.3  平台专用功能   940
        34.2  跨语言开发   940
        34.2.1  混用C和C++   941
        34.2.2  改变范型   941
        34.2.3  链接C代码   944
        34.2.4  从C#调用C++代码   946
        34.2.5  C++/CLI在C++中使用C#代码和在C#中使用C++代码   947
        34.2.6  在Java中使用JNI调用C++代码   948
        34.2.7  从C++代码调用脚本   950
        34.2.8  从脚本调用C++代码   950
        34.2.9  从C++调用汇编代码   952
        34.3  本章小结   953
        34.4  练习   953
        第VI部分  附录
        附录A  C++面试   957
        在线资源(扫描封底二维码下载)
        附录B  标准库头文件   977
        附录C  UML简介   983
        附录D  带注解的参考文献   989
     · · · · · ·     (收起)"
30329536,数据密集型应用系统设计,9.7,(1709人评价),Martin Kleppmann / 赵军平、李三平、吕云松、耿煜 / 中国电力出版社 / 2018-9-1 / 128,"全书分为三大部分：
第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以...",https://book.douban.com/subject/30329536/,https://img1.doubanio.com/view/subject/s/public/s34186559.jpg,128,9787519821968,"全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方...(展开全部)





全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方式就是集成多个不同的数据库、缓存模块以及索引模块等。首先第10章以批处理开始来处理派生数据，紧接着第11章采用流式处理。第12章总结之前介绍的多种技术，并分析讨论未来构建可靠、可扩展和可维护应用系统可能的新方向或方法。","作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, ...(展开全部)




作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, Nvidia GPU Tech Conf等做技术分享，持续关注数据密集和计算密集相关技术的演进、融合与赋能推广。 吕云松，北京大学计算机硕士，硕士及DELL EMC中国研究院实习期间专注于大数据实时流式处理相关的研究。现就职于华为2012中软院黎曼实验室，主要从事深度学习的研发。 耿煜，DELL EMC架构师兼GTM负责人，致力于推广企业级数字化转型方案。深耕分布式架构以及云计算12年，先后任职于ChinaCache，Sun Microsystems以及EMC等公司。 李三平，美国麻省大学计算机工程专业博士，DELL EMC中国研究院首席科学家，研究方向为机器学习、深度学习、智能运维、遥感影像等。已在IEEE Transactions期刊和会议上发表论文数十篇，申请美国专利20余项。推崇简约，热衷机器学习。","前言 .....................................................1
        第一部分 数据系统基础
        第1章 可靠、可扩展与可维护的应用系统 ................... 11
        认识数据系统 ...........................................12
        可靠性 ..................................................14
        可扩展性 ................................................18
        可维护性 ................................................25
        小结 .....................................................28
        第2章 数据模型与查询语言 ............................... 33
        关系模型与文档模型 .......................................34
        数据查询语言 ...........................................46
        图状数据模型 ......................................52
        小结 ...................................................65
        第3章 数据存储与检索 .................................. 71
        数据库核心：数据结构 ...................................72
        事务处理与分析处理 ...................................89
        列式存储 .........................................94
        小结 ..............................................101
        第4章 数据编码与演化 .............................. 109
        数据编码格式 .................................... 110
        数据流模式 ......................................124
        小结 .............................................134
        第二部分 分布式数据系统
        第5章 数据复制 ................................. 145
        主节点与从节点 ..................................146
        复制滞后问题 ......................................154
        多主节点复制 .......................................160
        无主节点复制 .....................................168
        小结 ..............................................181
        第6章 数据分区 ............................... 189
        数据分区与数据复制 .................................190
        键-值数据的分区 ...................................190
        分区与二级索引 ...................................195
        分区再平衡 ....................................198
        请求路由 ..................................202
        小结 .................................204
        第7章 事务 .............................. 211
        深入理解事务 ......................................212
        弱隔离级别 .................................221
        串行化 ...........................................237
        小结 ...........................................250
        第8章 分布式系统的挑战 ...................... 259
        故障与部分失效 ...............................260
        不可靠的网络 ..................................262
        不可靠的时钟 ..................................271
        知识，真相与谎言 ...............................282
        小结 ..........................................292
        第9章 一致性与共识 ..................... 303
        一致性保证 ....................................304
        可线性化 ........................................305
        顺序保证 ........................................319
        分布式事务与共识 .................................330
        小结 ...............................................349
        第三部分 派生数据
        第10章 批处理系统 ................................ 367
        使用UNIX工具进行批处理 .............................368
        MapReduce与分布式文件系统 .........................375
        超越MapReduce ....................................394
        小结 ............................................403
        第11章 流处理系统 .............................. 413
        发送事件流 .......................................414
        数据库与流 .......................................424
        流处理 .........................................435
        小结 ............................................449
        第12章 数据系统的未来 ............................ 461
        数据集成 .........................................461
        分拆数据库 .......................................469
        端到端的正确性 ....................................484
        做正确的事情 .......................................500
        小结 ..............................................509
        术语表 ............................................ 521
     · · · · · ·     (收起)"
35144587,Go专家编程,9.1,(128人评价),任洪彩 / 电子工业出版社 / 2020-7 / 108.00元,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松...,https://book.douban.com/subject/35144587/,https://img3.doubanio.com/view/subject/s/public/s33699643.jpg,108.00元,9787121365577,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松地了解Go语言的内部运作机制。 本书首先介绍Go语言常见的数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者可以借此测验自身对该知识点的掌握程度。接着介绍了Go语言最基础的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了一些标准库、异常处理和依赖管理等非语法相关但非常重要的内容。最后结合作者的见闻，整理了一些发生在真实项目中的编程陷阱。,任洪彩，华为云原生团队核心成员，开源爱好者，深度参与CNCF（云原生计算基金会）旗下Kubernetes、Prometheus等项目贡献，Kubernetes资深成员，担任Kubernetes SIG-Instrumentation Approver，敏捷软件思想深度实践者，在Nokia、华为等公司参与过多个大型项目的研发与重构，对Go、C/C++、Python、Swift等语言均有深入的研究与实践。,"第1章　常见数据结构的实现原理
        1.1　管道
        1.1.1　热身测验
        1.1.2　特性速览
        1.1.3　实现原理
        1.2　slice
        1.2.1　热身测验
        1.2.2　特性速览
        1.2.3　实现原理
        1.2.4　切片表达式
        1.3　map
        1.3.1　热身测验
        1.3.2　特性速览
        1.3.3　实现原理
        1.4　struct
        1.4.1　热身测验
        1.4.2　内嵌字段
        1.4.3　方法受体
        1.4.4　字段标签
        1.5　iota
        1.5.1　热身测验
        1.5.2　特性速览
        1.5.3　实现原理
        1.6　string
        1.6.1　热身测验
        1.6.2　特性速览
        1.6.3　实现原理
        第2章　控制结构
        2.1　select
        2.1.1　热身测验
        2.1.2　特性速览
        2.1.3　实现原理
        2.2　for-range
        2.2.1　热身测验
        2.2.2　特性速览
        2.2.3　实现原理
        第3章　协程
        3.1　协程的概念
        3.2　调度模型
        3.3　调度策略
        第4章　内存管理
        4.1　内存分配
        4.2　垃圾回收
        4.3　逃逸分析
        第5章　并发控制
        5.1　channel
        5.2　WaitGroup
        5.3　context
        5.4　Mutex
        5.5　RWMutex
        5.5.1　读写锁的数据结构
        5.5.2　场景分析
        第6章　反射
        6.1　热身测验
        6.2　接口
        6.3　反射定律
        第7章　测试
        7.1　快速开始
        7.1.1　单元测试
        7.1.2　基准测试
        7.1.3　示例测试
        7.2　进阶测试
        7.2.1　子测试
        7.2.2　Main测试
        7.3　实现原理
        7.3.1　testing.common
        7.3.2　testing.TB接口
        7.3.3　单元测试的实现原理
        7.3.4　性能测试的实现原理
        7.3.5　示例测试的实现原理
        7.3.6　Main测试的实现原理
        7.3.7　go test的工作机制
        7.4　扩展阅读
        7.4.1　测试参数
        7.4.2　benchstat
        第8章　异常处理
        8.1　error
        8.1.1　热身测验
        8.1.2　基础error
        8.1.3　链式error
        8.1.4　工程迁移
        8.2　defer
        8.2.1　热身测验
        8.2.2　约法三章
        8.2.3　实现原理
        8.2.4　性能优化
        8.3　panic
        8.3.1　热身测验
        8.3.2　工作机制
        8.3.3　源码剖析
        8.4　recover
        8.4.1　热身测验
        8.4.2　工作机制
        8.4.3　源码剖析
        第9章　定时器
        9.1　一次性定时器（Timer）
        9.1.1　快速开始
        9.1.2　实现原理
        9.2　周期性定时器（Ticker）
        9.2.1　快速开始
        9.2.2　实现原理
        9.3　runtimeTimer
        9.3.1　实现原理
        9.3.2　性能优化
        9.4　案例分享
        第10章　语法糖
        10.1　简短变量声明符
        10.1.1　热身测验
        10.1.2　规则
        10.2　可变参函数
        第11章　版本管理
        11.1　安装Go
        11.2　删除Go
        11.3　升级Go
        11.4　Go版本管理器
        11.4.1　快速开始
        11.4.2　工作机制
        11.4.3　小结
        11.5　源码编译
        11.5.1　源码下载
        11.5.2　源码编译过程
        第12章　Go语言依赖管理
        12.1　GOPATH
        12.1.1　GOROOT是什么
        12.1.2　GOPATH是什么
        12.1.3　依赖查找
        12.1.4　GOPATH的缺点
        12.2　vendor
        12.2.1　vendor目录位置
        12.2.2　搜索顺序
        12.2.3　vendor的不足
        12.3　Go Module
        12.3.1　Go Module基础
        12.3.2　快速实践
        12.3.3　replace指令
        12.3.4　exclude指令
        12.3.5　indirect指令
        12.3.6　版本选择机制
        12.3.7　incompatible
        12.3.8　伪版本
        12.3.9　依赖包存储
        12.3.10　go.sum
        12.3.11　模块代理
        12.3.12　GOSUMDB的工作机制
        12.3.13　GOSUMDB的实现原理
        12.3.14　第三方代理
        12.3.15　私有模块
        12.3.16　Go Module的演进
        第13章　编程陷阱
        13.1　切片扩容
        13.2　空切片
        13.3　append的本质
        13.4　循环变量引用
        13.5　协程引用循环变量
        13.6　recover失效
     · · · · · ·     (收起)"
25844633,实现领域驱动设计,8.4,(416人评价),Vaughn Vernon / 滕云 / 电子工业出版社 / 2014-3 / 99.00元,领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如...,https://book.douban.com/subject/25844633/,https://img1.doubanio.com/view/subject/s/public/s29544670.jpg,99.00元,9787121224485,"领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为...(展开全部)





领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为一本DDD 参考书。",作者：Vaughn Vernon是一个经验丰富的软件工匠，在软件设计、开发和架构方面拥有超过25年的从业经验。他提倡通过创新来简化软件的设计和实现。从20世纪80年代开始，他便开始使用面向对象语言进行编程；在 20世纪 90年代早期，他便在领域建模中应用了领域驱动设计，那时他使用的是Smalltalk语言。他在很多业务领域都有从业经验，包括航空、环境、地理、保险、医学和电信等领域。同时，Vaughn在技术上也取得了很大的成功，包括开发可重用的框架和类库等。他在全球范围之内提供软件咨询和演讲，此外，他还在许多国家教授《实现领域驱动设计》的课程。你可以通过www.VaughnVernon.co访问到他的最新研究成果。他的Twitter：@VaughnVernon。,"序............... xix
        前言............. xxi
        致谢............ xxxi
        关于作者................... xxxv
        如何使用本书.........xxxvii
        第1章 DDD入门...............1
        我能DDD吗？..................2
        为什么我们需要DDD.............5
        如何DDD...................... 17
        使用DDD的业务价值..............22
        1.你获得了一个非常有用的领域模型................22
        2.你的业务得到了更准确的定义和理解............23
        3.领域专家可以为软件设计做出贡献...........23
        4.更好的用户体验....................23
        5.清晰的模型边界.....................24
        6.更好的企业架构..............24
        7.敏捷、迭代式和持续建模....................24
        8.使用战略和战术新工具........................24
        实施DDD所面临的挑战.....................25
        虚构的案例，真实的实践................... 33
        本章小结.........................36
        第2章 领域、子域和限界上下文.....................37
        总览....................... 37
        工作中的子域和限界上下文............................. 38
        将关注点放在核心域上............................. 42
        战略设计为什么重要.................... 45
        现实世界中领域和子域...................48
        理解限界上下文..................... 53
        限界上下文不仅仅只包含模型..................... 57
        限界上下文的大小...................... 59
        与技术组件保持一致................... 61
        示例上下文........................ 62
        协作上下文..................63
        身份与访问上下文..................69
        敏捷项目管理上下文................. 71
        本章小结....................................73
        第3章 上下文映射图............................75
        上下文映射图为什么重要........................ 75
        绘制上下文映射图......................77
        产品和组织关系........................79
        映射3个示例限界上下文........................82
        本章小结............................97
        第4章 架构.......................99
        采访一个成功的CIO.................... 100
        分层................................. 104
        依赖倒置原则.................... 107
        六边形架构（端口与适配器）..................... 110
        面向服务架构.......................114
        REST................................117
        REST作为一种架构风格...........................117
        RESTful HTTP服务器的关键方面 ........................................ 118
        RESTful HTTP客户端的关键方面 ........................................ 119
        REST和DDD..................... 120
        为什么是REST？......................... 121
        命令和查询职责分离——CQRS................. 121
        CQRS的各个方面........................ 123
        处理具有最终一致性的查询模型.................. 128
        事件驱动架构................... 129
        管道和过滤器..................... 131
        长时处理过程（也叫Saga）................... 134
        事件源...................... 140
        数据网织和基于网格的分布式计算....................... 143
        数据复制..................... 144
        事件驱动网织和领域事件.................. 145
        持续查询................... 145
        分布式处理...................... 146
        本章小结............................ 148
        第5章 实体......................... 149
        为什么使用实体......................... 149
        唯一标识............................ 151
        用户提供唯一标识......................... 152
        应用程序生成唯一标识........................... 153
        持久化机制生成唯一标识............................ 156
        另一个限界上下文提供唯一标识..................... 160
        标识生成时间..................... 161
        委派标识......................... 163
        标识稳定性.......................... 165
        发现实体及其本质特征............................. 167
        揭开实体及其本质特征的神秘面纱................. 168
        挖掘实体的关键行为.......................... 172
        角色和职责......................... 176
        创建实体......................... 181
        验证................................... 183
        跟踪变化............................ 192
        本章小结................................ 192
        第6章 值对象..................... 193
        值对象的特征.......................... 194
        度量或描述.......................... 195
        不变性........................... 195
        概念整体................................ 196
        可替换性.......................... 199
        值对象相等性..........................200
        无副作用行为............................. 201
        最小化集成..................204
        用值对象表示标准类型........................206
        测试值对象........................ 210
        实现.............................. 214
        持久化值对象................. 219
        拒绝由数据建模泄漏带来的不利影响..................220
        ORM与单个值对象................................ 221
        多个值对象序列化到单个列中.....................224
        使用数据库实体保存多个值对象....................225
        使用联合表保存多个值对象..........................229
        ORM与枚举状态对象........................................230
        本章小结....................... 233
        第7章 领域服务.................................235
        什么是领域服务（首先，什么不是领域服务）.................. 237
        请确定你是否需要一个领域服务................................ 238
        建模领域服务.................. 241
        独立接口有必要吗.............................244
        一个计算过程..........................246
        转换服务........................249
        为领域服务创建一个迷你层.........................250
        测试领域服务............................250
        本章小结.................. 253
        第8章 领域事件...............................255
        何时/为什么使用领域事件.......................... 255
        建模领域事件.................... 258
        创建具有聚合特征的领域事件................... 263
        身份标识............................264
        从领域模型中发布领域事件.............................. 265
        发送方................... 265
        订阅方.....................269
        向远程限界上下文发布领域事件............................. 271
        消息设施的一致性........................... 271
        自治服务和系统............................. 272
        容许时延.................. 273
        事件存储.................. 274
        转发存储事件的架构风格........................... 279
        以REST资源的方式发布事件通知....................... 279
        通过消息中间件发布事件通知.................. 283
        实现............................284
        发布NotificationLog............... 285
        发布基于消息的事件通知..............................290
        本章小结........................297
        第9章 模块................................299
        通过模块完成设计..................................299
        模块的基本命名规范..........................302
        领域模型的命名规范...........................302
        敏捷项目管理上下文中的模块..............................305
        其他层中的模块..................308
        先考虑模块，再是限界上下文...............................309
        本章小结......................... 310
        第10章 聚合...................... 311
        在Scrum核心领域中使用聚合........................ 312
        第一次尝试：臃肿的聚合....................... 313
        第二次尝试：多个聚合........................... 314
        原则：在一致性边界之内建模真正的不变条件................317
        原则：设计小聚合............................. 319
        不要相信每一个用例............................ 321
        原则：通过唯一标识引用其他聚合......................... 322
        通过标识引用使多个聚合协同工作 ...................................... 324
        建模对象导航性............................ 325
        可伸缩性和分布式............................. 326
        原则：在边界之外使用最终一致性............................. 327
        谁的任务？............................ 328
        打破原则的理由......................... 329
        理由之一：方便用户界面................................. 329
        理由之二：缺乏技术机制............................. 330
        理由之三：全局事务.......................................... 331
        理由之四：查询性能.................................. 331
        遵循原则.................... 332
        通过发现，深入理解............................... 332
        重新思考设计............................... 332
        估算聚合成本............................. 334
        常见用例场景........................ 335
        内存消耗............................ 336
        探索另外的设计................................... 337
        实现最终一致性.............................. 338
        这是Scrum团队成员的任务吗？......................... 339
        决定的时候到了.............................. 341
        实现........................................ 341
        创建具有唯一标识的根实体........................ 342
        优先使用值对象...................... 343
        使用迪米特法则和“告诉而非询问”原则 ...............344
        乐观并发...............346
        避免依赖注入................348
        本章小结................................ 349
        第11章 工厂................. 351
        领域模型中的工厂................. 351
        聚合根中的工厂方法............................. 352
        创建CalendarEntry实例................... 353
        创建Discussion实例............................ 357
        领域服务中的工厂.......................... 358
        本章小结.......................... 361
        第12章 资源库...........................363
        面向集合资源库...........................364
        Hibernate实现...................... 369
        TopLink实现.................... 377
        面向持久化资源库........................ 379
        Coherence实现............................ 381
        MongoDB实现......................... 386
        额外的行为...................................... 391
        管理事务................................. 393
        警告................................. 397
        类型层级............................... 397
        资源库 vs 数据访问对象（DAO）..............................400
        测试资源库.......................................... 401
        以内存实现进行测试...................404
        本章小结................................407
        第13章 集成限界上下文...............................409
        集成基础知识....................................409
        分布式系统之间存在根本性区别.......................411
        跨系统边界交换信息...............................411
        通过REST资源集成限界上下文......................... 417
        实现REST资源.......................... 418
        使用防腐层实现REST客户端........... 421
        通过消息集成限界上下文................ 428
        从Scrum的产品负责人和团队成员处得到持续通知 .................... 428
        你能处理这样的职责吗？..................... 434
        长时处理过程，以及避免职责............. 439
        长时处理过程的状态机和超时跟踪器 .................................. 450
        设计一个更复杂的长时处理过程 ..........................................460
        当消息机制或你的系统不可用时 ...........................................464
        本章小结.................................465
        第14章 应用程序..................467
        用户界面...................................469
        渲染领域对象............. 470
        渲染数据传输对象................... 471
        使用调停者发布聚合的内部状态 .......................................... 471
        通过领域负载对象渲染聚合实例 .......................................... 472
        聚合实例的状态展现............................. 473
        用例优化资源库查询...................... 474
        处理不同类型的客户端................... 474
        渲染适配器以及处理用户编辑............. 475
        应用服务 ............................................ 478
        示例应用服务 ................................ 478
        解耦服务输出 .....................485
        组合多个限界上下文 .....................487
        基础设施 ...............................489
        企业组件容器 ....................490
        本章小结 ....................494
        附录A 聚合与事件源：A+ES ..........................495
        应用服务内部 ....................... 496
        命令处理器 .....................505
        Lambda语法...................508
        并发控制 ....................... 510
        A+ES所带来的结构自由性 .............. 513
        性能 ............................ 513
        实现事件存储 ..................... 516
        关系型持久化 .................. 520
        BLOB持久化 ...................... 522
        专注的聚合 ............................ 523
        读模型投射 ........................... 524
        与聚合设计一道使用 ................ 527
        增强事件 ........................... 527
        工具和模式 ................... 529
        事件序列器 .......... 530
        事件不变性 ................ 531
        值对象 ..................... 531
        协议生成 .................... 534
        单元测试和需求规范 .............. 535
        事件源和函数式语言 .......... 536
        参考文献 ..................539
     · · · · · ·     (收起)"
30333919,架构整洁之道,8.7,(858人评价),【美】Robert C. Martin（罗伯特 C. 马丁） / 电子工业出版社 / 2018-9 / 99.00元,《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过...,https://book.douban.com/subject/30333919/,https://img9.doubanio.com/view/subject/s/public/s29943454.jpg,99.00元,9787121347962,"《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构...(展开全部)





《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构设计，还是软件研发管理，《架构整洁之道》都是不可或缺的。","Robert C·Martin
作者","第1部分  概述
        第1章  设计与架构究竟是什么  3
        目标是什么  4
        案例分析  5
        本章小结  11
        第2章  两个价值维度  12
        行为价值  13
        架构价值  13
        哪个价值维度更重要  14
        艾森豪威尔矩阵  15
        为好的软件架构而持续斗争  16
        第2部分  从基础构件开始：编程范式
        第3章  编程范式总览  21
        结构化编程  22
        面向对象编程  22
        函数式编程  23
        仅供思考  23
        本章小结  24
        第4章  结构化编程  25
        可推导性  26
        goto是有害的  28
        功能性降解拆分  29
        形式化证明没有发生  29
        科学来救场  29
        测试  30
        本章小结  31
        第5章  面向对象编程  32
        封装  33
        继承  36
        多态  38
        本章小结  44
        第6章  函数式编程  45
        整数平方  46
        不可变性与软件架构  47
        可变性的隔离  48
        事件溯源  49
        本章小结  51
        第3部分  设计原则
        第7章  SRP：单一职责原则  56
        反面案例2：代码合并  59
        解决方案  60
        本章小结  61
        第8章  OCP：开闭原则  62
        思想实验  63
        依赖方向的控制  67
        信息隐藏  67
        本章小结  67
        第9章  LSP：里氏替换原则  68
        继承的使用指导  69
        正方形/长方形问题  70
        LSP与软件架构  70
        违反LSP的案例  71
        本章小结  73
        第10章 ISP：接口隔离原则  74
        ISP与编程语言  76
        ISP与软件架构  76
        本章小结  77
        第11章 DIP：依赖反转原则  78
        稳定的抽象层  79
        工厂模式  80
        具体实现组件  82
        本章小结  82
        第4部分  组件构建原则
        第12章 组件  84
        组件发展史  85
        重定位技术  88
        链接器  88
        本章小结  90
        第13章 组件聚合  91
        复用/发布等同原则  92
        共同闭包原则  93
        共同复用原则  94
        组件聚合张力图  95
        本章小结  97
        第14章 组件耦合  98
        无依赖环原则  99
        自上而下的设计  105
        稳定依赖原则  106
        稳定抽象原则  112
        本章小结  117
        第5部分  软件架构
        第15章 什么是软件架构  120
        开发（Development）  122
        部署（Deployment）  123
        运行（Operation）  123
        维护（Maintenance）  124
        保持可选项  124
        设备无关性  126
        垃圾邮件  128
        物理地址寻址  129
        本章小结  130
        第16章 独立性  131
        用例  132
        运行  133
        开发  133
        部署  134
        保留可选项  134
        按层解耦  135
        用例的解耦  136
        解耦的模式  136
        开发的独立性  137
        部署的独立性  137
        重复  138
        再谈解耦模式  139
        本章小结  141
        第17章 划分边界  142
        几个悲伤的故事  143
        FitNesse  146
        应在何时、何处画这些线  148
        输入和输出怎么办  151
        插件式架构  152
        插件式架构的好处  153
        本章小结  154
        第18章 边界剖析  155
        跨边界调用  156
        令人生畏的单体结构  156
        部署层次的组件  158
        线程  159
        本地进程  159
        服务  160
        本章小结  161
        第19章 策略与层次  162
        层次（Level）  163
        本章小结  166
        第20章 业务逻辑  167
        业务实体  168
        用例  169
        请求和响应模型  171
        本章小结  172
        第21章 尖叫的软件架构  173
        架构设计的主题  174
        架构设计的核心目标  175
        那Web呢  175
        框架是工具而不是生活信条  175
        可测试的架构设计  176
        本章小结  176
        第22章 整洁架构  177
        依赖关系规则  179
        一个常见的应用场景  183
        本章小结  184
        第23章 展示器和谦卑对象  185
        谦卑对象模式  186
        展示器与视图  186
        测试与架构  187
        数据库网关  188
        数据映射器  188
        服务监听器  189
        本章小结  189
        第24章 不完全边界  190
        省掉最后一步  191
        单向边界  192
        门户模式  193
        本章小结  193
        第25章 层次与边界  194
        基于文本的冒险游戏：Hunt The Wumpus  195
        可否采用整洁架构  196
        交汇数据流  199
        数据流的分割  199
        本章小结  201
        第26章 Main组件  203
        最细节化的部分  204
        本章小结  208
        第27章 服务：宏观与微观  209
        面向服务的架构  210
        服务所带来的好处  210
        运送猫咪的难题  212
        对象化是救星  213
        基于组件的服务  215
        横跨型变更  216
        本章小结  216
        第28章 测试边界  217
        测试也是一种系统组件  218
        可测试性设计  219
        测试专用API  220
        本章小结  221
        第29章 整洁的嵌入式架构  222
        “程序适用测试”测试  225
        目标硬件瓶颈  228
        本章小结  238
        第6部分  实现细节
        第30章 数据库只是实现细节  240
        关系型数据库  241
        为什么数据库系统如此流行  242
        假设磁盘不存在会怎样  243
        实现细节  243
        但性能怎么办呢  244
        一段轶事  244
        本章小结  246
        第31章 Web是实现细节  247
        无尽的钟摆  248
        总结一下  250
        本章小结  251
        第32章 应用程序框架是实现细节  252
        框架作者  253
        单向婚姻  253
        风险  254
        解决方案  255
        不得不接受的依赖  255
        本章小结  256
        第33章 案例分析：视频销售网站  257
        产品  258
        用例分析  258
        组件架构  260
        依赖关系管理  261
        本章小结  262
        第34章 拾遗  263
        按层封装  264
        按功能封装  266
        端口和适配器  268
        按组件封装  270
        具体实现细节中的陷阱  274
        组织形式与封装的区别  275
        其他的解耦合模式  277
        本章小结：本书拾遗  279
        后序  280
        附录A  架构设计考古  283
     · · · · · ·     (收起)"
5387403,Effective C++,9.5,(1104人评价),[美] Scott Meyers / 侯捷 / 电子工业出版社 / 2011-1-1 / 65.00元,"在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。
作者高超的技术把握力、独特...",https://book.douban.com/subject/5387403/,https://img2.doubanio.com/view/subject/s/public/s4647091.jpg,65.00元,9787121123320,在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。 作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和仿效。 这本书不是读完一遍就可以束之高阁的快餐读物，也不是用以解决手边问题的参考手册，而是需要你去反复阅读体会的，C++是真正程序员的语言，背后有着精深的思想与无以伦比的表达能力，这使得它具有类似宗教般的魅力。,"侯捷
译者","译序
        中英简繁术语对照
        目录
        序言
        致谢
        导读
        1. 让自己习惯c++
        2. 构造/析构/赋值运算
        3. 资源管理
        4. 设计与声明
        5. 实现
        6. 继承与面向对象设计
        7. 模板与泛型编程
        8. 定制new和delete
        9. 杂项讨论
        a 本书之外
        b 新旧版条款对照
        索引
     · · · · · ·     (收起)"
36654266,高级算法和数据结构,9.7,(28人评价),马塞洛·拉·罗卡（Marcello La Rocca） / 肖鉴明 / 人民邮电出版社 / 2023-12 / 149.80元,这是一本关于“高级/进阶”算法和数据结构的图书，主要介绍了用于Web应用程序、系统编程和数据处理领域的各种算法，旨在让读者了解如何用这些算法应对各种棘手的编...,https://book.douban.com/subject/36654266/,https://img9.doubanio.com/view/subject/s/public/s34704215.jpg,149.80元,9787115614575,这是一本关于“高级/进阶”算法和数据结构的图书，主要介绍了用于Web应用程序、系统编程和数据处理领域的各种算法，旨在让读者了解如何用这些算法应对各种棘手的编码挑战，以及如何将其应用于具体问题，以应对新技术浪潮下的“棘手”问题。 本书对一些广为人知的基本算法进行了扩展，还介绍了用于改善优先队列、有效缓存、对数据进行集群等的技术，以期读者能针对不同编程问题选出更好的解决方案。书中示例大多辅以图解，并以不囿于特定语言的伪代码以及多种语言的代码样本加以闸释。 学完本书，读者可以了解高级算法和数据结构的相关内容，并能运用这些知识让代码具备更优性能，甚至能够独立设计数据结构，应对需要自定义解决方案的情况。 本书可作为高等院校计算机相关专业本科高年级学生以及研究生的学习用书，也可供从事与算法相关工作的开发者参考。,Marcello La Rocca现为一家电商公司的高级软件工程师，曾参与开发Twitter、微软和苹果等公司的大型Web应用程序和数据基础设施，并发明了NeatSort这一自适应排序算法。他的主要研究领域为图、算法优化、机器学习和量子计算。,"第1章　初识数据结构　1
        1.1　数据结构　2
        1.1.1　定义数据结构　2
        1.1.2　描述数据结构　3
        1.1.3　算法与数据结构有区别吗　4
        1.2　设定目标：阅读本书后的期望　4
        1.3　打包背包：数据结构与现实世界的结合　5
        1.3.1　抽象化问题　5
        1.3.2　寻找解决方案　6
        1.3.3　拯救大家的算法　7
        1.3.4　打破常规来思考问题　8
        1.3.5　完美的结局　9
        1.4　小结　9
        第一部分　改进基本数据结构
        第2章　改进优先队列：d叉堆　12
        2.1　本章结构　13
        2.2　问题：处理优先级　13
        2.3　已知解决方案：让列表保持有序　15
        2.4　描述数据结构API：优先队列　15
        2.4.1　使用优先队列　16
        2.4.2　优先级为何非常重要　17
        2.5　具体数据结构　17
        2.5.1　性能比较　18
        2.5.2　正确的具体数据结构是什么　18
        2.5.3　堆　18
        2.5.4　优先级、最小堆和最大堆　20
        2.5.5　高级变体：d叉堆　21
        2.6　如何实现堆　22
        2.6.1　向上冒泡　22
        2.6.2　向下推动　25
        2.6.3　插入　27
        2.6.4　移除顶部元素　28
        2.6.5　修改　30
        2.6.6　处理重复优先级　31
        2.6.7　堆化　32
        2.6.8　API之外的方法：包含　34
        2.6.9　性能回顾　34
        2.6.10　从伪代码到实现　35
        2.7　用例：找到最大的k个元素　35
        2.7.1　选择正确的数据结构　36
        2.7.2　正确地使用数据结构　36
        2.7.3　代码写起来　36
        2.8　更多的用例　37
        2.8.1　图中的最小距离：Dijkstra算法　37
        2.8.2　更多的图算法：Prim算法　37
        2.8.3　数据压缩：霍夫曼编码　38
        2.9　对分支因子进行分析　41
        2.9.1　是否需要d叉堆　41
        2.9.2　运行时间　42
        2.9.3　寻找最佳分支因子　42
        2.9.4　分支因子与内存的关系　43
        2.10　性能分析：寻找最佳分支因子　43
        2.10.1　剖析　44
        2.10.2　解释结果　45
        2.10.3　堆化的谜团　49
        2.10.4　选择最佳分支因子　49
        2.11　小结　50
        第3章　树堆：使用随机化来平衡二叉搜索树　52
        3.1　问题：多索引　53
        3.2　解决方案：描述与API　53
        3.3　树堆　54
        3.3.1　旋转　57
        3.3.2　一些设计问题　60
        3.3.3　实现搜索方法　61
        3.3.4　插入　61
        3.3.5　删除　64
        3.3.6　去顶、看顶以及修改　66
        3.3.7　返回最小键和最大键　67
        3.3.8　性能回顾　67
        3.4　应用：随机树堆　68
        3.4.1　平衡树　68
        3.4.2　引入随机化　70
        3.4.3　随机树堆的应用　71
        3.5　性能分析和剖析　72
        3.5.1　理论：期望高度　72
        3.5.2　剖析高度　74
        3.5.3　剖析运行时间　76
        3.5.4　剖析内存使用情况　78
        3.5.5　结论　78
        3.6　小结　80
        第4章　布隆过滤器：减少跟踪内容所需的内存　81
        4.1　字典问题：跟踪事物　82
        4.2　实现字典的其他方法　83
        4.3　描述数据结构API：关联数组　83
        4.4　具体数据结构　84
        4.4.1　无序数组：快速插入，慢速搜索　84
        4.4.2　有序数组和二分查找：慢插入，稍微快一些的搜索　85
        4.4.3　哈希表：在不需要有序的情况下，具有平均常数时间的性能　86
        4.4.4　二叉搜索树：所有操作都是对数阶的　86
        4.4.5　布隆过滤器：与哈希表一样快，但（由于一个缺陷而）更节省内存　88
        4.5　表面之下：布隆过滤器是如何工作的　88
        4.6　实现　89
        4.6.1　使用布隆过滤器　90
        4.6.2　位的读取和写入　91
        4.6.3　找到键存储的位置　92
        4.6.4　生成哈希函数　93
        4.6.5　构造函数　93
        4.6.6　查找键　94
        4.6.7　存储键　95
        4.6.8　估计准确率　96
        4.7　应用场景　97
        4.7.1　缓存　97
        4.7.2　路由　98
        4.7.3　爬虫　98
        4.7.4　I/O提取器　98
        4.7.5　拼写检查器　98
        4.7.6　分布式数据库和文件系统　99
        4.8　为什么布隆过滤器是可行的　99
        4.8.1　为什么没有假阴性　100
        4.8.2　为什么有假阳性　100
        4.8.3　作为随机算法的布隆过滤器　101
        4.9　性能分析　101
        4.9.1　运行时间　101
        4.9.2　构造函数　102
        4.9.3　存储元素　102
        4.9.4　查找元素　102
        4.10　估计布隆过滤器的精确度　102
        4.11　改进的变体　106
        4.11.1　布隆表过滤器　106
        4.11.2　组合布隆过滤器　106
        4.11.3　分层布隆过滤器　106
        4.11.4　压缩布隆过滤器　107
        4.11.5　可扩展布隆过滤器　107
        4.12　小结　108
        第5章　不交集：次线性时间的处理过程　109
        5.1　不同子集问题　110
        5.2　解决方案的论证　111
        5.3　描述数据结构API：不交集　112
        5.4　简单解决方案　113
        5.5　使用树状结构　117
        5.5.1　从链表转移到树　117
        5.5.2　实现使用树的版本　118
        5.6　改进运行时间的启发式算法　120
        5.6.1　路径压缩　121
        5.6.2　实现平衡性与路径压缩　122
        5.7　应用程序　124
        5.7.1　图：连通分量　124
        5.7.2　图：最小生成树的Kruskal算法　124
        5.7.3　聚类　125
        5.7.4　合一　126
        5.8　小结　126
        第6章　trie与基数树：高效的字符串搜索　127
        6.1　拼写检查　128
        6.1.1　拼写检查器的设计　128
        6.1.2　压缩是关键　129
        6.1.3　描述与API　129
        6.2　trie　130
        6.2.1　为什么trie更好　132
        6.2.2　搜索　134
        6.2.3　插入　137
        6.2.4　删除　139
        6.2.5　搜索最长前缀词　140
        6.2.6　返回匹配特定前缀的所有键　141
        6.2.7　什么时候应该使用trie　143
        6.3　基数树　144
        6.3.1　节点和边　146
        6.3.2　搜索　148
        6.3.3　插入　149
        6.3.4　删除　151
        6.3.5　搜索最长前缀词　153
        6.3.6　返回匹配特定前缀的所有键　153
        6.4　应用程序　154
        6.4.1　拼写检查器　154
        6.4.2　字符串相似度　156
        6.4.3　字符串排序　157
        6.4.4　T9　157
        6.4.5　自动完成　158
        6.5　小结　158
        第7章　用例：LRU缓存　160
        7.1　不要重复计算　160
        7.2　第一次尝试：记住数据　163
        7.2.1　描述与API　164
        7.2.2　请保存新数据　164
        7.2.3　处理异步调用　165
        7.2.4　将缓存的值标记为“正在加载”　166
        7.3　内存（真的）不够　167
        7.4　清除陈旧数据：LRU缓存　168
        7.4.1　有时必须要重复解决问题　169
        7.4.2　时间排序　170
        7.4.3　性能　174
        7.5　当新数据更有价值时：LFU　175
        7.5.1　如何选择缓存的清除策略　176
        7.5.2　LFU缓存有什么不同　176
        7.5.3　性能　178
        7.5.4　LFU缓存的不足　178
        7.6　如何使用缓存也同样重要　179
        7.7　同步简介　180
        7.7.1　（在Java中）解决并发问题　182
        7.7.2　锁简介　183
        7.7.3　获取锁　183
        7.7.4　重入锁　184
        7.7.5　读锁　185
        7.7.6　解决并发的其他方法　186
        7.8　缓存应用程序　186
        7.9　小结　187
        第二部分　多维查询
        第8章　最近邻搜索　190
        8.1　最近邻搜索问题　190
        8.2　解决方案　191
        8.2.1　第一次尝试　191
        8.2.2　有时缓存并不是答案　191
        8.2.3　简化事情以获得灵感　192
        8.2.4　谨慎选择数据结构　193
        8.3　描述与API　194
        8.4　迁移到k维空间　195
        8.4.1　一维二分查找　196
        8.4.2　迁移到更高维度　196
        8.4.3　用数据结构对二维空间进行建模　197
        8.5　小结　198
        第9章　k-d树：索引多维数据　199
        9.1　从结束的地方继续　199
        9.2　迁移到k维空间：循环遍历
        维度　199
        9.2.1　构造BST　201
        9.2.2　不变量　204
        9.2.3　保持平衡的重要性　204
        9.3　方法　205
        9.3.1　搜索　206
        9.3.2　插入　208
        9.3.3　平衡树　209
        9.3.4　删除　212
        9.3.5　最近邻搜索　218
        9.3.6　区域搜索　224
        9.3.7　所有方法的回顾　227
        9.4　限制与可能的改进　228
        9.5　小结　229
        第10章　相似性搜索树：图像检索的近似
        最近邻搜索　230
        10.1　从结束的地方继续　230
        10.1.1　一个新的（更复杂的）例子　231
        10.1.2　克服k-d树的缺陷　232
        10.2　R树　232
        10.2.1　先退一步：B树简介　232
        10.2.2　由B树到R树　233
        10.2.3　在R树中插入点　236
        10.2.4　搜索　237
        10.3　SS树　238
        10.3.1　搜索　241
        10.3.2　插入　244
        10.3.3　插入：方差、均值与投影　249
        10.3.4　插入：分裂节点　252
        10.3.5　删除　255
        10.4　相似性搜索　259
        10.4.1　最近邻搜索　260
        10.4.2　区域搜索　262
        10.4.3　近似相似性搜索　263
        10.5　SS+树　265
        10.5.1　SS树会更好吗　266
        10.5.2　缓解超球体的限制　267
        10.5.3　改进拆分启发式算法　267
        10.5.4　减少重叠　268
        10.6　小结　270
        第11章　最近邻搜索的应用　271
        11.1　应用程序：查找最近的枢纽　271
        11.1.1　解决方案的初稿　272
        11.1.2　天堂里的麻烦　273
        11.2　中心化应用程序　274
        11.2.1　过滤点　274
        11.2.2　复杂的决定　276
        11.3　迁移到分布式应用程序　278
        11.3.1　处理HTTP通信的问题　279
        11.3.2　保持库存同步　281
        11.3.3　经验教训　281
        11.4　其他应用程序　282
        11.4.1　色彩还原　282
        11.4.2　粒子的相互作用　283
        11.4.3　多维数据库查询的优化　285
        11.4.4　聚类　287
        11.5　小结　287
        第12章　聚类　288
        12.1　聚类简介　289
        12.1.1　机器学习的类型　289
        12.1.2　聚类的类型　290
        12.2　k均值算法　291
        12.2.1　k均值算法的问题　295
        12.2.2　维度诅咒再次来袭　296
        12.2.3　k均值算法的性能分析　297
        12.2.4　用k-d树来加快k均值算法　297
        12.2.5　关于k均值算法的最后一些提示　300
        12.3　DBSCAN算法　300
        12.3.1　直接可达与密度可达　301
        12.3.2　从定义到算法　302
        12.3.3　实现　304
        12.3.4　DBSCAN算法的优缺点　305
        12.4　OPTICS算法　307
        12.4.1　定义　308
        12.4.2　OPTICS算法的核心思想　308
        12.4.3　从可达距离到聚类　311
        12.4.4　分层聚类　314
        12.4.5　性能分析和最终的考虑　318
        12.5　评估聚类结果：评估指标　318
        12.6　小结　322
        第13章　并行聚类：MapReduce与树冠聚类　323
        13.1　并行化　323
        13.1.1　并行计算与分布式计算　324
        13.1.2　并行化k均值算法　325
        13.1.3　树冠聚类　325
        13.1.4　应用树冠聚类　327
        13.2　MapReduce　328
        13.2.1　MapReduce是如何工作的　328
        13.2.2　先映射，后归约　331
        13.2.3　表面之下，还有更多　334
        13.3　MapReduce版本的k均值算法　334
        13.3.1　并行化树冠聚类　337
        13.3.2　使用树冠聚类来进行质心的初始化　339
        13.3.3　MapReduce版本的树冠聚类　340
        13.4　MapReduce版本的DBSCAN 算法　343
        13.5　小结　348
        第三部分　平面图与最小交叉数
        第14章　图简介：寻找距离最短的
        路径　350
        14.1　定义　351
        14.1.1　图的实现　351
        14.1.2　作为代数类型的图　353
        14.1.3　伪代码　354
        14.2　图的属性　354
        14.2.1　无向　355
        14.2.2　连通　355
        14.2.3　无环　356
        14.3　图的遍历：BFS与DFS　357
        14.3.1　优化配送路线　357
        14.3.2　广度优先搜索　359
        14.3.3　重建到目标的路径　361
        14.3.4　深度优先搜索　362
        14.3.5　再次比较队列与堆栈　364
        14.3.6　投递包裹的最佳路线　365
        14.4　加权图中的最短路径：迪杰斯特拉 算法　365
        14.4.1　与BFS算法的区别　366
        14.4.2　实现　367
        14.4.3　分析　368
        14.4.4　投递包裹的最佳路线　369
        14.5　超越迪杰斯特拉算法：A*
        算法　370
        14.5.1　A*算法到底有多好　372
        14.5.2　将启发式函数作为平衡实时数据的一种方式　375
        14.6　小结　376
        第15章　图嵌入与平面性：绘制具有最少相交边的图　377
        15.1　图嵌入　378
        15.1.1　一些基础定义　379
        15.1.2　完全图与完全二分图　380
        15.2　平面图　381
        15.2.1　在实践中使用库拉托夫斯基定理　381
        15.2.2　平面性测试　382
        15.2.3　用于平面性测试的朴素算法　383
        15.2.4　提高性能　386
        15.2.5　高效的算法　388
        15.3　非平面图　389
        15.3.1　找到交叉数　391
        15.3.2　直线交叉数　392
        15.4　边的交叉点　393
        15.4.1　直线线段　394
        15.4.2　折线　397
        15.4.3　贝塞尔曲线　397
        15.4.4　二次贝塞尔曲线之间的交点　398
        15.4.5　顶点与顶点相交以及边与顶点相交　401
        15.5　小结　402
        第16章　梯度下降：（不仅是）图的优化问题　403
        16.1　用于交叉数的启发式算法　404
        16.1.1　刚才提到启发式了吗　404
        16.1.2　扩展到曲线边　408
        16.2　优化的工作原理　409
        16.2.1　成本函数　410
        16.2.2　阶跃函数与局部最小值　412
        16.2.3　优化随机抽样算法　412
        16.3　梯度下降　414
        16.3.1　梯度下降中的数学描述　415
        16.3.2　几何解释　416
        16.3.3　什么时候可以应用梯度下降　418
        16.3.4　梯度下降的问题　418
        16.4　梯度下降的应用　419
        16.5　使用梯度下降进行图嵌入　422
        16.5.1　另一种标准　423
        16.5.2　实现　425
        16.6　小结　426
        第17章　模拟退火：超越局部最小值的优化　427
        17.1　模拟退火　428
        17.1.1　有时候需要先向上爬才能到达底部　429
        17.1.2　实现　431
        17.1.3　为什么模拟退火是有效的　432
        17.1.4　短程与长程的转换　434
        17.1.5　变体　435
        17.1.6　模拟退火与梯度下降：应该选择哪一个呢　436
        17.2　模拟退火与旅行推销员　436
        17.2.1　精确解与近似解　438
        17.2.2　可视化成本　438
        17.2.3　修剪域　440
        17.2.4　状态转换　440
        17.2.5　相邻交换与随机交换　443
        17.2.6　TSP近似算法的应用　444
        17.3　模拟退火与图嵌入　444
        17.3.1　最小边交叉　445
        17.3.2　力导向绘制　446
        17.4　小结　450
        第18章　遗传算法：受生物学启发的快速收敛优化　451
        18.1　遗传算法简介　451
        18.1.1　来自大自然的灵感　453
        18.1.2　染色体　456
        18.1.3　种群　457
        18.1.4　适应度　458
        18.1.5　自然选择　459
        18.1.6　选择交配的个体　461
        18.1.7　交叉操作　466
        18.1.8　突变操作　468
        18.1.9　遗传算法模板　469
        18.1.10　遗传算法在什么时候效果最好　470
        18.2　TSP　471
        18.2.1　适应度、染色体与初始化　471
        18.2.2　突变操作　472
        18.2.3　交叉操作　472
        18.2.4　结果与参数调整　473
        18.2.5　超越TSP：优化整个车队的路线　476
        18.3　最小顶点覆盖　477
        18.3.1　顶点覆盖的应用　478
        18.3.2　实现遗传算法　478
        18.4　遗传算法的其他应用　480
        18.4.1　最大流问题　480
        18.4.2　蛋白质折叠　481
        18.4.3　超越遗传算法　482
        18.4.4　算法，超越本书　483
        18.5　小结　483
        附录A　伪代码快速指南　485
        附录B　大O符号　494
        附录C　核心数据结构　500
        附录D　类似于优先队列的容器　511
        附录E　递归　514
        附录F　分类问题与随机算法的度量指标　520
     · · · · · ·     (收起)"
30270959,深度学习入门,9.5,(1381人评价),[日］斋藤康毅 / 陆宇杰 / 人民邮电出版社 / 2018-7 / 59.00元,本书是深度学习真正意义上的入门书，深入浅出地剖析了深度学习的原理和相关技术。书中使用Python3，尽量不依赖外部库或工具，从基本的数学知识出发，带领读者从...,https://book.douban.com/subject/30270959/,https://img9.doubanio.com/view/subject/s/public/s29815955.jpg,59.00元,9787115485588,本书是深度学习真正意义上的入门书，深入浅出地剖析了深度学习的原理和相关技术。书中使用Python3，尽量不依赖外部库或工具，从基本的数学知识出发，带领读者从零创建一个经典的深度学习网络，使读者在此过程中逐步理解深度学习。书中不仅介绍了深度学习和神经网络的概念、特征等基础知识，对误差反向传播法、卷积神经网络等也有深入讲解，此外还介绍了深度学习相关的实用技巧，自动驾驶、图像生成、强化学习等方面的应用，以及为什么加深层可以提高识别精度等“为什么”的问题。,作者简介： 斋藤康毅 东京工业大学毕业，并完成东京大学研究生院课程。现从事计算机视觉与机器学习相关的研究和开发工作。是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。 译者简介： 陆宇杰 众安科技NLP算法工程师。主要研究方向为自然语言处理及其应用，对图像识别、机器学习、深度学习等领域有密切关注。Python爱好者。,"译者序　　xiii
        前言　　xv
        第1章　Python入门　　1
        1.1 Python是什么　　1
        1.2 Python的安装　　2
        1.2.1　Python版本　　2
        1.2.2　使用的外部库　　2
        1.2.3　Anaconda发行版　　3
        1.3 Python解释器　　4
        1.3.1　算术计算　　4
        1.3.2　数据类型　　5
        1.3.3　变量　　5
        1.3.4　列表　　6
        1.3.5　字典　　7
        1.3.6　布尔型　　7
        1.3.7　if 语句　　8
        1.3.8　for 语句　　8
        1.3.9　函数　　9
        1.4 Python脚本文件　　9
        1.4.1　保存为文件　　9
        1.4.2　类　　10
        1.5 NumPy　　11
        1.5.1　导入NumPy　　11
        1.5.2　生成NumPy数组　　12
        1.5.3　NumPy 的算术运算　　12
        1.5.4　NumPy的N维数组　　13
        1.5.5　广播　　14
        1.5.6　访问元素　　15
        1.6 Matplotlib　　16
        1.6.1　绘制简单图形　　16
        1.6.2　pyplot 的功能　　17
        1.6.3　显示图像　　18
        1.7 小结　　19
        第2章　感知机　　21
        2.1 感知机是什么　　21
        2.2 简单逻辑电路　　23
        2.2.1　与门　　23
        2.2.2　与非门和或门　　23
        2.3 感知机的实现　　25
        2.3.1　简单的实现　　25
        2.3.2　导入权重和偏置　　26
        2.3.3　使用权重和偏置的实现　　26
        2.4 感知机的局限性　　28
        2.4.1　异或门　　28
        2.4.2　线性和非线性　　30
        2.5 多层感知机　　31
        2.5.1　已有门电路的组合　　31
        2.5.2　异或门的实现　　33
        2.6 从与非门到计算机　　35
        2.7 小结　　36
        第3章　神经网络　　37
        3.1 从感知机到神经网络　　37
        3.1.1　神经网络的例子　　37
        3.1.2　复习感知机　　38
        3.1.3　激活函数登场　　40
        3.2 激活函数　　42
        3.2.1　sigmoid 函数　　42
        3.2.2　阶跃函数的实现　　43
        3.2.3　阶跃函数的图形　　44
        3.2.4　sigmoid 函数的实现　　45
        3.2.5　sigmoid 函数和阶跃函数的比较　　46
        3.2.6　非线性函数　　48
        3.2.7　ReLU函数　　49
        3.3 多维数组的运算　　50
        3.3.1　多维数组　　50
        3.3.2　矩阵乘法　　51
        3.3.3　神经网络的内积　　55
        3.4　　3 层神经网络的实现　　56
        3.4.1　符号确认　　57
        3.4.2　各层间信号传递的实现　　58
        3.4.3　代码实现小结　　62
        3.5 输出层的设计　　63
        3.5.1　恒等函数和softmax 函数　　64
        3.5.2　实现softmax 函数时的注意事项　　66
        3.5.3　softmax 函数的特征　　67
        3.5.4　输出层的神经元数量　　68
        3.6 手写数字识别　　69
        3.6.1　MNIST数据集　　70
        3.6.2　神经网络的推理处理　　73
        3.6.3　批处理　　75
        3.7 小结　　79
        第4章　神经网络的学习　　81
        4.1 从数据中学习　　81
        4.1.1　数据驱动　　82
        4.1.2　训练数据和测试数据　　84
        4.2 损失函数　　85
        4.2.1　均方误差　　85
        4.2.2　交叉熵误差　　87
        4.2.3　mini-batch 学习　　88
        4.2.4　mini-batch 版交叉熵误差的实现　　91
        4.2.5　为何要设定损失函数　　92
        4.3 数值微分　　94
        4.3.1　导数　　94
        4.3.2　数值微分的例子　　96
        4.3.3　偏导数　　98
        4.4 梯度　　100
        4.4.1　梯度法　　102
        4.4.2　神经网络的梯度　　106
        4.5 学习算法的实现　　109
        4.5.1　2 层神经网络的类　　110
        4.5.2　mini-batch 的实现　　114
        4.5.3　基于测试数据的评价　　116
        4.6 小结　　118
        第5章　误差反向传播法　　121
        5.1 计算图　　121
        5.1.1　用计算图求解　　122
        5.1.2　局部计算　　124
        5.1.3　为何用计算图解题　　125
        5.2 链式法则　　126
        5.2.1　计算图的反向传播　　127
        5.2.2　什么是链式法则　　127
        5.2.3　链式法则和计算图　　129
        5.3 反向传播　　130
        5.3.1　加法节点的反向传播　　130
        5.3.2　乘法节点的反向传播　　132
        5.3.3　苹果的例子　　133
        5.4 简单层的实现　　135
        5.4.1　乘法层的实现　　135
        5.4.2　加法层的实现　　137
        5.5 激活函数层的实现　　139
        5.5.1　ReLU层　　139
        5.5.2　Sigmoid 层　　141
        5.6 AffineSoftmax层的实现　　144
        5.6.1　Affine层　　144
        5.6.2　批版本的Affine层　　148
        5.6.3　Softmax-with-Loss 层　　150
        5.7 误差反向传播法的实现　　154
        5.7.1　神经网络学习的全貌图　　154
        5.7.2　对应误差反向传播法的神经网络的实现　　155
        5.7.3　误差反向传播法的梯度确认　　158
        5.7.4　使用误差反向传播法的学习　　159
        5.8 小结　　161
        第6章　与学习相关的技巧　　163
        6.1 参数的更新　　163
        6.1.1　探险家的故事　　164
        6.1.2　SGD　　164
        6.1.3　SGD的缺点　　166
        6.1.4　Momentum　　168
        6.1.5　AdaGrad　　170
        6.1.6　Adam　　172
        6.1.7　使用哪种更新方法呢　　174
        6.1.8　基于MNIST数据集的更新方法的比较　　175
        6.2 权重的初始值　　176
        6.2.1　可以将权重初始值设为0 吗　　176
        6.2.2　隐藏层的激活值的分布　　177
        6.2.3　ReLU的权重初始值　　181
        6.2.4　基于MNIST数据集的权重初始值的比较　　183
        6.3 Batch Normalization　　184
        6.3.1　Batch Normalization 的算法　　184
        6.3.2　Batch Normalization 的评估　　186
        6.4 正则化　　188
        6.4.1　过拟合　　189
        6.4.2　权值衰减　　191
        6.4.3　Dropout　　192
        6.5 超参数的验证　　195
        6.5.1　验证数据　　195
        6.5.2　超参数的最优化　　196
        6.5.3　超参数最优化的实现　　198
        6.6 小结　　200
        第7章　卷积神经网络　　201
        7.1 整体结构　　201
        7.2 卷积层　　202
        7.2.1　全连接层存在的问题　　203
        7.2.2　卷积运算　　203
        7.2.3　填充　　206
        7.2.4　步幅　　207
        7.2.5　3 维数据的卷积运算　　209
        7.2.6　结合方块思考　　211
        7.2.7　批处理　　213
        7.3 池化层　　214
        7.4 卷积层和池化层的实现　　216
        7.4.1　4 维数组　　216
        7.4.2　基于im2col 的展开　　217
        7.4.3　卷积层的实现　　219
        7.4.4　池化层的实现　　222
        7.5 CNN的实现　　224
        7.6 CNN的可视化　　228
        7.6.1　第1 层权重的可视化　　228
        7.6.2　基于分层结构的信息提取　　230
        7.7 具有代表性的CNN　　231
        7.7.1　LeNet　　231
        7.7.2　AlexNet　　232
        7.8 小结　　233
        第8章　深度学习　　235
        8.1 加深网络　　235
        8.1.1　向更深的网络出发　　235
        8.1.2　进一步提高识别精度　　238
        8.1.3　加深层的动机　　240
        8.2 深度学习的小历史　　242
        8.2.1　ImageNet　　243
        8.2.2　VGG　　244
        8.2.3　GoogLeNet　　245
        8.2.4　ResNet　　246
        8.3 深度学习的高速化　　248
        8.3.1　需要努力解决的问题　　248
        8.3.2　基于GPU的高速化　　249
        8.3.3　分布式学习　　250
        8.3.4　运算精度的位数缩减　　252
        8.4 深度学习的应用案例　　253
        8.4.1　物体检测　　253
        8.4.2　图像分割　　255
        8.4.3　图像标题的生成　　256
        8.5 深度学习的未来　　258
        8.5.1　图像风格变换　　258
        8.5.2　图像的生成　　259
        8.5.3　自动驾驶　　261
        8.5.4　Deep Q-Network（强化学习）　　262
        8.6 小结　　264
        附录A　Softmax-with-Loss 层的计算图　　267
        A.1 正向传播　　268
        A.2 反向传播　　270
        A.3 小结　　277
        参考文献　　279
     · · · · · ·     (收起)"
25708312,C++ Primer 中文版（第 5 版）,9.4,(2781人评价),[美] Stanley B. Lippman、[美] Josée Lajoie、[美] Barbara E. Moo / 王刚、杨巨峰 / 电子工业出版社 / 2013-9-1 / 128.00元,这本久负盛名的 C++ 经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++ 大师 Stanley B. ...,https://book.douban.com/subject/25708312/,https://img1.doubanio.com/view/subject/s/public/s33903490.jpg,128.00元,9787121155352,这本久负盛名的 C++ 经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++ 大师 Stanley B. Lippman 的丰富实践经验，C++标准委员会原负责人 Josée Lajoie 对C++标准的深入理解，以及C+ + 先驱 Barbara E. Moo 在 C++教学方面的真知灼见外，更是基于全新的 C++11标准进行了全面而彻底的内容更新。非常难能可贵的是，本书所有示例均全部采用 C++11 标准改写，这在经典升级版中极其罕见——充分体现了 C++ 语言的重大进展及其全面实践。书中丰富的教学辅助内容、醒目的知识点提示，以及精心组织的编程示范，让这本书在 C++ 领域的权威地位更加不可动摇。无论是初学者入门，或是中、高级程序员提升，本书均为不容置疑的首选。,"Stanley B·Lippman
作者","第1章  开始	1
        1.1  编写一个简单的C++程序	2
        1.1.1  编译、运行程序	3
        1.2  初识输入输出	5
        1.3  注释简介	8
        1.4  控制流	10
        1.4.1  while语句	10
        1.4.2  for语句	11
        1.4.3  读取数量不定的输入数据	13
        1.4.4  if语句	15
        1.5  类简介	17
        1.5.1  Sales_item类	17
        1.5.2  初识成员函数	20
        1.6  书店程序	21
        小结	23
        术语表	23
        第Ⅰ部分  C++基础	27
        第2章  变量和基本类型	29
        2.1  基本内置类型	30
        2.1.1  算术类型	30
        2.1.2  类型转换	32
        2.1.3  字面值常量	35
        2.2  变量	38
        2.2.1  变量定义	38
        2.2.2  变量声明和定义的关系	41
        2.2.3  标识符	42
        2.2.4  名字的作用域	43
        2.3  复合类型	45
        2.3.1  引用	45
        2.3.2  指针	47
        2.3.3  理解复合类型的声明	51
        2.4  const限定符	53
        2.4.1  const的引用	54
        2.4.2  指针和const	56
        2.4.3  顶层const	57
        2.4.4  constexpr和常量表达式	58
        2.5  处理类型	60
        2.5.1  类型别名	60
        2.5.2  auto类型说明符	61
        2.5.3  decltype类型指示符	62
        2.6  自定义数据结构	64
        2.6.1  定义Sales_data类型	64
        2.6.2  使用Sales_data类	66
        2.6.3  编写自己的头文件	67
        小结	69
        术语表	69
        第3章  字符串、向量和数组	73
        3.1  命名空间的using声明	74
        3.2  标准库类型string	75
        3.2.1  定义和初始化string对象	76
        3.2.2  string对象上的操作	77
        3.2.3  处理string对象中的字符	81
        3.3  标准库类型vector	86
        3.3.1  定义和初始化vector对象	87
        3.3.2  向vector对象中添加元素	90
        3.3.3  其他vector操作	91
        3.4  迭代器介绍	95
        3.4.1  使用迭代器	95
        3.4.2  迭代器运算	99
        3.5  数组	101
        3.5.1  定义和初始化内置数组	101
        3.5.2  访问数组元素	103
        3.5.3  指针和数组	105
        3.5.4  C风格字符串	109
        3.5.5  与旧代码的接口	111
        3.6  多维数组	112
        小结	117
        术语表	117
        第4章  表达式	119
        4.1  基础	120
        4.1.1  基本概念	120
        4.1.2  优先级与结合律	121
        4.1.3  求值顺序	123
        4.2  算术运算符	124
        4.3  逻辑和关系运算符	126
        4.4  赋值运算符	129
        4.5  递增和递减运算符	131
        4.6  成员访问运算符	133
        4.7  条件运算符	134
        4.8  位运算符	135
        4.9  sizeof运算符	139
        4.10  逗号运算符	140
        4.11  类型转换	141
        4.11.1  算术转换	142
        4.11.2  其他隐式类型转换	143
        4.11.3  显式转换	144
        4.12  运算符优先级表	147
        小结	149
        术语表	149
        第5章  语句	153
        5.1  简单语句	154
        5.2  语句作用域	155
        5.3  条件语句	156
        5.3.1  if语句	156
        5.3.2  switch语句	159
        5.4  迭代语句	165
        5.4.1  while语句	165
        5.4.2  传统的for语句	166
        5.4.3  范围for语句	168
        5.4.4  do while语句	169
        5.5  跳转语句	170
        5.5.1  break语句	170
        5.5.2  continue语句	171
        5.5.3  goto语句	172
        5.6  TRY语句块和异常处理	172
        5.6.1  throw表达式	173
        5.6.2  try语句块	174
        5.6.3  标准异常	176
        小结	178
        术语表	178
        第6章  函数	181
        6.1  函数基础	182
        6.1.1  局部对象	184
        6.1.2  函数声明	186
        6.1.3  分离式编译	186
        6.2  参数传递	187
        6.2.1  传值参数	187
        6.2.2  传引用参数	188
        6.2.3  const形参和实参	190
        6.2.4  数组形参	193
        6.2.5  main：处理命令行选项	196
        6.2.6  含有可变形参的函数	197
        6.3  返回类型和return语句	199
        6.3.1  无返回值函数	200
        6.3.2  有返回值函数	200
        6.3.3  返回数组指针	205
        6.4  函数重载	206
        6.4.1  重载与作用域	210
        6.5  特殊用途语言特性	211
        6.5.1  默认实参	211
        6.5.2  内联函数和constexpr函数	213
        6.5.3  调试帮助	215
        6.6  函数匹配	217
        6.6.1  实参类型转换	219
        6.7  函数指针	221
        小结	225
        术语表	225
        第7章  类	227
        7.1  定义抽象数据类型	228
        7.1.1  设计Sales_data类	228
        7.1.2  定义改进的Sales_data类	230
        7.1.3  定义类相关的非成员函数	234
        7.1.4  构造函数	235
        7.1.5  拷贝、赋值和析构	239
        7.2  访问控制与封装	240
        7.2.1  友元	241
        7.3  类的其他特性	243
        7.3.1  类成员再探	243
        7.3.2  返回*this的成员函数	246
        7.3.3  类类型	249
        7.3.4  友元再探	250
        7.4  类的作用域	253
        7.4.1  名字查找与类的作用域	254
        7.5  构造函数再探	257
        7.5.1  构造函数初始值列表	258
        7.5.2  委托构造函数	261
        7.5.3  默认构造函数的作用	262
        7.5.4  隐式的类类型转换	263
        7.5.5  聚合类	266
        7.5.6  字面值常量类	267
        7.6  类的静态成员	268
        小结	273
        术语表	273
        第Ⅱ部  C++标准库	275
        第8章  IO库	277
        8.1  IO类	278
        8.1.1  IO对象无拷贝或赋值	279
        8.1.2  条件状态	279
        8.1.3  管理输出缓冲	281
        8.2  文件输入输出	283
        8.2.1  使用文件流对象	284
        8.2.2  文件模式	286
        8.3  string流	287
        8.3.1  使用istringstream	287
        8.3.2  使用ostringstream	289
        小结	290
        术语表	290
        第9章  顺序容器	291
        9.1  顺序容器概述	292
        9.2  容器库概览	294
        9.2.1  迭代器	296
        9.2.2  容器类型成员	297
        9.2.3  begin和end成员	298
        9.2.4  容器定义和初始化	299
        9.2.5  赋值和swap	302
        9.2.6  容器大小操作	304
        9.2.7  关系运算符	304
        9.3  顺序容器操作	305
        9.3.1  向顺序容器添加元素	305
        9.3.2  访问元素	309
        9.3.3  删除元素	311
        9.3.4  特殊的forward_list操作	312
        9.3.5  改变容器大小	314
        9.3.6  容器操作可能使迭代器失效	315
        9.4  vector对象是如何增长的	317
        9.5  额外的string操作	320
        9.5.1  构造string的其他方法	321
        9.5.2  改变string的其他方法	322
        9.5.3  string搜索操作	325
        9.5.4  compare函数	327
        9.5.5  数值转换	327
        9.6  容器适配器	329
        小结	332
        术语表	332
        第10章  泛型算法	335
        10.1  概述	336
        10.2  初识泛型算法	338
        10.2.1  只读算法	338
        10.2.2  写容器元素的算法	339
        10.2.3  重排容器元素的算法	342
        10.3  定制操作	344
        10.3.1  向算法传递函数	344
        10.3.2  lambda表达式	345
        10.3.3  lambda捕获和返回	349
        10.3.4  参数绑定	354
        10.4  再探迭代器	357
        10.4.1  插入迭代器	358
        10.4.2  iostream迭代器	359
        10.4.3  反向迭代器	363
        10.5  泛型算法结构	365
        10.5.1  5类迭代器	365
        10.5.2  算法形参模式	367
        10.5.3  算法命名规范	368
        10.6  特定容器算法	369
        小结	371
        术语表	371
        第11章  关联容器	373
        11.1  使用关联容器	374
        11.2  关联容器概述	376
        11.2.1  定义关联容器	376
        11.2.2  关键字类型的要求	378
        11.2.3  pair类型	379
        11.3  关联容器操作	381
        11.3.1  关联容器迭代器	382
        11.3.2  添加元素	383
        11.3.3  删除元素	386
        11.3.4  map的下标操作	387
        11.3.5  访问元素	388
        11.3.6  一个单词转换的map	391
        11.4  无序容器	394
        小结	397
        术语表	397
        第12章  动态内存	399
        12.1  动态内存与智能指针	400
        12.1.1  shared_ptr类	400
        12.1.2  直接管理内存	407
        12.1.3  shared_ptr和new结合使用	412
        12.1.4  智能指针和异常	415
        12.1.5  unique_ptr	417
        12.1.6  weak_ptr	420
        12.2  动态数组	423
        12.2.1  new和数组	423
        12.2.2  allocator类	427
        12.3  使用标准库：文本查询程序	430
        12.3.1  文本查询程序设计	430
        12.3.2  文本查询程序类的定义	432
        小结	436
        术语表	436
        第Ⅲ部分  类设计者的工具	437
        第13章  拷贝控制	439
        13.1  拷贝、赋值与销毁	440
        13.1.1  拷贝构造函数	440
        13.1.2  拷贝赋值运算符	443
        13.1.3  析构函数	444
        13.1.4  三/五法则	447
        13.1.5  使用=default	449
        13.1.6  阻止拷贝	449
        13.2  拷贝控制和资源管理	452
        13.2.1  行为像值的类	453
        13.2.2  定义行为像指针的类	455
        13.3  交换操作	457
        13.4  拷贝控制示例	460
        13.5  动态内存管理类	464
        13.6  对象移动	470
        13.6.1  右值引用	471
        13.6.2  移动构造函数和移动赋值运算符	473
        13.6.3  右值引用和成员函数	481
        小结	486
        术语表	486
        第14章  操作重载与类型转换	489
        14.1  基本概念	490
        14.2  输入和输出运算符	494
        14.2.1  重载输出运算符<<	494
        14.2.2  重载输入运算符>>	495
        14.3  算术和关系运算符	497
        14.3.1  相等运算符	497
        14.3.2  关系运算符	498
        14.4  赋值运算符	499
        14.5  下标运算符	501
        14.6  递增和递减运算符	502
        14.7  成员访问运算符	504
        14.8  函数调用运算符	506
        14.8.1  lambda是函数对象	507
        14.8.2  标准库定义的函数对象	509
        14.8.3  可调用对象与function	511
        14.9  重载、类型转换与运算符	514
        14.9.1  类型转换运算符	514
        14.9.2  避免有二义性的类型转换	517
        14.9.3  函数匹配与重载运算符	521
        小结	523
        术语表	523
        第15章  面向对象程序设计	525
        15.1  OOP：概述	526
        15.2  定义基类和派生类	527
        15.2.1  定义基类	528
        15.2.2  定义派生类	529
        15.2.3  类型转换与继承	534
        15.3  虚函数	536
        15.4  抽象基类	540
        15.5  访问控制与继承	542
        15.6  继承中的类作用域	547
        15.7  构造函数与拷贝控制	551
        15.7.1  虚析构函数	552
        15.7.2  合成拷贝控制与继承	552
        15.7.3  派生类的拷贝控制成员	554
        15.7.4  继承的构造函数	557
        15.8  容器与继承	558
        15.8.1  编写Basket类	559
        15.9  文本查询程序再探	562
        15.9.1  面向对象的解决方案	563
        15.9.2  Query_base类和Query类	567
        15.9.3  派生类	568
        15.9.4  eval函数	571
        小结	575
        术语表	575
        第16章  模板与泛型编程	577
        16.1  定义模板	578
        16.1.1  函数模板	578
        16.1.2  类模板	583
        16.1.3  模板参数	592
        16.1.4  成员模板	595
        16.1.5  控制实例化	597
        16.1.6  效率与灵活性	599
        16.2  模板实参推断	600
        16.2.1  类型转换与模板类型参数	601
        16.2.2  函数模板显式实参	603
        16.2.3  尾置返回类型与类型转换	604
        16.2.4  函数指针和实参推断	607
        16.2.5  模板实参推断和引用	608
        16.2.6  理解std::move	610
        16.2.7  转发	612
        16.3  重载与模板	614
        16.4  可变参数模板	618
        16.4.1  编写可变参数函数模板	620
        16.4.2  包扩展	621
        16.4.3  转发参数包	622
        16.5  模板特例化	624
        小结	630
        术语表	630
        第Ⅳ部分  高级主题	633
        第17章  标准库特殊设施	635
        17.1  tuple类型	636
        17.1.1  定义和初始化tuple	637
        17.1.2  使用tuple返回多个值	638
        17.2  BITSET类型	640
        17.2.1  定义和初始化bitset	641
        17.2.2  bitset操作	643
        17.3  正则表达式	645
        17.3.1  使用正则表达式库	646
        17.3.2  匹配与Regex迭代器类型	650
        17.3.3  使用子表达式	653
        17.3.4  使用regex_replace	657
        17.4  随机数	659
        17.4.2  其他随机数分布	663
        bernoulli_distribution类	665
        17.5  IO库再探	666
        17.5.1  格式化输入与输出	666
        17.5.2  未格式化的输入/输出操作	673
        17.5.3  流随机访问	676
        小结	680
        术语表	680
        第18章  用于大型程序的工具	683
        18.1  异常处理	684
        18.1.1  抛出异常	684
        18.1.2  捕获异常	687
        18.1.3  函数try语句块与构造函数	689
        18.1.4  noexcept异常说明	690
        18.1.5  异常类层次	693
        18.2  命名空间	695
        18.2.1  命名空间定义	695
        18.2.2  使用命名空间成员	701
        18.2.3  类、命名空间与作用域	705
        18.2.4  重载与命名空间	708
        18.3  多重继承与虚继承	710
        18.3.1  多重继承	711
        18.3.2  类型转换与多个基类	713
        18.3.3  多重继承下的类作用域	715
        18.3.4  虚继承	717
        18.3.5  构造函数与虚继承	720
        小结	722
        术语表	722
        第19章  特殊工具与技术	725
        19.1  控制内存分配	726
        19.1.1  重载new和delete	726
        19.1.2  定位new表达式	729
        19.2  运行时类型识别	730
        19.2.1  dynamic_cast运算符	730
        19.2.2  typeid运算符	732
        19.2.3  使用RTTI	733
        19.2.4  type_info类	735
        19.3  枚举类型	736
        19.4  类成员指针	739
        19.4.1  数据成员指针	740
        19.4.2  成员函数指针	741
        19.4.3  将成员函数用作可调用对象	744
        19.5  嵌套类	746
        19.6  union：一种节省空间的类	749
        19.7  局部类	754
        19.8  固有的不可移植的特性	755
        19.8.1  位域	756
        19.8.2  volatile限定符	757
        19.8.3  链接指示：extern ""C""	758
        小结	762
        术语表	762
        附录A  标准库	765
        A.1  标准库名字和头文件	766
        A.2  算法概览	770
        A.2.1  查找对象的算法	771
        A.2.2  其他只读算法	772
        A.2.3  二分搜索算法	772
        A.2.4  写容器元素的算法	773
        A.2.5  划分与排序算法	775
        A.2.6  通用重排操作	776
        A.2.7  排列算法	778
        A.2.8  有序序列的集合算法	778
        A.2.9  最小值和最大值	779
        A.2.10  数值算法	780
        A.3  随机数	781
        A.3.1  随机数分布	781
        A.3.2  随机数引擎	783
        C++11的新特性
        2.1.1  long long类型	31
        2.2.1  列表初始化	39
        2.3.2  nullptr常量	48
        2.4.4  constexpr变量	59
        2.5.1  类型别名声明	60
        2.5.2  auto类型指示符	61
        2.5.3  decltype类型指示符	62
        2.6.1  类内初始化	65
        3.2.2  使用auto或decltype缩写类型	79
        3.2.3  范围for语句	82
        3.3   定义vector对象的vector（向量的向量）	87
        3.3.1  vector对象的列表初始化	88
        3.4.1  容器的cbegin和cend函数	98
        3.5.3  标准库begin和end函数	106
        3.6   使用auto和decltype简化声明	115
        4.2   除法的舍入规则	125
        4.4   用大括号包围的值列表赋值	129
        4.9   将sizeof用于类成员	139
        5.4.3 范围for语句	168
        6.2.6  标准库initializer_list类	197
        6.3.2  列表初始化返回值	203
        6.3.3  定义尾置返回类型	206
        6.3.3  使用decltype简化返回类型定义
        6.5.2  constexpr函数	214
        7.1.4  使用=default生成默认构造函数	237
        7.3.1  类对象成员的类内初始化	246
        7.5.2  委托构造函数	261
        7.5.6  constexpr构造函数	268
        8.2.1  用string对象处理文件名	284
        9.1   array和forward_list容器	293
        9.2.3 容器的cbegin和cend函数	298
        9.2.4  容器的列表初始化	300
        9.2.5  容器的非成员函数swap	303
        9.3.1  容器insert成员的返回类型	308
        9.3.1  容器的emplace成员的返回类型	308
        9.4   shrink_to_fit	318
        9.5.5  string的数值转换函数	327
        10.3.2  Lambda表达式	346
        10.3.3  Lambda表达式中的尾置返回类型	353
        10.3.4  标准库bind函数	354
        11.2.1  关联容器的列表初始化	377
        11.2.3  列表初始化pair的返回类型	380
        11.3.2  pair的列表初始化	384
        11.4   无序容器	394
        12.1   智能指针	400
        12.1.1  shared_ptr类
        12.1.2  动态分配对象的列表初始化	407
        12.1.2  auto和动态分配	408
        12.1.5  unique_ptr类	417
        12.1.6  weak_ptr类	420
        12.2.1  范围for语句不能应用于动态分配数组	424
        12.2.1  动态分配数组的列表初始化	424
        12.2.1  auto不能用于分配数组	424
        12.2.2  allocator::construct可使用任意构造函数	428
        13.1.5  将=default用于拷贝控制成员	449
        13.1.6  使用=default阻止拷贝类对象	449
        13.5   用移动类对象代替拷贝类对象	469
        13.6.1  右值引用	471
        13.6.1  标准库move函数	472
        13.6.2  移动构造函数和移动赋值	473
        13.6.2  移动构造函数通常应该是noexcept	473
        13.6.2  移动迭代器	480
        13.6.3  引用限定成员函数	483
        14.8.3  function类模板	512
        14.9.1  explicit类型转换运算符	516
        15.2.2  虚函数的override指示符	530
        15.2.2  通过定义类为final来阻止继承	533
        15.3   虚函数的override和final指示符	538
        15.7.2  删除的拷贝控制和继承	553
        15.7.4  继承的构造函数	557
        16.1.2  声明模板类型形参为友元	590
        16.1.2  模板类型别名	590
        16.1.3  模板函数的默认模板参数	594
        16.1.5  实例化的显式控制	597
        16.2.3  模板函数与尾置返回类型	605
        16.2.5  引用折叠规则	609
        16.2.6  用static_cast将左值转换为右值	612
        16.2.7  标准库forward函数	614
        16.4   可变参数模板	618
        16.4   sizeof...运算符	619
        16.4.3  可变参数模板与转发	622
        17.1   标准库Tuple类模板	636
        17.2.2  新的bitset运算	643
        17.3   正则表达式库	645
        17.4   随机数库	659
        17.5.1  浮点数格式控制	670
        18.1.4  noexcept异常指示符	690
        18.1.4  noexcept运算符	691
        18.2.1  内联名字空间	699
        18.3.1  继承的构造函数和多重继承	712
        19.3   有作用域的enum	736
        19.3   说明类型用于保存enum对象	738
        19.3   enum的提前声明	738
        19.4.3  标准库mem_fn类模板	746
        19.6   类类型的联合成员	751
     · · · · · ·     (收起)"
36457109,程序员的README,8.6,(95人评价),[美] 克里斯·里科米尼（Chris Riccomini）、[美] 德米特里·里亚博伊（Dmitriy Ryaboy） / 付裕 / 人民邮电出版社 / 2023-7-10 / 79.8,对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填...,https://book.douban.com/subject/36457109/,https://img9.doubanio.com/view/subject/s/public/s34570616.jpg,79.8,9787115599438,"对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新...(展开全部)





对于刚刚成为软件工程师的新手来说，知道如何编写代码只是成功了一半。你可能很快就会发现，学校并没有教授在现实世界中至关重要的技能和工作中必要的流程。本书恰恰填补了这一环节，它是作者十多年来在大型公司指导初级工程师工作的教程，涵盖软件工程的基础知识和最佳实践。 本书第1～2 章讲解当你在公司开启你的职业生涯时会发生什么；第3～11 章会扩展你的工作技能，教你如何使用现有代码库、解决和防止技术债、编写生产级软件、管理依赖关系、有效地测试、评审代码、交付软件、处理On-Call 时的事故和构建可演进的架构等；剩余章节涵盖管理能力和职业阶梯的提升等相关内容，例如敏捷计划、与管理者合作以及成长为资深工程师的必经之路。本书中非常重要的一部分内容是教你如何应对糟糕的管理，以及如何调整自己的节奏。 本书内容不仅浅显易懂，还覆盖整个软件开发周期，是一本技术主管希望每名新入行的工程师在开始工作之前都能阅读的书。","付裕
译者","第1 章 前面的旅程 1
        1.1 你的目的地 1
        1.2 你的旅程地图 2
        1.2.1 新手营 3
        1.2.2 试炼之河 5
        1.2.3 贡献者之角 5
        1.2.4 运维之海 6
        1.2.5 胜任之湾 6
        1.3 前进！ 7
        第2 章 步入自觉阶段 8
        2.1 学习如何学习 9
        2.1.1 前置学习 9
        2.1.2 在实践中学习 9
        2.1.3 运行实例代码 11
        2.1.4 阅读 11
        2.1.5 观看讲座 13
        2.1.6 适度地参加会议和聚会 14
        2.1.7 跟班学习并同有经验的工程师结对 15
        2.1.8 用副业项目实践 16
        2.2 提出问题 17
        2.2.1 动手调查一下 17
        2.2.2 设置一个时间限制 17
        2.2.3 写下全过程 18
        2.2.4 别打扰别人 19
        2.2.5 多用“非打扰式”交流 20
        2.2.6 批量处理你的同步请求 20
        2.3 克服成长的障碍 21
        2.3.1 冒充者综合征 21
        2.3.2 邓宁-克鲁格效应 22
        2.4 行为准则 23
        2.5 升级加油站 23
        第3 章 玩转代码 25
        3.1 软件的熵 26
        3.2 技术债 26
        3.3 变更代码 29
        3.3.1 善于利用现有代码 30
        3.3.2 过手的代码要比之前更干净 32
        3.3.3 做渐变式的修改 33
        3.3.4 对重构要务实 33
        3.3.5 善用IDE 34
        3.3.6 请使用VCS 的最佳实践 34
        3.4 避“坑”指南 35
        3.4.1 保守一些的技术选型 36
        3.4.2 不要特立独行 39
        3.4.3 不要只分叉而不向上游提交修改 40
        3.4.4 克制重构的冲动 40
        3.5 行为准则 42
        3.6 升级加油站 42
        第4 章 编写可维护的代码 44
        4.1 防御式编程 45
        4.1.1 避免空值 45
        4.1.2 保持变量不可变 46
        4.1.3 使用类型提示和静态类型检查器 46
        4.1.4 验证输入 47
        4.1.5 善用异常 49
        4.1.6 异常要有精确含义 50
        4.1.7 早抛晚捕 51
        4.1.8 智能重试 52
        4.1.9 构建幂等系统 53
        4.1.10 及时释放资源 53
        4.2 关于日志的使用 54
        4.2.1 给日志分级 55
        4.2.2 日志的原子性 56
        4.2.3 关注日志性能 57
        4.2.4 不要记录敏感数据 59
        4.3 系统监控 59
        4.3.1 使用标准的监控组件 60
        4.3.2 测量一切 63
        4.4 跟踪器 64
        4.5 配置相关注意事项 64
        4.5.1 配置无须新花样 65
        4.5.2 记录并校验所有的配置 66
        4.5.3 提供默认值 67
        4.5.4 给配置分组 67
        4.5.5 将配置视为代码 67
        4.5.6 保持配置文件清爽 68
        4.5.7 不要编辑已经部署的配置 68
        4.6 工具集 68
        4.7 行为准则 70
        4.8 升级加油站 71
        第5 章 依赖管理 72
        5.1 依赖管理基础知识 73
        5.1.1 语义化版本 74
        5.1.2 传递依赖 75
        5.2 相依性地狱 76
        5.3 避免相依性地狱 80
        5.3.1 隔离依赖项 80
        5.3.2 按需添加依赖项 81
        5.3.3 指定依赖项的版本 82
        5.3.4 依赖范围最小化 84
        5.3.5 保护自己免受循环依赖的影响 84
        5.4 行为准则 85
        5.5 升级加油站 85
        第6 章 测试 87
        6.1 测试的多种用途 87
        6.2 测试类型 88
        6.3 测试工具 91
        6.3.1 模拟库 91
        6.3.2 测试框架 92
        6.3.3 代码质量工具 93
        6.4 自己动手编写测试 95
        6.4.1 编写干净的测试 95
        6.4.2 避免过度测试 96
        6.5 测试中的确定性 98
        6.5.1 种子随机数生成器 99
        6.5.2 不要在单元测试中调用远程系统 99
        6.5.3 采用注入式时间戳 99
        6.5.4 避免使用休眠和超时 102
        6.5.5 记得关闭网络套接字和文件句柄 102
        6.5.6 绑定到0 端口 103
        6.5.7 生成唯一的文件路径和数据库位置 103
        6.5.8 隔离并清理剩余的测试状态 103
        6.5.9 不要依赖测试顺序 104
        6.6 行为准则 105
        6.7 升级加油站 105
        第7 章 代码评审 107
        7.1 为什么需要评审代码? 107
        7.2 当你的代码被评审时 109
        7.2.1 准备工作 109
        7.2.2 用评审草案降低风险 110
        7.2.3 提交评审请勿触发测试 111
        7.2.4 预排大体量的代码修改 111
        7.2.5 不要太在意 112
        7.2.6 保持同理心，但不要容忍粗鲁 113
        7.2.7 保持主动 113
        7.3 评审别人的代码时 114
        7.3.1 分流评审请求 114
        7.3.2 给评审预留时间 114
        7.3.3 理解修改的意图 115
        7.3.4 提供全面的反馈 115
        7.3.5 要承认优点 116
        7.3.6 区分问题、建议和挑剔 116
        7.3.7 不要只做橡皮图章 117
        7.3.8 不要只局限于使用网页版的评审工具 118
        7.3.9 不要忘记评审测试代码 118
        7.3.10 推动决断 118
        7.4 行为准则 119
        7.5 升级加油站 120
        第8 章 软件交付 121
        8.1 软件交付流程 121
        8.2 分支策略 122
        8.3 构建环节 125
        8.3.1 打包需要带版本号 126
        8.3.2 将不同的资源单独打包 127
        8.4 发布环节 129
        8.4.1 请勿只想着发布 129
        8.4.2 将包发布到仓库 130
        8.4.3 保持版本不变性 131
        8.4.4 频繁发布 131
        8.4.5 对发布计划保持透明 132
        8.4.6 撰写变更日志和发行说明 132
        8.5 部署环节 133
        8.5.1 自动部署 133
        8.5.2 部署的原子性 134
        8.5.3 独立地部署应用 134
        8.6 展开环节 136
        8.6.1 系统监控 137
        8.6.2 特性开关 137
        8.6.3 熔断器 138
        8.6.4 并行的服务版本梯队 139
        8.6.5 摸黑启动 141
        8.7 行为准则 143
        8.8 升级加油站 144
        第9 章 On-Call 146
        9.1 On-Call 的工作方式 147
        9.2 On-Call 技能包 148
        9.2.1 随时响应 148
        9.2.2 保持专注 148
        9.2.3 确定工作优先级 149
        9.2.4 清晰的沟通 150
        9.2.5 跟踪你的工作 151
        9.3 事故处理 152
        9.3.1 分流 153
        9.3.2 协同 154
        9.3.3 应急方案 155
        9.3.4 解决方案 157
        9.3.5 后续行动 159
        9.4 提供支持 162
        9.5 不要逞英雄 164
        9.6 行为准则 165
        9.7 升级加油站 165
        第10 章 技术设计流程 167
        10.1 技术设计的V 形结构 168
        10.2 关于设计的思考 169
        10.2.1 定义问题 170
        10.2.2 着手调查 171
        10.2.3 进行实验 172
        10.2.4 给些时间 173
        10.3 撰写设计文档 174
        10.3.1 文档持续变更 174
        10.3.2 了解撰写文档的目的 175
        10.3.3 学会写作 176
        10.3.4 保证文档是最新的 176
        10.4 使用设计文档模板 177
        10.4.1 概要 178
        10.4.2 现状与背景 178
        10.4.3 变更的目的 178
        10.4.4 需求 179
        10.4.5 潜在的解决方案 179
        10.4.6 建议的解决方案 180
        10.4.7 设计与架构 180
        10.4.8 测试计划 181
        10.4.9 发布计划 181
        10.4.10 遗留的问题 181
        10.4.11 附录 181
        10.5 协作设计 182
        10.5.1 理解你的团队的设计评审流程 182
        10.5.2 不要让人惊讶 183
        10.5.3 用设计讨论来进行头脑风暴 183
        10.5.4 为设计出力 184
        10.6 行为准则 185
        10.7 升级加油站 185
        第11 章 构建可演进的架构 187
        11.1 理解复杂性 188
        11.2 可演进的设计 189
        11.2.1 你不是真的需要 189
        11.2.2 最小惊讶原则 191
        11.2.3 封装专业领域知识 193
        11.3 可演进的API 193
        11.3.1 保持API 小巧 194
        11.3.2 公开定义良好的服务端API 194
        11.3.3 保持API 变更的兼容性 195
        11.3.4 API 版本化 198
        11.4 可持续的数据管理 199
        11.4.1 数据库隔离 199
        11.4.2 使用schema 201
        11.4.3 schema 自动化迁移 203
        11.4.4 保持schema 的兼容性 206
        11.5 行为准则 207
        11.6 升级加油站 208
        第12 章 敏捷计划 210
        12.1 敏捷宣言 210
        12.2 敏捷计划的框架 211
        12.3 Scrum 框架 212
        12.3.1 用户故事 213
        12.3.2 任务分解 214
        12.3.3 故事点 214
        12.3.4 消化积压 216
        12.3.5 冲刺计划 216
        12.4 站会 217
        12.5 评审机制 218
        12.6 回顾会 219
        12.7 路线图 220
        12.8 行为准则 221
        12.9 升级加油站 222
        第13 章 与管理者合作 223
        13.1 管理者是做什么的 223
        13.2 沟通、目标与成长 224
        13.2.1 一对一面谈 225
        13.2.2 PPP 227
        13.2.3 OKR 229
        13.2.4 绩效考核 230
        13.3 向上管理 232
        13.3.1 接收反馈 232
        13.3.2 给予反馈 233
        13.3.3 讨论你的目标 235
        13.3.4 事情不顺时要采取行动 236
        13.4 行为准则 238
        13.5 升级加油站 239
        第14 章 职业生涯规划 241
        14.1 迈向资深之路 241
        14.2 职业生涯建议 242
        14.2.1 T 型人才 242
        14.2.2 参加工程师训练营 243
        14.2.3 主导你自己的晋升 244
        14.2.4 换工作需谨慎 246
        14.2.5 自我调节 247
        14.3 结尾寄语 248
     · · · · · ·     (收起)"
35503091,C语言程序设计：现代方法（第2版•修订版）,9.2,(114人评价),[美] K.N.金 / 吕秀锋、黄倩 / 图灵丨人民邮电出版社 / 2021-7 / 129.80元,"◎ 本书特色
近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分
哈佛、麻省理工、斯坦福等诸多名校C语言教材
基于C1X标准全新升级
浙江大...",https://book.douban.com/subject/35503091/,https://img9.doubanio.com/view/subject/s/public/s33927414.jpg,129.80元,9787115565198,"◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超...(展开全部)





◎ 本书特色 近30年来珍宝级C语言入门经典，累计印数10万+，豆瓣评分9.3分 哈佛、麻省理工、斯坦福等诸多名校C语言教材 基于C1X标准全新升级 浙江大学教授翁恺、哈尔滨工业大学教授苏小红、Boolan首席咨询师吴咏炜、资深Linux专家宋宝华联合推荐 ◎ 内容简介 时至今日，C语言仍然是计算机领域的通用语言之一，但今天的C语言已经和最初的时候大不相同了。本书主要目的就是通过一种“现代方法”来介绍C语言，书中强调标准C，强调软件工程，不再强调“手工优化”。第2版修订版中不仅有C99中的新特性，还与时俱进地增加了C11和C18中的内容。本书分为C语言的基础特性、C语言的高级特性、C语言标准库和参考资料4个部分。每章末尾的“问与答”部分给出一系列与该章内容相关的问题及答案，此外还包含适量的习题。 ◎ 名人推荐 C语言已经有近50年的历史了。在中国，超过95%的大学用C语言作为入门编程语言，但也因此把C语言当作一种学习编程的教学媒介语言来教，使得学生只学到了其中的基础部分，而对C语言近30年的发展及其在工业中的应用所知甚少。本书是难得的真正讲述C语言的教材，覆盖了C99、C11、C18标准的内容。本书非常适合今后会用C语言来做嵌入式系统、设备驱动和操作系统等产品开发的人士学习。在浙江大学，我们在工程实践课程中使用了本书的上一个版本，收获了良好的教学效果。 ——翁恺，浙江大学计算机学院教授 书如其名，本书以一种崭新的视角和通俗易懂的方式，来向读者介绍C语言的“现代方法”，聚焦程序设计的核心问题和方法，给C语言这门经久不衰、老而弥坚的语言赋予了崭新的面貌。本书介绍了C99和C1X的许多新特性，而且编排方式方便读者查阅。本书用现代的视角来解读C语言，每章后面的“问与答”也很贴心，适时地解答了读者在阅读过程中可能会遇到的很多疑难问题。本书内容特别适合具备一定语言基础，想深入了解C语言精髓的读者，我相信这本书一定会受到读者的欢迎，成为C语言爱好者提升内功的一本武林秘笈。 ——苏小红，哈尔滨工业大学教授、博士生导师，省级教学名师 本书讨论了C语言的所有特性，从C89一直贯穿到C18。内容足够新，也足够全面，这就是它的突出特色。 ——吴咏炜，Boolan首席咨询师 本书是C语言程序设计的经典图书，本次修订版增加了C1X的内容，并就C1X与之前的C89、C99进行了比对，做到了与时俱进。本书更是新增了第28章，重点介绍了C1X的多线程特性，相信对读者会有巨大的帮助。读者通过阅读本书，可深入理解C89、C99和C1X的演进，并进一步思考C语言为什么这么演进，这对提高自身的思维能力以及对软件工程问题的认知都会有帮助。 ——宋宝华，资深Linux专家",作者简介 K. N. 金（K. N. King） 世界知名的计算机程序设计教育家。他拥有耶鲁大学计算机科学硕士学位，加州大学伯克利分校计算机科学博士学位，曾任教于佐治亚理工学院和佐治亚州立大学。除本书外，他还撰写了广受欢迎的著作Modula-2: A Complete Guide和Java Programming: From the Beginning。 译者简介 吕秀锋 曾任教于北京理工大学软件学院，讲授过多门计算机课程，包括“计算机基础（双语）”“C语言程序设计（双语）”“数据结构”“程序设计开发与实践”。 黄倩 河海大学计算机科学与技术系主任，兼任中国人工智能学会深度学习专委会委员、中国计算机学会多媒体技术专委会委员。博士毕业于中国科学院计算技术研究所，译有《编程珠玑（第2版）》等。,"第1章 C语言概述
        第2章 C语言基本概念
        第3章 格式化输入/输出
        第4章 表达式
        第5章 选择语句
        第6章 循环
        第7章 基本类型
        第8章 数组
        第9章 函数
        第10章 程序结构
        第11章 指针
        第12章 指针和数组
        第13章 字符串
        第14章 预处理器
        第15章 编写大型程序
        第16章 结构、联合和枚举
        第17章 指针的高级应用
        第18章 声明
        第19章 程序设计
        第20章 底层程序设计
        第21章 标准库
        第22章 输入/输出
        第23章 库对数值和字符数据的支持
        第24章 错误处理
        第25章 国际化特性
        第26章 其他库函数
        第27章 C99对数学计算的新增支持
        第28章 C1X新增的多线程和原子操作支持
        附录A C语言运算符
        附录B C1X与C99的比较
        附录C C99与C89的比较
        附录D C89与经典C的比较
        附录E 标准库函数
        附录F ASCII字符集
        延伸阅读
        索引
     · · · · · ·     (收起)"
1998341,计算机系统要素,9.1,(269人评价),[美] Noam Nisan、[美] Shimon Schocken / 周维、宋磊、陈曦 / 电子工业出版社 / 2007-01-01 / 45.00元,本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，...,https://book.douban.com/subject/1998341/,https://img9.doubanio.com/view/subject/s/public/s2207295.jpg,45.00元,9787121033360,"本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统...(展开全部)





本书通过展现简单但功能强大的计算机系统之构建过程，为读者呈现了一幅完整、严格的计算机应用科学大图景。本书作者认为，理解计算机工作原理的最好方法就是亲自动手，从零开始构建计算机系统。 通过12个章节和项目来引领读者从头开始，本书逐步地构建一个基本的硬件平台和现代软件阶层体系。在这个过程中，读者能够获得关于硬件体系结构、操作系统、编程语言、编译器、数据结构、算法以及软件工程的详实知识。通过这种逐步构造的方法，本书揭示了计算机科学知识中的重要成分，并展示其它课程中所介绍的理论和应用技术如何融入这幅全局大图景当中去。全书基于“先抽象再实现”的阐述模式，每一章都介绍一个关键的硬件或软件抽象，一种实现方式以及一个实际的项目。完成这些项目所必要的计算机科学知识在本书中都有涵盖，只要求读者具备程序设计经验。本书配套的支持网站提供了书中描述的用于构建所有硬件和软件系统所必需的工具和资料，以及用于12个项目的200个测试程序。 全书内容广泛、涉猎全面，适合计算机及相关专业本科生、研究生、技术开发人员、教师以及技术爱好者参考和学习。","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
    · · · · · ·
    (更多)","前言
        介绍：Hello, World Below
        第1章 布尔逻辑
        1.1 背景知识
        1.1.1 布尔代数
        1.1.2 门逻辑
        1.1.3 实际硬件结构
        1.1.4 硬件描述语言（HDL）
        1.1.5 硬件仿真
        1.2 规范详述
        1.2.1 Nand门
        1.2.2 基本逻辑门
        1.2.3 多位基本门
        1.2.4 多通道逻辑门
        1.3 实现
        1.4 观点
        1.5 项目
        第2章 布尔运算
        2.1 背景知识
        2.2 规范详述
        2.2.1 加法器
        2.2.2 算术逻辑单元（ALU）
        2.3 实现
        2.4 观点
        2.5 项目
        第3章 时序逻辑
        3.1 背景知识
        3.2 规范详述
        3.2.1 D触发器
        3.2.2 寄存器
        3.2.3 存储
        3.2.4 计数器
        3.3 实现
        3.4 观点
        3.5 项目
        第4章 机器语言
        4.1 背景知识
        4.1.1 机器
        4.1.2 语言
        4.1.3 命令
        4.2 Hack机器语言规范详述
        4.2.1 概述
        4.2.2 A-指令
        4.2.3 C-指令
        4.2.4 符号
        4.2.5 输入/输出处理
        4.2.6 语法规约和文件格式
        4.3 观点
        4.4 项目
        第5章 计算机体系结构
        5.1 背景知识
        5.1.1 存储程序概念
        5.1.2 冯?诺依曼结构
        5.1.3 内存
        5.1.4 中央处理器
        5.1.5 寄存器
        5.1.6 输入和输出
        5.2 Hack硬件平台规范详述
        5.2.1 概述
        5.2.2 中央处理器（CPU）
        5.2.3 指令内存
        5.2.4 数据内存
        5.2.5 计算机
        5.3 实现
        5.3.1 中央处理器
        5.3.2 内存
        5.3.3 计算机
        5.4 观点
        5.5 项目
        第6章 汇编编译器
        第7章 虚拟机Ⅰ：堆栈运算
        第8章 虚拟机Ⅱ：程序控制
        第9章 高级语言
        第10章 编译器Ⅰ：语法分析
        第11章 编译器Ⅱ：代码生成
        第12章 操作系统
        第13章 后记：发掘更多乐趣
        附录A： 硬件描述语言（HDL）
        附录B： 测试脚本语言
        索引
     · · · · · ·     (收起)"
35972849,代码大全2（纪念版）,9.3,(62人评价),[美] 史蒂夫·麦康奈尔(Steve McConnell) / 陈玉毅、陈军、杨志昂、洪佳、徐东伟、王国良、徐毅、李虎 / 清华大学出版社 / 2022-7-7 / 256.00,"《软件开发》杂志Jolt大奖
大而全，洞悉软件构建精髓
优而先，兼顾行业实践研究
奠定硬核技术领导力的经典
庸常变身卓越的实用性指导
《代码大全2》是著名科...",https://book.douban.com/subject/35972849/,https://img3.doubanio.com/view/subject/s/public/s34276333.jpg,256.00,9787302583646,"《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序...(展开全部)





《软件开发》杂志Jolt大奖 大而全，洞悉软件构建精髓 优而先，兼顾行业实践研究 奠定硬核技术领导力的经典 庸常变身卓越的实用性指导 《代码大全2》是著名科技类作家史蒂夫·麦康奈尔的经典著作，是一本完整的软件构建手册，涵盖了软件构建过程中的所有细节。它从软件质量和编程思想等方面论述了软件构建的各个问题，并详细论述了紧跟时代潮流的新技术、高屋建瓴的观点、通用的概念，还含有丰富而典型的程序示例。本书所论述的技术不仅填补了初级与中高级编程技术之间的空白，而且也为程序员提供了一个有关编程技巧的信息来源。 本书的缘起与使命，响应计算机科学与技术委员会的报告，植根于“软件工程参考手册”这个基本的概念，同时兼顾软件质量和研发效能，对已有的高效软件工程实践进行全面收集、萃取、分类和传播（CSTB 1990, McConnell 1997a）。 这本书对经验丰富的程序员、技术带头人、自学的程序员及几乎不懂太多编程技巧的学生们都是大有裨益的。无论是什么背景的读者，阅读本书都有助于在更短的时间内、更容易地写出更好、更简洁、更优雅的程序。","史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现...(展开全部)




史蒂夫 · 麦康奈尔（Steve McConnell）与《代码大全》的故事 • 1985年，惠特曼文理学院获得哲学和计算机双学位。1991年，西雅图大学获得计算机硕士学位 • 1993年，4年累计3500小时的投入，《代码大全1》完工，出版发行后，迅速成为热点，并于当年 斩获《软件开发》杂志震撼图书大奖。此后十年，累计重印30多次，被翻译为10多种语言 • 1996年，成立Construx软件公司。此后二十多年，长期入围西雅图地区“小而美最佳雇主”名单 • 1998年，与Linux创始人林纳斯和比尔盖茨齐名，被《软件开发》杂志推选为最有影响力的三大人物 • 2004年，经过1000多个小时的全面修订，《代码大全2》出版发行。到目前为止，累计重印40多次，被翻译为30多种语言 关于作者本人，史蒂夫·麦康奈尔（Steve McConnell） • 百万现象级科技类图书缔造者 • 会做（编程）又会教的一线程序员 • 《软件开发》杂志震撼图书大奖（两次） • 《软件开发》杂志生产力大奖（两次） •   西雅图大学杰出校友奖 • 《普吉特海湾商业期刊》40 UNDER 40杰出青年奖 •  波音和微软等公司顾问 •  ACM（计算机学会）金牌核心奖章得主 •  IEEE Software杂志主编 •  惠特曼文理学院优秀毕业生，PBK会员","第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界　003
        第2章　通过隐喻更充分地理解软件开发　009
        第3章　谋定而后动：前期准备　023
        第4章　关键的构建决策　057
        第II部分高质量的代码
        第5章　软件构建的设计　069
        第6章　可以工作的类　121
        第7章　高质量的子程序　157
        第8章　防御式编程　187
        第9章　伪代码编程过程　215
        第Ⅲ部分变量
        第10章　变量使用中的常规问题　239
        第11章　变量名称的威力　263
        第12章　基本数据类型　295
        第13章　不常见的数据类型　323
        第Ⅳ部分语句
        第14章　直线型代码的组织　353
        第15章　使用条件语句　361
        第16章　控制循环　373
        第17章　不常见的控制结构　395
        第18章　表驱动法　417
        第19章　常规控制问题　437
        第Ⅴ部分代码改进
        第20章　软件质量概述　469
        第21章　协同构建　483
        第22章　开发人员测试　503
        第23章　调试　541
        第24章　重构　569
        第25章　代码调优策略　591
        第26章　代码调优技术　613
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响　651
        第28章　管理构建　663
        第29章　集成　693
        第30章　编程工具　715
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格　733
        第32章　自文档代码　781
        第33章　个人性格　821
        第34章　关于软件匠艺　837
        第35章　更多信息来源　853
        详细目录
        第Ⅰ部分奠定基础
        第1章　欢迎来到软件构建的世界	003
        1.1什么是软件构建	003
        1.2软件构建为何如此重要	006
        1.3如何阅读本书	008
        第2章　通过隐喻更充分地
        理解软件开发	009
        2.1隐喻的重要性	009
        2.2如何使用软件隐喻	012
        2.3常见的软件隐喻	013
        第3章　谋定而后动：前期准备	023
        3.1前期准备的重要性	024
        3.2确定要开发什么类型的软件	030
        3.3定义问题的先决条件	034
        3.4需求的先决条件	036
        3.5架构的先决条件	041
        3.6前期准备所花费的时间	052
        第4章　关键的构建决策	057
        4.1编程语言的选择	057
        4.2编程约定	062
        4.3判断个人处于技术浪潮中的哪个阶段	062
        4.4选择重要的构建实践	065
        第II部分高质量的代码
        第5章　软件构建的设计	069
        5.1设计挑战	070
        5.2关键设计概念	073
        5.3设计构建基块：启发式方法	083
        5.4设计实践	107
        5.5点评各种流行的方法论	115
        第6章　可以工作的类	121
        6.1类的基础：抽象数据类型(ADT)	122
        6.2良好的类接口	129
        6.3设计和实现问题	139
        6.4创建类的理由	149
        6.5语言特定问题	153
        6.6超越类：包	153
        第7章　高质量的子程序	157
        7.1创建子程序的正当理由	160
        7.2子程序级别的设计	165
        7.3好的子程序名称	169
        7.4一个子程序应该有多长	171
        7.5如何使用子程序参数	173
        7.6函数使用中的特别注意事项	180
        7.7宏子程序和内联子程序	182
        第8章　防御式编程	187
        8.1保护程序，
        使其免受无效输入的影响	188
        8.2断言	189
        8.3错误处理技术	194
        8.4异常	198
        8.5隔离程序，使之包容
        由错误造成的损害	203
        8.6调试辅助代码	205
        8.7确定在生产代码中
        保留多少防御式代码	209
        8.8对防御式编程采取防御的姿态	211
        第9章　伪代码编程过程	215
        9.1类和子程序构建步骤总结	215
        9.2面向专家的伪代码	218
        9.3使用PPP构建子程序	220
        9.4PPP的替代方案	233
        第Ⅲ部分变量
        第10章　变量使用中的常规问题	239
        10.1数据扫盲	240
        10.2简化变量声明	241
        10.3变量初始化指南	242
        10.4作用域	247
        10.5持久性	254
        10.6绑定时间	255
        10.7数据类型和控制结构之间的关系	257
        10.8每个变量只有一个用途	258
        第11章　变量名称的威力	263
        11.1选择好名称的注意事项	263
        11.2特定数据类型的命名	269
        11.3命名规范的威力	275
        11.4非正式的命名规范	276
        11.5前缀的标准化	283
        11.6创建可读的短名称	286
        11.7变量名称避坑指南	289
        第12章　基本数据类型	295
        12.1一般的数字	296
        12.2整型	297
        12.3浮点型	299
        12.4字符和字符串	302
        12.5布尔变量	305
        12.6枚举类型	307
        12.7具名常量	312
        12.8数组	314
        12.9创建自定义类型(类型别名)	316
        第13章　不常见的数据类型	323
        13.1结构体	323
        13.2指针	327
        13.3全局数据	340
        第Ⅳ部分语句
        第14章　直线型代码的组织	353
        14.1顺序攸关的语句	353
        14.2顺序无关的语句	356
        第15章　使用条件语句	361
        15.1if语句	361
        15.2case语句	367
        第16章　控制循环	373
        16.1选择循环类型	373
        16.2控制循环	379
        16.3轻松创建循环：由内而外 	391
        16.4循环和数组的对应关系	393
        第17章　不常见的控制结构	395
        17.1子程序中的多个返回点	395
        17.2递归	397
        17.3goto语句	402
        17.4众说纷纭，谈谈不常见的控制结构	413
        第18章　表驱动法	417
        18.1表驱动法使用总则	417
        18.2直接访问表	419
        18.3索引访问表	431
        18.4阶梯访问表	433
        18.5表查询的其他示例	436
        第19章　常规控制问题	437
        19.1布尔表达式	437
        19.2复合语句(语句块)	448
        19.3空语句	449
        19.4驾驭深层嵌套	451
        19.5编程基础：结构化编程	460
        19.6控制结构与复杂度	462
        第Ⅴ部分代码改进
        第20章　软件质量概述	469
        20.1软件质量的特性	469
        20.2改进软件质量的技术	472
        20.3质量保证技术的相对效能	475
        20.4何时进行质量保证	479
        20.5软件质量的普遍原理	479
        第21章　协同构建	483
        21.1协同开发实践概述	484
        21.2结对编程	487
        21.3正式审查	489
        21.4其他类型的协同开发实践	496
        第22章　开发人员测试	503
        22.1开发者测试
        对软件质量所起的作用	504
        22.2开发人员测试的推荐方法	507
        22.3一些测试技巧	509
        22.4典型错误 	522
        22.5测试支持工具	528
        22.6改进测试	534
        22.7维护测试记录 	535
        第23章　调试	541
        23.1调试问题概述	541
        23.2发现缺陷	546
        23.3修复缺陷	557
        23.4调试中的心理因素	560
        23.5那些显而易见和
        不太明显的调试工具	563
        第24章　重构	569
        24.1软件演变的类型	570
        24.2重构简介	571
        24.3特定的重构	577
        24.4安全重构	585
        24.5重构策略	587
        第25章　代码调优策略	591
        25.1性能概述	592
        25.2代码调优简介	595
        25.3各式各样的臃肿和蜜糖	601
        25.4度量	607
        25.5迭代	608
        25.6代码调优方法总结	609
        第26章　代码调优技术	613
        26.1逻辑	614
        26.2循环	619
        26.3数据变换	628
        26.4表达式	633
        26.5子程序	642
        26.6用低级语言重新编码	643
        26.7改得越多，越不会有大的改观	646
        第Ⅵ部分系统化考虑
        第27章　程序规模对构建的影响	651
        27.1沟通和规模	651
        27.2项目规模的范围	652
        27.3项目规模对错误的影响	653
        27.4项目规模对生产力的影响	655
        27.5项目规模对开发活动的影响	656
        第28章　管理构建	663
        28.1鼓励良好的编码实践	664
        28.2配置管理	666
        28.3评估构建进度表	673
        28.4度量	679
        28.5以人为本，善待每一位程序员	683
        28.6向上管理	689
        第29章　集成	693
        29.1集成方法的重要性	693
        29.2集成的频率，阶段式还是增量式	695
        29.3增量式集成策略	698
        29.4每日构建和冒烟测试	707
        第30章　编程工具	715
        30.1设计工具	716
        30.2源代码工具	716
        30.3可执行码工具	721
        30.4面向工具的环境	726
        30.5自己动手写编程工具	726
        30.6工具的幻境	728
        第Ⅶ部分软件匠艺
        第31章　代码的布局和风格	733
        31.1基本理论	734
        31.2布局技术	741
        31.3布局风格	743
        31.4控制结构的布局	750
        31.5单条语句的布局	757
        31.6注释的布局	768
        31.7子程序的布局	771
        31.8类的布局	772
        第32章　自文档代码	781
        32.1外部文档	781
        32.2编程风格即文档	782
        32.3注释，还是不注释	785
        32.4高效注释的关键	788
        32.5注释的技术	795
        32.6IEEE标准	815
        第33章　个人性格	821
        33.1个人性格与本书主题有关	822
        33.2聪明与谦卑	823
        33.3好奇心	824
        33.4理性诚实	827
        33.5沟通与合作	830
        33.6创造力与规范	830
        33.7懒惰	831
        33.8没有想象中那么重要的性格因素	832
        33.9习惯	833
        第34章　关于软件匠艺	837
        34.1征服复杂性	837
        34.2优选开发过程	839
        34.3编写程序时，先考虑人，
        再考虑机器	840
        34.4深入语言去编程，
        而不是用语言来编程	842
        34.5借助于规范来保持专注	843
        34.6面向问题域编程	844
        34.7 当心落石	846
        34.8迭代，迭代，迭代，
        重要的事情说三遍	848
        34.9警惕编程中的执念	849
        试验	851
        第35章　更多信息来源	853
        35.1与软件构建相关的信息	853
        35.2软件构建之外的话题	854
        35.3出版物	856
        35.4软件开发者的阅读计划	857
        35.5加入专业组织	859
        参考文献	861
     · · · · · ·     (收起)"
35520512,深入浅出Pandas,8.6,(97人评价),李庆辉 / 机械工业出版社 / 2021-7-10 / 99.00,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。
这是一本全面覆盖了Pandas使用者的普遍需求和...",https://book.douban.com/subject/35520512/,https://img9.doubanio.com/view/subject/s/public/s33944495.jpg,99.00,9787111685456,"如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 ...(展开全部)





如果你想充分发挥Python的强大作用，如果你想成为一名好的Python工程师，你应该先学好Pandas。 这是一本全面覆盖了Pandas使用者的普遍需求和痛点的著作，基于实用、易学的原则，从功能、使用、原理等多个维度对Pandas做了全方位的详细讲解，既是初学者系统学习Pandas难得的入门书，又是有经验的Python工程师案头必不可少的查询手册。 本书共17章，分为七部分。 第1部分（第1～2章） Pandas入门 首先介绍了Pandas的功能、使用场景和学习方法，然后详细讲解了Python开发环境的搭建，Z后介绍了Pandas的大量基础功能，旨在引领读者快速入门。 第二部分（第3～5章） Pandas数据分析基础 详细讲解了Pandas读取与输出数据、索引操作、数据类型转换、查询筛选、统计计算、排序、位移、数据修改、数据迭代、函数应用等内容。 第三部分（第6～9章） 数据形式变化 讲解了Pandas的分组聚合操作、合并操作、对比操作、数据透视、转置、归一化、标准化等，以及如何利用多层索引对数据进行升降维。 第四部分（第10～12章） 数据清洗 讲解了缺失值和重复值的识别、删除、填充，数据的替换、格式转换，文本的提取、连接、匹配、切分、替换、格式化、虚拟变量化等，以及分类数据的应用场景和操作方法。 第五部分（第13～14章）时序数据分析 讲解了Pandas中对于各种时间类型数据的处理和分析，以及在时序数据处理中经常使用的窗口计算。 第六部分（第15～16章） 可视化 讲解了Pandas的样式功能如何让数据表格更有表现力，以及Pandas的绘图功能如何让数据自己说话。 第七部分（第17章） 实战案例 介绍了从需求到代码的思考过程，如何利用链式编程思想提高代码编写和数据分析效率，以及数据分析的基本方法与需要掌握的数据分析工具和技术栈，此外还从数据处理和数据分析两个角度给出了大量的应用案例及代码详解。",李庆辉，数据产品专家，某电商公司数据产品团队负责人，擅长通过数据治理、数据分析、数据化运营提升公司的数据应用水平。 精通 Python 数据科学及 Python Web 开发，曾独立开发公司的自动化数据分析平台，参与教育部“1+X”数据分析（Python）职业技能等级标准评审。 中国人工智能学会会员，企业数字化、数据产品和数据分析讲师，在个人网站“盖若”上编写的技术和产品教程广受欢迎。,"前言
        第一部分 Pandas入门
        第1章 Pandas简介及快速入门2
        1.1 Pandas是什么2
        1.1.1 Python简介2
        1.1.2 Python的应用3
        1.1.3 为什么不选择R4
        1.1.4 Pandas简介4
        1.1.5 Pandas的使用人群5
        1.1.6 Pandas的基本功能5
        1.1.7 Pandas的学习方法6
        1.1.8 小结6
        1.2 环境搭建及安装6
        1.2.1 Python环境安装7
        1.2.2 Anaconda简介7
        1.2.3 安装miniconda8
        1.2.4 多Python版本环境9
        1.2.5 安装编辑器10
        1.2.6 Jupyter Notebook10
        1.2.7 用pip安装三方库11
        1.2.8 安装Jupyter Notebook12
        1.2.9 启动Jupyter Notebook12
        1.2.10 使用Jupyter Notebook13
        1.2.11 安装Pandas14
        1.2.12 小结14
        1.3 Pandas快速入门14
        1.3.1 安装导入14
        1.3.2 准备数据集15
        1.3.3 读取数据15
        1.3.4 查看数据16
        1.3.5 验证数据17
        1.3.6 建立索引17
        1.3.7 数据选取18
        1.3.8 排序19
        1.3.9 分组聚合19
        1.3.10 数据转换20
        1.3.11 增加列21
        1.3.12 统计分析21
        1.3.13 绘图21
        1.3.14 导出24
        1.3.15 小结24
        1.4 本章小结24
        第2章 数据结构25
        2.1 数据结构概述25
        2.1.1 什么是数据25
        2.1.2 什么是数据结构26
        2.1.3 小结26
        2.2 Python的数据结构26
        2.2.1 数字27
        2.2.2 字符串27
        2.2.3 布尔型28
        2.2.4 列表29
        2.2.5 元组30
        2.2.6 字典30
        2.2.7 集合31
        2.2.8 小结32
        2.3 NumPy32
        2.3.1 NumPy简介33
        2.3.2 数据结构33
        2.3.3 创建数据34
        2.3.4 数据类型34
        2.3.5 数组信息35
        2.3.6 统计计算35
        2.3.7 小结35
        2.4 Pandas的数据结构35
        2.4.1 Series36
        2.4.2 DataFrame36
        2.4.3 索引37
        2.4.4 小结38
        2.5 Pandas生成数据38
        2.5.1 导入Pandas38
        2.5.2 创建数据38
        2.5.3 生成Series40
        2.5.4 生成DataFrame41
        2.5.5 小结43
        2.6 Pandas的数据类型43
        2.6.1 数据类型查看43
        2.6.2 常见数据类型44
        2.6.3 数据检测44
        2.6.4 小结45
        2.7 本章小结45
        第二部分 Pandas数据分析基础
        第3章 Pandas数据读取与输出48
        3.1 数据读取48
        3.1.1 CSV文件49
        3.1.2 Excel49
        3.1.3 JSON 50
        3.1.4 HTML50
        3.1.5 剪贴板51
        3.1.6 SQL51
        3.1.7 小结52
        3.2 读取CSV52
        3.2.1 语法52
        3.2.2 数据内容53
        3.2.3 分隔符53
        3.2.4 表头54
        3.2.5 列名54
        3.2.6 索引54
        3.2.7 使用部分列54
        3.2.8 返回序列55
        3.2.9 表头前缀55
        3.2.10 处理重复列名55
        3.2.11 数据类型55
        3.2.12 引擎55
        3.2.13 列数据处理56
        3.2.14 真假值转换56
        3.2.15 跳过指定行56
        3.2.16 读取指定行57
        3.2.17 空值替换57
        3.2.18 保留默认空值57
        3.2.19 日期时间解析58
        3.2.20 文件处理59
        3.2.21 符号60
        3.2.22 小结61
        3.3 读取Excel61
        3.3.1 语法61
        3.3.2 文件内容62
        3.3.3 表格62
        3.3.4 表头62
        3.3.5 列名62
        3.3.6 其他62
        3.3.7 小结63
        3.4 数据输出63
        3.4.1 CSV63
        3.4.2 Excel63
        3.4.3 HTML64
        3.4.4 数据库（SQL）64
        3.4.5 Markdown65
        3.4.6 小结65
        3.5 本章小结65
        第4章 Pandas基础操作66
        4.1 索引操作66
        4.1.1 认识索引66
        4.1.2 建立索引67
        4.1.3 重置索引68
        4.1.4 索引类型68
        4.1.5 索引对象69
        4.1.6 索引的属性70
        4.1.7 索引的操作70
        4.1.8 索引重命名72
        4.1.9 修改索引内容72
        4.1.10 小结73
        4.2 数据的信息73
        4.2.1 查看样本73
        4.2.2 数据形状74
        4.2.3 基础信息74
        4.2.4 数据类型74
        4.2.5 行列索引内容75
        4.2.6 其他信息75
        4.2.7 小结75
        4.3 统计计算76
        4.3.1 描述统计76
        4.3.2 数学统计77
        4.3.3 统计函数78
        4.3.4 非统计计算79
        4.3.5 小结80
        4.4 位置计算80
        4.4.1 位置差值diff()80
        4.4.2 位置移动shift()81
        4.4.3 位置序号rank()81
        4.4.4 小结82
        4.5 数据选择82
        4.5.1 选择列83
        4.5.2 切片[]83
        4.5.3 按轴标签.loc84
        4.5.4 按数字索引.iloc86
        4.5.5 取具体值.at/.iat86
        4.5.6 获取数据.get86
        4.5.7 数据截取.truncate87
        4.5.8 索引选择器87
        4.5.9 小结87
        4.6 本章小结88
        第5章 Pandas高级操作89
        5.1 复杂查询89
        5.1.1 逻辑运算89
        5.1.2 逻辑筛选数据91
        5.1.3 函数筛选92
        5.1.4 比较函数92
        5.1.5 查询df.query()93
        5.1.6 筛选df.filter()93
        5.1.7 按数据类型查询93
        5.1.8 小结94
        5.2 数据类型转换94
        5.2.1 推断类型94
        5.2.2 指定类型95
        5.2.3 类型转换astype()95
        5.2.4 转为时间类型96
        5.2.5 小结96
        5.3 数据排序96
        5.3.1 索引排序97
        5.3.2 数值排序98
        5.3.3 混合排序100
        5.3.4 按值大小排序101
        5.3.5 小结101
        5.4 添加修改101
        5.4.1 修改数值101
        5.4.2 替换数据103
        5.4.3 填充空值103
        5.4.4 修改索引名104
        5.4.5 增加列104
        5.4.6 插入列df.insert()105
        5.4.7 指定列df.assign()106
        5.4.8 执行表达式df.eval()108
        5.4.9 增加行109
        5.4.10 追加合并109
        5.4.11 删除110
        5.4.12 删除空值111
        5.4.13 小结111
        5.5 高级过滤111
        5.5.1 df.where()111
        5.5.2 np.where()113
        5.5.3 df.mask()115
        5.5.4 df.lookup()116
        5.5.5 小结116
        5.6 数据迭代116
        5.6.1 迭代Series116
        5.6.2 df.iterrows()117
        5.6.3 df.itertuples()117
        5.6.4 df.items()118
        5.6.5 按列迭代119
        5.6.6 小结119
        5.7 函数应用120
        5.7.1 pipe()120
        5.7.2 apply()121
        5.7.3 applymap()123
        5.7.4 map()124
        5.7.5 agg()124
        5.7.6 transform()125
        5.7.7 copy()126
        5.7.8 小结126
        5.8 本章小结126
        第三部分 数据形式变化
        第6章 Pandas分组聚合128
        6.1 概述128
        6.1.1 原理128
        6.1.2 groupby语法129
        6.1.3 DataFrame应用分组130
        6.1.4 Series应用分组131
        6.1.5 小结131
        6.2 分组131
        6.2.1 分组对象131
        6.2.2 按标签分组132
        6.2.3 表达式132
        6.2.4 函数分组133
        6.2.5 多种方法混合134
        6.2.6 用pipe调用分组方法134
        6.2.7 分组器Grouper135
        6.2.8 索引136
        6.2.9 排序136
        6.2.10 小结136
        6.3 分组对象的操作136
        6.3.1 选择分组137
        6.3.2 迭代分组138
        6.3.3 选择列139
        6.3.4 应用函数apply()139
        6.3.5 管道方法pipe()142
        6.3.6 转换方法transform()142
        6.3.7 筛选方法filter()144
        6.3.8 其他功能145
        6.3.9 小结146
        6.4 聚合统计146
        6.4.1 描述统计146
        6.4.2 统计函数147
        6.4.3 聚合方法agg()147
        6.4.4 时序重采样方法resample()149
        6.4.5 组内头尾值150
        6.4.6 组内分位数150
        6.4.7 组内差值151
        6.4.8 小结151
        6.5 数据分箱151
        6.5.1 定界分箱pd.cut()152
        6.5.2 等宽分箱pd.qcut()152
        6.5.3 小结154
        6.6 分组可视化154
        6.6.1 绘图方法plot()154
        6.6.2 直方图hist()155
        6.6.3 箱线图boxplot()156
        6.6.4 小结157
        6.7 本章小结158
        第7章 Pandas数据合并与对比159
        7.1 数据追加df.append159
        7.1.1 基本语法159
        7.1.2 相同结构160
        7.1.3 不同结构161
        7.1.4 忽略索引161
        7.1.5 重复内容162
        7.1.6 追加序列162
        7.1.7 追加字典163
        7.1.8 小结163
        7.2 数据连接pd.concat163
        7.2.1 基本语法163
        7.2.2 简单连接164
        7.2.3 按列连接164
        7.2.4 合并交集165
        7.2.5 与序列合并165
        7.2.6 指定索引166
        7.2.7 多文件合并166
        7.2.8 目录文件合并167
        7.2.9 小结167
        7.3 数据合并pd.merge167
        7.3.1 基本语法168
        7.3.2 连接键168
        7.3.3 索引连接169
        7.3.4 多连接键169
        7.3.5 连接方法170
        7.3.6 连接指示170
        7.3.7 小结171
        7.4 按元素合并171
        7.4.1 df.combine_first()171
        7.4.2 df.combine()172
        7.4.3 df.update()173
        7.4.4 小结173
        7.5 数据对比df.compare173
        7.5.1 简单对比174
        7.5.2 对齐方式174
        7.5.3 显示相同值174
        7.5.4 保持形状175
        7.5.5 小结175
        7.6 本章小结175
        第8章 Pandas多层索引177
        8.1 概述177
        8.1.1 什么是多层索引177
        8.1.2 通过分组产生多层索引178
        8.1.3 由序列创建多层索引179
        8.1.4 由元组创建多层索引179
        8.1.5 可迭代对象的笛卡儿积180
        8.1.6 将DataFrame转为多层索引对象180
        8.1.7 小结180
        8.2 多层索引操作181
        8.2.1 生成数据181
        8.2.2 索引信息181
        8.2.3 查看层级182
        8.2.4 索引内容182
        8.2.5 排序183
        8.2.6 其他操作183
        8.2.7 小结183
        8.3 数据查询183
        8.3.1 查询行183
        8.3.2 查询列184
        8.3.3 行列查询185
        8.3.4 条件查询185
        8.3.5 用pd.IndexSlice索引数据186
        8.3.6 df.xs()186
        8.3.7 小结186
        8.4 本章小结186
        第9章 Pandas数据重塑与透视187
        9.1 数据透视187
        9.1.1 整理透视187
        9.1.2 整理透视操作188
        9.1.3 聚合透视189
        9.1.4 聚合透视操作190
        9.1.5 聚合透视高级操作191
        9.1.6 小结192
        9.2 数据堆叠192
        9.2.1 理解堆叠193
        9.2.2 堆叠操作df.stack()194
        9.2.3 解堆操作df.unstack()195
        9.2.4 小结195
        9.3 交叉表195
        9.3.1 基本语法196
        9.3.2 生成交叉表196
        9.3.3 归一化197
        9.3.4 指定聚合方法198
        9.3.5 汇总198
        9.3.6 小结199
        9.4 数据转置df.T199
        9.4.1 理解转置199
        9.4.2 转置操作200
        9.4.3 类型变化200
        9.4.4 轴交换df.swapaxes()201
        9.4.5 小结201
        9.5 数据融合201
        9.5.1 基本语法201
        9.5.2 融合操作202
        9.5.3 标识和值203
        9.5.4 指定名称204
        9.5.5 小结204
        9.6 虚拟变量204
        9.6.1 语法结构204
        9.6.2 生成虚拟变量205
        9.6.3 列前缀205
        9.6.4 从DataFrame生成206
        9.6.5 小结207
        9.7 因子化207
        9.7.1 基本方法207
        9.7.2 排序208
        9.7.3 缺失值208
        9.7.4 枚举类型208
        9.7.5 小结208
        9.8 爆炸列表208
        9.8.1 基本功能209
        9.8.2 DataFrame的爆炸209
        9.8.3 非列表格式210
        9.8.4 小结210
        9.9 本章小结210
        第四部分 数据清洗
        第10章 Pandas数据清洗212
        10.1 缺失值的认定212
        10.1.1 缺失值类型212
        10.1.2 缺失值判断213
        10.1.3 缺失值统计214
        10.1.4 缺失值筛选214
        10.1.5 NA标量215
        10.1.6 时间数据中的缺失值216
        10.1.7 整型数据中的缺失值216
        10.1.8 插入缺失值217
        10.1.9 小结217
        10.2 缺失值的操作217
        10.2.1 缺失值填充217
        10.2.2 插值填充219
        10.2.3 缺失值删除220
        10.2.4 缺失值参与计算221
        10.2.5 小结223
        10.3 数据替换223
        10.3.1 指定值替换223
        10.3.2 使用替换方式223
        10.3.3 字符替换223
        10.3.4 缺失值替换224
        10.3.5 数字替换224
        10.3.6 数据修剪225
        10.3.7 小结226
        10.4 重复值及删除数据226
        10.4.1 重复值识别226
        10.4.2 删除重复值228
        10.4.3 删除数据229
        10.4.4 小结229
        10.5 NumPy格式转换230
        10.5.1 转换方法230
        10.5.2 DataFrame转为ndarray230
        10.5.3 Series转为ndarray231
        10.5.4 df.to_records()231
        10.5.5 np.array读取231
        10.5.6 小结232
        10.6 本章小结232
        第11章 Pandas文本处理233
        11.1 数据类型233
        11.1.1 文本数据类型233
        11.1.2 类型转换234
        11.1.3 类型异同234
        11.1.4 小结235
        11.2 字符的操作235
        11.2.1 .str访问器235
        11.2.2 文本格式236
        11.2.3 文本对齐236
        11.2.4 计数和编码236
        11.2.5 格式判定237
        11.2.6 小结237
        11.3 文本高级处理237
        11.3.1 文本分隔237
        11.3.2 字符分隔展开238
        11.3.3 文本切片选择239
        11.3.4 文本划分240
        11.3.5 文本替换241
        11.3.6 指定替换241
        11.3.7 重复替换242
        11.3.8 文本连接243
        11.3.9 文本查询244
        11.3.10 文本包含245
        11.3.11 文本提取246
        11.3.12 提取虚拟变量247
        11.3.13 小结248
        11.4 本章小结248
        第12章 Pandas分类数据249
        12.1 分类数据249
        12.1.1 创建分类数据249
        12.1.2 pd.Categorical()251
        12.1.3 CategoricalDtype对象251
        12.1.4 类型转换252
        12.1.5 小结253
        12.2 分类的操作253
        12.2.1 修改分类253
        12.2.2 追加新分类254
        12.2.3 删除分类254
        12.2.4 顺序255
        12.2.5 小结256
        12.3 本章小结256
        第五部分 时序数据分析
        第13章 Pandas窗口计算258
        13.1 窗口计算258
        13.1.1 理解窗口计算258
        13.1.2 移动窗口259
        13.1.3 扩展窗口259
        13.1.4 指数加权移动260
        13.1.5 小结260
        13.2 窗口操作260
        13.2.1 计算方法260
        13.2.2 基本语法261
        13.2.3 移动窗口使用262
        13.2.4 统计方法263
        13.2.5 agg()264
        13.2.6 apply()264
        13.2.7 扩展窗口265
        13.2.8 小结266
        13.3 本章小结266
        第14章 Pandas时序数据267
        14.1 固定时间267
        14.1.1 时间的表示267
        14.1.2 创建时间点268
        14.1.3 时间的属性269
        14.1.4 时间的方法270
        14.1.5 时间缺失值271
        14.1.6 小结272
        14.2 时长数据272
        14.2.1 创建时间差272
        14.2.2 时长的加减274
        14.2.3 时长的属性275
        14.2.4 时长索引275
        14.2.5 小结275
        14.3 时间序列275
        14.3.1 时序索引275
        14.3.2 创建时序数据276
        14.3.3 数据访问277
        14.3.4 类型转换279
        14.3.5 按格式转换281
        14.3.6 时间访问器.dt282
        14.3.7 时长数据访问器284
        14.3.8 时序数据移动284
        14.3.9 频率转换285
        14.3.10 小结286
        14.4 时间偏移286
        14.4.1 DateOffset对象286
        14.4.2 偏移别名287
        14.4.3 移动偏移289
        14.4.4 应用偏移289
        14.4.5 偏移参数290
        14.4.6 相关查询290
        14.4.7 与时序的计算291
        14.4.8 锚定偏移292
        14.4.9 自定义工作时间294
        14.4.10 小结296
        14.5 时间段297
        14.5.1 Period对象297
        14.5.2 属性方法297
        14.5.3 时间段的计算298
        14.5.4 时间段索引299
        14.5.5 数据查询300
        14.5.6 相关类型转换301
        14.5.7 小结302
        14.6 时间操作302
        14.6.1 时区转换302
        14.6.2 时间的格式化303
        14.6.3 时间重采样304
        14.6.4 上采样306
        14.6.5 重采样聚合307
        14.6.6 时间类型间转换307
        14.6.7 超出时间戳范围时间308
        14.6.8 区间间隔309
        14.6.9 小结311
        14.7 本章小结312
        第六部分 可视化
        第15章 Pandas样式314
        15.1 内置样式314
        15.1.1 样式功能314
        15.1.2 Styler对象315
        15.1.3 空值高亮315
        15.1.4 极值高亮316
        15.1.5 背景渐变317
        15.1.6 条形图318
        15.1.7 小结320
        15.2 显示格式320
        15.2.1 语法结构320
        15.2.2 常用方法320
        15.2.3 综合运用321
        15.2.4 小结321
        15.3 样式高级操作322
        15.3.1 样式配置操作322
        15.3.2 表格CSS样式323
        15.3.3 应用函数324
        15.3.4 样式复用325
        15.3.5 样式清除325
        15.3.6 导出Excel326
        15.3.7 生成HTML326
        15.3.8 小结327
        15.4 本章小结327
        第16章 Pandas可视化328
        16.1 plot()方法328
        16.1.1 plot()概述328
        16.1.2 plot()基础方法329
        16.1.3 图形类型331
        16.1.4 x轴和y轴331
        16.1.5 图形标题332
        16.1.6 字体大小332
        16.1.7 线条样式333
        16.1.8 背景辅助线334
        16.1.9 图例334
        16.1.10 图形大小334
        16.1.11 色系335
        16.1.12 绘图引擎336
        16.1.13 Matplotlib的其他参数337
        16.1.14 图形叠加337
        16.1.15 颜色的表示337
        16.1.16 解决图形中的中文乱码问题338
        16.1.17 小结340
        16.2 常用可视化图形340
        16.2.1 折线图plot.line340
        16.2.2 饼图plot.pie342
        16.2.3 柱状图plot.bar345
        16.2.4 直方图plot.hist348
        16.2.5 箱形图plot.box351
        16.2.6 面积图plot.area353
        16.2.7 散点图plot.scatter354
        16.2.8 六边形分箱图plot.hexbin356
        16.2.9 小结357
        16.3 本章小结357
        第七部分 实战案例
        第17章 Pandas实战案例360
        17.1 实战思想360
        17.1.1 链式方法360
        17.1.2 代码思路362
        17.1.3 分析方法366
        17.1.4 分析流程368
        17.1.5 分析工具368
        17.1.6 小结369
        17.2 数据处理案例370
        17.2.1 剧组表格道具370
        17.2.2 当月最后一个星期三371
        17.2.3 同组数据转为同一行372
        17.2.4 相关性最强的两个变量373
        17.2.5 全表最大值的位置375
        17.2.6 编写年会抽奖程序376
        17.2.7 北京各区无新增新冠肺炎确诊病例天数377
        17.2.8 生成SQL378
        17.2.9 圣诞节的星期分布379
        17.2.10 试验三天中恰有两天下雨的概率381
        17.2.11 计算平均打卡上班时间382
        17.2.12 小结383
        17.3 综合案例383
        17.3.1 中国经济发展分析383
        17.3.2 新冠肺炎疫情分析387
        17.3.3 利用爬虫获取房价390
        17.3.4 全国城市房价分析392
        17.3.5 客服对话文本分析396
        17.3.6 RFM用户分层399
        17.3.7 自动邮件报表404
        17.3.8 鸢尾花品种预测407
        17.3.9 小结410
        17.4 本章小结410
     · · · · · ·     (收起)"
35768338,Vue.js设计与实现,9.6,(197人评价),霍春阳 / 人民邮电出版社 / 2022-2-10 / 119.8,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章...,https://book.douban.com/subject/35768338/,https://img9.doubanio.com/view/subject/s/public/s34120804.jpg,119.8,9787115583864,本书基于Vue.js 3，从规范出发，以源码为基础，并结合大量直观的配图，循序渐进地讲解Vue.js中各个功能模块的实现，细致剖析框架设计原理。全书共18章，分为六篇，主要内容包括：框架设计概览、响应系统、渲染器、组件化、编译器和服务端渲染等。通过阅读本书，对Vue.js 2/3具有上手经验的开发人员能够进一步理解Vue.js框架的实现细节，没有Vue.js使用经验但对框架设计感兴趣的前端开发人员，能够快速掌握Vue.js的设计原理。,霍春阳（HcySunYang） Vue.js官方团队成员，专注于Web研发领域，是Vue.js 3的核心贡献者之一，Vue.js文档生成工具Vuese的作者，技术社区活跃者，曾撰写大量颇受好评的技术博客。,"序
        前言
        第　1章 权衡的艺术　2
        1．1　命令式和声明式　2
        1．2　性能与可维护性的权衡　3
        1．3　虚拟DOM的性能到底如何　4
        1．4　运行时和编译时　8
        1．5　总结　11
        第　2章 框架设计的核心要素　12
        2．1　提升用户的开发体验　12
        2．2　控制框架代码的体积　14
        2．3　框架要做到良好的Tree-Shaking　15
        2．4　框架应该输出怎样的构建产物　17
        2．5　特性开关　19
        2．6　错误处理　21
        2．7　良好的TypeScript类型支持　23
        2．8　总结　25
        第3章　Vue．js 3的设计思路　27
        3．1　声明式地描述UI　27
        3．2　初识渲染器　29
        3．3　组件的本质　32
        3．4　模板的工作原理　34
        3．5　Vue．js是各个模块组成的有机整体　36
        3．6　总结　37
        第4章　响应系统的作用与实现　40
        4．1　响应式数据与副作用函数　40
        4．2　响应式数据的基本实现　41
        4．3　设计一个完善的响应系统　43
        4．4　分支切换与cleanup　50
        4．5　嵌套的effect与effect栈　55
        4．6　避免无限递归循环　59
        4．7　调度执行　60
        4．8　计算属性computed与lazy　64
        4．9　watch的实现原理　71
        4．10　立即执行的watch与回调执行时机　75
        4．11　过期的副作用　77
        4．12　总结　82
        第5章　非原始值的响应式方案　84
        5．1　理解Proxy和Reflect　84
        5．2　JavaScript对象及Proxy的工作原理　88
        5．3　如何代理Object　92
        5．4　合理地触发响应　102
        5．5　浅响应与深响应　108
        5．6　只读和浅只读　110
        5．7　代理数组　113
        5．7．1　数组的索引与 length　114
        5．7．2　遍历数组　119
        5．7．3　数组的查找方法　124
        5．7．4　隐式修改数组长度的原型方法　129
        5．8　代理Set和Map　132
        5．8．1　如何代理Set和Map　133
        5．8．2　建立响应联系　137
        5．8．3　避免污染原始数据　140
        5．8．4　处理forEach　143
        5．8．5　迭代器方法　147
        5．8．6　values与keys方法　152
        5．9　总结　155
        第6章　原始值的响应式方案　158
        6．1　引入ref的概念　158
        6．2　响应丢失问题　160
        6．3　自动脱ref　164
        6．4　总结　166
        第7章　渲染器的设计　170
        7．1　渲染器与响应系统的结合　170
        7．2　渲染器的基本概念　172
        7．3　自定义渲染器　175
        7．4　总结　179
        第8章　挂载与更新　180
        8．1　挂载子节点和元素的属性　180
        8．2　HTML Attributes与DOM Properties　182
        8．3　正确地设置元素属性　184
        8．4　class的处理　189
        8．5　卸载操作　192
        8．6　区分vnode的类型　195
        8．7　事件的处理　196
        8．8　事件冒泡与更新时机问题　201
        8．9　更新子节点　204
        8．10　文本节点和注释节点　209
        8．11　Fragment　212
        8．12　总结　215
        第9章　简单Diff算法　218
        9．1　减少DOM操作的性能开销　218
        9．2　DOM复用与key的作用　221
        9．3　找到需要移动的元素　225
        9．4　如何移动元素　228
        9．5　添加新元素　233
        9．6　移除不存在的元素　238
        9．7　总结　241
        第　10章 双端Diff算法　242
        10．1　双端比较的原理　242
        10．2　双端比较的优势　252
        10．3　非理想状况的处理方式　255
        10．4　添加新元素　263
        10．5　移除不存在的元素　268
        10．6　总结　270
        第　11章 快速Diff算法　271
        11．1　相同的前置元素和后置元素　271
        11．2　判断是否需要进行DOM移动操作　279
        11．3　如何移动元素　288
        11．4　总结　296
        第　12章 组件的实现原理　298
        12．1　渲染组件　298
        12．2　组件状态与自更新　301
        12．3　组件实例与组件的生命周期　304
        12．4　props与组件的被动更新　306
        12．5　setup函数的作用与实现　311
        12．6　组件事件与emit的实现　314
        12．7　插槽的工作原理与实现　316
        12．8　注册生命周期　318
        12．9　总结　320
        第　13章 异步组件与函数式组件　322
        13．1　异步组件要解决的问题　322
        13．2　异步组件的实现原理　324
        13．2．1　封装defineAsyncComponent函数　324
        13．2．2　超时与Error组件　325
        13．2．3　延迟与Loading组件　328
        13．2．4　重试机制　331
        13．3　函数式组件　333
        13．4　总结　335
        第　14章 内建组件和模块　337
        14．1　KeepAlive组件的实现原理　337
        14．1．1　组件的激活与失活　337
        14．1．2　include和exclude　342
        14．1．3　缓存管理　343
        14．2　Teleport组件的实现原理　346
        14．2．1　Teleport组件要解决的问题　346
        14．2．2　实现Teleport组件　347
        14．3　Transition组件的实现原理　350
        14．3．1　原生DOM的过渡　351
        14．3．2　实现Transition组件　356
        14．4　总结　360
        第　15章 编译器核心技术概览　364
        15．1　模板DSL的编译器　364
        15．2　parser的实现原理与状态机　368
        15．3　构造AST　374
        15．4　AST的转换与插件化架构　383
        15．4．1　节点的访问　383
        15．4．2　转换上下文与节点操作　387
        15．4．3　进入与退出　392
        15．5　将模板AST转为JavaScript AST　396
        15．6　代码生成　402
        15．7　总结　407
        第　16章 解析器　409
        16．1　文本模式及其对解析器的影响　409
        16．2　递归下降算法构造模板AST　413
        16．3　状态机的开启与停止　419
        16．4　解析标签节点　426
        16．5　解析属性　430
        16．6　解析文本与解码HTML实体　436
        16．6．1　解析文本　436
        16．6．2　解码命名字符引用　438
        16．6．3　解码数字字符引用　445
        16．7　解析插值与注释　449
        16．8　总结　451
        第　17章 编译优化　453
        17．1　动态节点收集与补丁标志　453
        17．1．1　传统Diff算法的问题　453
        17．1．2　Block与PatchFlags　454
        17．1．3　收集动态节点　457
        17．1．4　渲染器的运行时支持　459
        17．2　Block树　461
        17．2．1　带有v-if指令的节点　462
        17．2．2　带有v-for指令的节点　464
        17．2．3　Fragment的稳定性　465
        17．3　静态提升　466
        17．4　预字符串化　468
        17．5　缓存内联事件处理函数　469
        17．6　v-once　470
        17．7　总结　471
        第　18章 同构渲染　474
        18．1　CSR、SSR以及同构渲染　474
        18．2　将虚拟DOM渲染为HTML字符串　478
        18．3　将组件渲染为HTML字符串　484
        18．4　客户端激活的原理　489
        18．5　编写同构的代码　494
        18．5．1　组件的生命周期　494
        18．5．2　使用跨平台的API　496
        18．5．3　只在某一端引入模块　496
        18．5．4　避免交叉请求引起的状态污染　497
        18．5．5　组件　498
        18．6　总结　499
     · · · · · ·     (收起)"
33450010,动手学深度学习,9.3,(552人评价),阿斯顿·张（Aston Zhang）、李沐（Mu Li）、[美] 扎卡里·C. 立顿（Zachary C. Lipton）、[德] 亚历山大·J. 斯莫拉（Alexander J. Smola） / 人民邮电出版社 / 2019-6 / 85.00元,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的...,https://book.douban.com/subject/33450010/,https://img9.doubanio.com/view/subject/s/public/s32322795.jpg,85.00元,9787115490841,本书旨在向读者交付有关深度学习的交互式学习体验。书中不仅阐述深度学习的算法原理，还演示它们的实现和运行。与传统图书不同，本书的每一节都是一个可以下载并运行的 Jupyter记事本，它将文字、公式、图像、代码和运行结果结合在了一起。此外，读者还可以访问并参与书中内容的讨论。 全书的内容分为3个部分：第一部分介绍深度学习的背景，提供预备知识，并包括深度学习最基础的概念和技术；第二部分描述深度学习计算的重要组成部分，还解释近年来令深度学习在多个领域大获成功的卷积神经网络和循环神经网络；第三部分评价优化算法，检验影响深度学习计算性能的重要因素，并分别列举深度学习在计算机视觉和自然语言处理中的重要应用。 本书同时覆盖深度学习的方法和实践，主要面向在校大学生、技术人员和研究人员。阅读本书需要读者了解基本的Python编程或附录中描述的线性代数、微分和概率基础。,"阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、Ne...(展开全部)




阿斯顿·张（Aston Zhang） 亚马逊应用科学家，美国伊利诺伊大学香槟分校计算机科学博士，统计学和计算机科学双硕士。他专注于机器学习的研究，并在数个顶级学术会议发表过论文。他担任过NeurIPS、ICML、KDD、WWW、WSDM、SIGIR、AAAI 等学术会议的程序委员或审稿人以及Frontiers in Big Data 期刊的编委。 李沐（Mu Li） 亚马逊首席科学家（Principal Scientist），加州大学伯克利分校客座助理教授，美国卡内基梅隆大学计算机系博士。他专注于分布式系统和机器学习算法的研究。他是深度学习框架MXNet 的作者之一。他曾任机器学习创业公司Marianas Labs 的CTO 和百度深度学习研究院的主任研发架构师。他在理论、机器学习、应用和操作系统等多个领域的顶级学术会议（包括FOCS、ICML、NeurIPS、AISTATS、CVPR、KDD 、WSDM、OSDI）上发表过论文。 扎卡里·C. 立顿（Zachary C. Lipton） 亚马逊应用科学家，美国卡内基梅隆大学助理教授，美国加州大学圣迭戈分校博士。他专注于机器学习算法及其社会影响的研究，特别是在时序数据与序列决策上的深度学习。这类工作有着广泛的应用场景，包括医疗诊断、对话系统和产品推荐。他创立了博客“Approximately Correct”（approximatelycorrect.com）。 亚历山大·J. 斯莫拉（Alexander J. Smola） 亚马逊副总裁/ 杰出科学家，德国柏林工业大学计算机科学博士。他曾在澳大利亚国立大学、美国加州大学伯克利分校和卡内基梅隆大学任教。他发表了超过200 篇学术论文，并著有5 本书，其论文及书被引用超过10 万次。他的研究兴趣包括深度学习、贝叶斯非参数、核方法、统计建模和可扩展算法。","对本书的赞誉
        前言
        如何使用本书
        资源与支持
        主要符号表
        第1 章　深度学习简介… ………………… 1
        1.1　起源…………………………………………… 2
        1.2　发展…………………………………………… 4
        1.3　成功案例……………………………………… 6
        1.4　特点………………………………………… 7
        小结…………………………………………… 8
        练习…………………………………………… 8
        第2 章　预备知识… ……………………… 9
        2.1　获取和运行本书的代码……………………… 9
        2.1.1　获取代码并安装运行环境 … ……… 9
        2.1.2　更新代码和运行环境 … …………… 11
        2.1.3　使用GPU版的MXNet … ………… 11
        小结……………………………………………12
        练习……………………………………………12
        2.2　数据操作… ……………………………… 12
        2.2.1　创建NDArray ………………………12
        2.2.2　运算 …………………………………14
        2.2.3　广播机制 ……………………………16
        2.2.4　索引 …………………………………17
        2.2.5　运算的内存开销 ……………………17
        2.2.6　NDArray和NumPy相互变换………18
        小结……………………………………………19
        练习……………………………………………19
        2.3　自动求梯度… …………………………… 19
        2.3.1　简单例子 … …………………………19
        2.3.2　训练模式和预测模式 …………… 20
        2.3.3　对Python控制流求梯度 … …… 20
        小结……………………………………………21
        练习……………………………………………21
        2.4　查阅文档… ……………………………… 21
        2.4.1　查找模块里的所有函数和类 … ……21
        2.4.2　查找特定函数和类的使用 ……… 22
        2.4.3　在MXNet网站上查阅 …………… 23
        小结………………………………………… 24
        练习………………………………………… 24
        第3 章　深度学习基础… ……………… 25
        3.1　线性回归…………………………………… 25
        3.1.1　线性回归的基本要素 … ………… 25
        3.1.2　线性回归的表示方法 … ………… 28
        小结………………………………………… 30
        练习………………………………………… 30
        3.2　线性回归的从零开始实现… …………… 30
        3.2.1　生成数据集 … …………………… 30
        3.2.2　读取数据集 ……………………… 32
        3.2.3　初始化模型参数 ………………… 32
        3.2.4　定义模型 ………………………… 33
        3.2.5　定义损失函数 …………………… 33
        3.2.6　定义优化算法 …………………… 33
        3.2.7　训练模型 ………………………… 33
        小结………………………………………… 34
        练习………………………………………… 34
        3.3　线性回归的简洁实现… ………………… 35
        3.3.1　生成数据集 … …………………… 35
        3.3.2　读取数据集 ……………………… 35
        3.3.3　定义模型 ………………………… 36
        3.3.4　初始化模型参数 ………………… 36
        3.3.5　定义损失函数 …………………… 37
        3.3.6　定义优化算法 …………………… 37
        3.3.7　训练模型 ………………………… 37
        小结………………………………………… 38
        练习………………………………………… 38
        3.4　softmax回归… ………………………… 38
        3.4.1　分类问题 … ……………………… 38
        3.4.2　softmax回归模型… …………… 39
        3.4.3　单样本分类的矢量计算表达式…… 40
        3.4.4　小批量样本分类的矢量计算表达式 …………………………… 40
        3.4.5　交叉熵损失函数 ……………………41
        3.4.6　模型预测及评价 ………………… 42
        小结………………………………………… 42
        练习………………………………………… 42
        3.5　图像分类数据集（Fashion-MNIST）… ……………… 42
        3.5.1　获取数据集 … …………………… 42
        3.5.2　读取小批量 ……………………… 44
        小结………………………………………… 45
        练习………………………………………… 45
        3.6　softmax回归的从零开始实现… ……… 45
        3.6.1　读取数据集 … …………………… 45
        3.6.2　初始化模型参数 ………………… 45
        3.6.3　实现softmax运算 … …………… 46
        3.6.4　定义模型 ………………………… 46
        3.6.5　定义损失函数 …………………… 47
        3.6.6　计算分类准确率 ………………… 47
        3.6.7　训练模型 ………………………… 48
        3.6.8　预测… …………………………… 48
        小结………………………………………… 49
        练习………………………………………… 49
        3.7　softmax回归的简洁实现… …………… 49
        3.7.1　读取数据集 … …………………… 49
        3.7.2　定义和初始化模型 ……………… 50
        3.7.3　softmax和交叉熵损失函数 … … 50
        3.7.4　定义优化算法 …………………… 50
        3.7.5　训练模型 ………………………… 50
        小结………………………………………… 50
        练习………………………………………… 50
        3.8　多层感知机… …………………………… 51
        3.8.1　隐藏层 … ……………………………51
        3.8.2　激活函数 ………………………… 52
        3.8.3　多层感知机 ……………………… 55
        小结………………………………………… 55
        练习………………………………………… 55
        3.9　多层感知机的从零开始实现… ………… 56
        3.9.1　读取数据集 … …………………… 56
        3.9.2　定义模型参数 …………………… 56
        3.9.3　定义激活函数 …………………… 56
        3.9.4　定义模型 ………………………… 56
        3.9.5　定义损失函数 …………………… 57
        3.9.6　训练模型 ………………………… 57
        小结………………………………………… 57
        练习………………………………………… 57
        3.10　多层感知机的简洁实现………………… 57
        3.10.1　定义模型 ………………………… 58
        3.10.2　训练模型 … …………………… 58
        小结………………………………………… 58
        练习………………………………………… 58
        3.11　模型选择、欠拟合和过拟合… ………… 58
        3.11.1　训练误差和泛化误差 …………… 59
        3.11.2　模型选择 ………………………… 59
        3.11.3　欠拟合和过拟合 ………………… 60
        3.11.4　多项式函数拟合实验 ……………61
        小结………………………………………… 65
        练习………………………………………… 65
        3.12　权重衰减………………………………… 65
        3.12.1　方法 ……………………………… 65
        3.12.2　高维线性回归实验 … ………… 66
        3.12.3　从零开始实现 … ……………… 66
        3.12.4　简洁实现 … …………………… 68
        小结………………………………………… 70
        练习………………………………………… 70
        3.13　丢弃法…………………………………… 70
        3.13.1　方法 ……………………………… 70
        3.13.2　从零开始实现 … …………………71
        3.13.3　简洁实现 … …………………… 73
        小结………………………………………… 74
        练习………………………………………… 74
        3.14　正向传播、反向传播和计算图………… 74
        3.14.1　正向传播 ……………………… 74
        3.14.2　正向传播的计算图 … ………… 75
        3.14.3　反向传播 … …………………… 75
        3.14.4　训练深度学习模型 … ………… 76
        小结………………………………………… 77
        练习………………………………………… 77
        3.15　数值稳定性和模型初始化……………… 77
        3.15.1　衰减和爆炸 ……………………… 77
        3.15.2　随机初始化模型参数 … ……… 78
        小结………………………………………… 78
        练习………………………………………… 79
        3.16　实战Kaggle比赛：房价预测… ……… 79
        3.16.1　Kaggle比赛 … ………………… 79
        3.16.2　读取数据集 … ………………… 80
        3.16.3　预处理数据集 … …………………81
        3.16.4　训练模型 … …………………… 82
        3.16.5　k 折交叉验证 …………………… 82
        3.16.6　模型选择 … …………………… 83
        3.16.7　预测并在Kaggle提交结果… … 84
        小结………………………………………… 85
        练习………………………………………… 85
        第4 章　深度学习计算… ……………… 86
        4.1　模型构造………………………………… 86
        4.1.1　继承Block类来构造模型 … …… 86
        4.1.2　Sequential类继承自Block类…………………………… 87
        4.1.3　构造复杂的模型… ……………… 88
        小结………………………………………… 89
        练习………………………………………… 90
        4.2　模型参数的访问、初始化和共享… …… 90
        4.2.1　访问模型参数 … ………………… 90
        4.2.2　初始化模型参数 ………………… 92
        4.2.3　自定义初始化方法 ……………… 93
        4.2.4　共享模型参数 …………………… 94
        小结………………………………………… 94
        练习………………………………………… 94
        4.3　模型参数的延后初始化… ……………… 95
        4.3.1　延后初始化 … …………………… 95
        4.3.2　避免延后初始化 ………………… 96
        小结………………………………………… 96
        练习………………………………………… 97
        4.4　自定义层… ……………………………… 97
        4.4.1　不含模型参数的自定义层 … …… 97
        4.4.2　含模型参数的自定义层 ………… 98
        小结………………………………………… 99
        练习………………………………………… 99
        4.5　读取和存储… …………………………… 99
        4.5.1　读写NDArray… ………………… 99
        4.5.2　读写Gluon模型的参数… ……… 100
        小结………………………………………… 101
        练习………………………………………… 101
        4.6　GPU计算………………………………… 101
        4.6.1　计算设备 … ……………………… 102
        4.6.2　NDArray的GPU计算…………… 102
        4.6.3　Gluon的GPU计算 ……………… 104
        小结………………………………………… 105
        练习………………………………………… 105
        第5 章　卷积神经网络… ……………… 106
        5.1　二维卷积层………………………………… 106
        5.1.1　二维互相关运算 … ……………… 106
        5.1.2　二维卷积层 … …………………… 107
        5.1.3　图像中物体边缘检测 … ………… 108
        5.1.4　通过数据学习核数组 … ………… 109
        5.1.5　互相关运算和卷积运算 … ……… 109
        5.1.6　特征图和感受野… ……………… 110
        小结………………………………………… 110
        练习………………………………………… 110
        5.2　填充和步幅… …………………………… 111
        5.2.1　填充 … …………………………… 111
        5.2.2　步幅 ……………………………… 112
        小结………………………………………… 113
        练习………………………………………… 113
        5.3　多输入通道和多输出通道… …………… 114
        5.3.1　多输入通道 … …………………… 114
        5.3.2　多输出通道… …………………… 115
        5.3.3　1×1卷积层 ……………………… 116
        小结………………………………………… 117
        练习………………………………………… 117
        5.4　池化层… ………………………………… 117
        5.4.1　二维最大池化层和平均池化层 … ………………………… 117
        5.4.2　填充和步幅 ……………………… 119
        5.4.3　多通道 …………………………… 120
        小结………………………………………… 120
        练习………………………………………… 121
        5.5　卷积神经网络（LeNet）… …………… 121
        5.5.1　LeNet模型 … …………………… 121
        5.5.2　训练模型… ……………………… 122
        小结………………………………………… 124
        练习………………………………………… 124
        5.6　深度卷积神经网络（AlexNet）… …… 124
        5.6.1　学习特征表示 … ………………… 125
        5.6.2　AlexNet… ……………………… 126
        5.6.3　读取数据集 ……………………… 127
        5.6.4　训练模型 ………………………… 128
        小结………………………………………… 128
        练习………………………………………… 129
        5.7　使用重复元素的网络（VGG）………… 129
        5.7.1　VGG块 …………………………… 129
        5.7.2　VGG网络 … …………………… 129
        5.7.3　训练模型… ……………………… 130
        小结………………………………………… 131
        练习………………………………………… 131
        5.8　网络中的网络（NiN）… ……………… 131
        5.8.1　NiN块 … ………………………… 131
        5.8.2　NiN模型 … ……………………… 132
        5.8.3　训练模型… ……………………… 133
        小结………………………………………… 134
        练习………………………………………… 134
        5.9　含并行连结的网络（GoogLeNet）…… 134
        5.9.1　Inception块 ……………………… 134
        5.9.2　GoogLeNet模型 … …………… 135
        5.9.3　训练模型 ………………………… 137
        小结………………………………………… 137
        练习………………………………………… 137
        5.10　批量归一化……………………………… 138
        5.10.1　批量归一化层 ………………… 138
        5.10.2　从零开始实现 … ……………… 139
        5.10.3　使用批量归一化层的LeNet … … 140
        5.10.4　简洁实现 … …………………… 141
        小结………………………………………… 142
        练习………………………………………… 142
        5.11　残差网络（ResNet） ……………… 143
        5.11.1　残差块 …………………………… 143
        5.11.2　ResNet模型… ………………… 145
        5.11.3　训练模型………………………… 146
        小结………………………………………… 146
        练习………………………………………… 146
        5.12　稠密连接网络（DenseNet）………… 147
        5.12.1　稠密块 …………………………… 147
        5.12.2　过渡层 … ……………………… 148
        5.12.3　DenseNet模型 ………………… 148
        5.12.4　训练模型 … …………………… 149
        小结………………………………………… 149
        练习………………………………………… 149
        第6 章　循环神经网络… ……………… 150
        6.1　语言模型………………………………… 150
        6.1.1　语言模型的计算 … ……………… 151
        6.1.2　n 元语法 … ……………………… 151
        小结………………………………………… 152
        练习………………………………………… 152
        6.2　循环神经网络… ………………………… 152
        6.2.1　不含隐藏状态的神经网络 … …… 152
        6.2.2　含隐藏状态的循环神经网络… … 152
        6.2.3　应用：基于字符级循环神经网络的语言模型 … ……………………… 154
        小结………………………………………… 155
        练习………………………………………… 155
        6.3　语言模型数据集（歌词）…… 155
        6.3.1　读取数据集 … …………………… 155
        6.3.2　建立字符索引 …………………… 156
        6.3.3　时序数据的采样 ………………… 156
        小结………………………………………… 158
        练习………………………………………… 159
        6.4　循环神经网络的从零开始实现… ……… 159
        6.4.1　one-hot向量 … ………………… 159
        6.4.2　初始化模型参数 ………………… 160
        6.4.3　定义模型 ………………………… 160
        6.4.4　定义预测函数 …………………… 161
        6.4.5　裁剪梯度 ………………………… 161
        6.4.6　困惑度 …………………………… 162
        6.4.7　定义模型训练函数 ……………… 162
        6.4.8　训练模型并创作歌词 …………… 163
        小结………………………………………… 164
        练习………………………………………… 164
        6.5　循环神经网络的简洁实现… …………… 165
        6.5.1　定义模型 … ……………………… 165
        6.5.2　训练模型 ………………………… 166
        小结………………………………………… 168
        练习………………………………………… 168
        6.6　通过时间反向传播… …………………… 168
        6.6.1　定义模型 … ……………………… 168
        6.6.2　模型计算图 ……………………… 169
        6.6.3　方法 ……………………………… 169
        小结………………………………………… 170
        练习………………………………………… 170
        6.7　门控循环单元（GRU）………………… 170
        6.7.1　门控循环单元 … ………………… 171
        6.7.2　读取数据集 ……………………… 173
        6.7.3　从零开始实现 …………………… 173
        6.7.4　简洁实现 ………………………… 175
        小结………………………………………… 176
        练习………………………………………… 176
        6.8　长短期记忆（LSTM）… ……………… 176
        6.8.1　长短期记忆 … …………………… 176
        6.8.2　读取数据集 ……………………… 179
        6.8.3　从零开始实现 …………………… 179
        6.8.4　简洁实现 ………………………… 181
        小结………………………………………… 181
        练习………………………………………… 182
        6.9　深度循环神经网络… …………………… 182
        小结………………………………………… 183
        练习………………………………………… 183
        6.10　双向循环神经网络……………………… 183
        小结………………………………………… 184
        练习………………………………………… 184
        第7 章　优化算法… …………………… 185
        7.1　优化与深度学习…………………………… 185
        7.1.1　优化与深度学习的关系 … ……… 185
        7.1.2　优化在深度学习中的挑战 … …… 186
        小结………………………………………… 188
        练习………………………………………… 189
        7.2　梯度下降和随机梯度下降… …………… 189
        7.2.1　一维梯度下降 … ………………… 189
        7.2.2　学习率 …………………………… 190
        7.2.3　多维梯度下降 …………………… 191
        7.2.4　随机梯度下降 …………………… 193
        小结………………………………………… 194
        练习………………………………………… 194
        7.3　小批量随机梯度下降… ………………… 194
        7.3.1　读取数据集 … …………………… 195
        7.3.2　从零开始实现 …………………… 196
        7.3.3　简洁实现 ………………………… 198
        小结………………………………………… 199
        练习………………………………………… 199
        7.4　动量法… …………………………………200
        7.4.1　梯度下降的问题 … ……………… 200
        7.4.2　动量法 …………………………… 201
        ·6·　目　　录
        7.4.3　从零开始实现 …………………… 203
        7.4.4　简洁实现 ………………………… 205
        小结………………………………………… 205
        练习………………………………………… 205
        7.5　AdaGrad算法……………………………206
        7.5.1　算法 … …………………………… 206
        7.5.2　特点 ……………………………… 206
        7.5.3　从零开始实现 …………………… 208
        7.5.4　简洁实现 ………………………… 209
        小结………………………………………… 209
        练习………………………………………… 209
        7.6　RMSProp算法… ………………………209
        7.6.1　算法 … …………………………… 210
        7.6.2　从零开始实现 …………………… 211
        7.6.3　简洁实现 ………………………… 212
        小结………………………………………… 212
        练习………………………………………… 212
        7.7　AdaDelta算法… ……………………… 212
        7.7.1　算法… …………………………… 212
        7.7.2　从零开始实现 …………………… 213
        7.7.3　简洁实现 ………………………… 214
        小结………………………………………… 214
        练习………………………………………… 214
        7.8　Adam算法… …………………………… 215
        7.8.1　算法 … …………………………… 215
        7.8.2　从零开始实现 …………………… 216
        7.8.3　简洁实现 ………………………… 216
        小结………………………………………… 217
        练习………………………………………… 217
        第8 章　计算性能… …………………… 218
        8.1　命令式和符号式混合编程… …………… 218
        8.1.1　混合式编程取两者之长 … ……… 220
        8.1.2　使用HybridSequential类构造模型 … …………………………… 220
        8.1.3　使用HybridBlock类构造模型… …………………………… 222
        小结………………………………………… 224
        练习………………………………………… 224
        8.2　异步计算… ………………………………224
        8.2.1　MXNet中的异步计算 …………… 224
        8.2.2　用同步函数让前端等待计算结果 … …………………………… 226
        8.2.3　使用异步计算提升计算性能 …… 226
        8.2.4　异步计算对内存的影响 ………… 227
        小结………………………………………… 229
        练习………………………………………… 229
        8.3　自动并行计算… …………………………229
        8.3.1　CPU和GPU的并行计算 … …… 230
        8.3.2　计算和通信的并行计算 ………… 231
        小结………………………………………… 231
        练习………………………………………… 231
        8.4　多GPU计算……………………………… 232
        8.4.1　数据并行 … ……………………… 232
        8.4.2　定义模型 ………………………… 233
        8.4.3　多GPU之间同步数据 … ……… 234
        8.4.4　单个小批量上的多GPU训练 … …………………………… 236
        8.4.5　定义训练函数 …………………… 236
        8.4.6　多GPU训练实验 … …………… 237
        小结………………………………………… 237
        练习………………………………………… 237
        8.5　多GPU计算的简洁实现………………… 237
        8.5.1　多GPU上初始化模型参数……… 238
        8.5.2　多GPU训练模型 … …………… 239
        小结………………………………………… 241
        练习………………………………………… 241
        第9 章　计算机视觉… ………………… 242
        9.1　图像增广…………………………………242
        9.1.1　常用的图像增广方法 … ………… 243
        9.1.2　使用图像增广训练模型 … ……… 246
        小结………………………………………… 250
        练习………………………………………… 250
        9.2　微调… ……………………………………250
        热狗识别 … ……………………………… 251
        小结………………………………………… 255
        练习………………………………………… 255
        目　　录　·7·
        9.3　目标检测和边界框… ……………………255
        边界框 … ………………………………… 256
        小结………………………………………… 257
        练习………………………………………… 257
        9.4　锚框… …………………………………… 257
        9.4.1　生成多个锚框… ………………… 257
        9.4.2　交并比 …………………………… 259
        9.4.3　标注训练集的锚框 ……………… 260
        9.4.4　输出预测边界框… ……………… 263
        小结………………………………………… 265
        练习………………………………………… 265
        9.5　多尺度目标检测… ………………………265
        小结………………………………………… 268
        练习………………………………………… 268
        9.6　目标检测数据集（皮卡丘）… …………268
        9.6.1　获取数据集 … …………………… 269
        9.6.2　读取数据集… …………………… 269
        9.6.3　图示数据 ………………………… 270
        小结………………………………………… 270
        练习………………………………………… 271
        9.7　单发多框检测（SSD）… ……………… 271
        9.7.1　定义模型… ……………………… 271
        9.7.2　训练模型 ………………………… 275
        9.7.3　预测目标 ………………………… 277
        小结………………………………………… 278
        练习………………………………………… 278
        9.8　区域卷积神经网络（R-CNN）系列……280
        9.8.1　R-CNN … ……………………… 280
        9.8.2　Fast R-CNN …………………… 281
        9.8.3　Faster R-CNN ………………… 283
        9.8.4　Mask R-CNN … ……………… 284
        小结………………………………………… 285
        练习………………………………………… 285
        9.9　语义分割和数据集… ……………………285
        9.9.1　图像分割和实例分割 … ………… 285
        9.9.2　Pascal VOC2012语义分割数据集 … ………………………… 286
        小结………………………………………… 290
        练习………………………………………… 290
        9.10　全卷积网络（FCN）… ………………290
        9.10.1　转置卷积层 …………………… 291
        9.10.2　构造模型 … …………………… 292
        9.10.3　初始化转置卷积层……………… 294
        9.10.4　读取数据集 … ………………… 295
        9.10.5　训练模型………………………… 296
        9.10.6　预测像素类别…………………… 296
        小结………………………………………… 297
        练习………………………………………… 297
        9.11　样式迁移… ………………………………298
        9.11.1　方法 ……………………………… 298
        9.11.2　读取内容图像和样式图像……… 299
        9.11.3　预处理和后处理图像 ………… 300
        9.11.4　抽取特征 ……………………… 301
        9.11.5　定义损失函数 ………………… 302
        9.11.6　创建和初始化合成图像 ……… 303
        9.11.7　训练模型………………………… 304
        小结………………………………………… 306
        练习………………………………………… 306
        9.12　实战Kaggle比赛：图像
        分类（CIFAR-10）……………………306
        9.12.1　获取和整理数据集 ……………… 307
        9.12.2　图像增广 … …………………… 310
        9.12.3　读取数据集 … ………………… 310
        9.12.4　定义模型………………………… 311
        9.12.5　定义训练函数 … ……………… 312
        9.12.6　训练模型 … …………………… 312
        9.12.7　对测试集分类并在Kaggle
        提交结果 … …………………… 313
        小结………………………………………… 313
        练习………………………………………… 313
        9.13　实战Kaggle比赛：狗的品种
        识别（ImageNet Dogs）…………… 314
        9.13.1　获取和整理数据集 …………… 315
        9.13.2　图像增广 … …………………… 316
        9.13.3　读取数据集 … ………………… 317
        9.13.4　定义模型 … …………………… 318
        9.13.5　定义训练函数 … ……………… 318
        9.13.6　训练模型 … …………………… 319
        ·8·　目　　录
        9.13.7　对测试集分类并在Kaggle提交结果 … …………………… 319
        小结………………………………………… 320
        练习………………………………………… 320
        第10 章　自然语言处理………………… 321
        10.1　词嵌入（word2vec）………………… 321
        10.1.1　为何不采用one-hot向量… …… 321
        10.1.2　跳字模型 ………………………… 322
        10.1.3　连续词袋模型 …………………… 323
        小结………………………………………… 325
        练习………………………………………… 325
        10.2　近似训练…………………………………325
        10.2.1　负采样 …………………………… 325
        10.2.2　层序softmax …………………… 326
        小结………………………………………… 327
        练习………………………………………… 328
        10.3　word2vec的实现………………………328
        10.3.1　预处理数据集 …………………… 328
        10.3.2　负采样 … ……………………… 331
        10.3.3　读取数据集 … ………………… 331
        10.3.4　跳字模型 … …………………… 332
        10.3.5　训练模型 … …………………… 333
        10.3.6　应用词嵌入模型 … …………… 335
        小结………………………………………… 336
        练习………………………………………… 336
        10.4　子词嵌入（fastText）… ……………336
        小结………………………………………… 337
        练习………………………………………… 337
        10.5　全局向量的词嵌入（GloVe）…………337
        10.5.1　GloVe模型 …………………… 338
        10.5.2　从条件概率比值理解GloVe模型……………………… 339
        小结………………………………………… 340
        练习………………………………………… 340
        10.6　求近义词和类比词………………………340
        10.6.1　使用预训练的词向量 ………… 340
        10.6.2　应用预训练词向量 … ………… 341
        小结………………………………………… 343
        练习………………………………………… 343
        10.7　文本情感分类：使用循环神经网络…… 343
        10.7.1　文本情感分类数据集 ………… 343
        10.7.2　使用循环神经网络的模型……… 345
        小结………………………………………… 347
        练习………………………………………… 347
        10.8　文本情感分类：使用卷积神经网络（textCNN）… …………………347
        10.8.1　一维卷积层 … ………………… 348
        10.8.2　时序最大池化层 … …………… 349
        10.8.3　读取和预处理IMDb数据集 … ……………………… 350
        10.8.4　textCNN模型 … ……………… 350
        小结………………………………………… 353
        练习………………………………………… 353
        10.9　编码器-解码器（seq2seq）…………353
        10.9.1　编码器 ………………………… 354
        10.9.2　解码器 … ……………………… 354
        10.9.3　训练模型………………………… 355
        小结………………………………………… 355
        练习………………………………………… 355
        10.10　 束搜索… ………………………………355
        10.10.1　贪婪搜索 … …………………… 356
        10.10.2　穷举搜索 ……………………… 357
        10.10.3　束搜索 ………………………… 357
        小结………………………………………… 358
        练习………………………………………… 358
        10.11　注意力机制… …………………………358
        10.11.1　计算背景变量 … ……………… 359
        10.11.2　更新隐藏状态 … ……………… 360
        10.11.3　发展… ………………………… 361
        小结………………………………………… 361
        练习………………………………………… 361
        10.12　机器翻译… …………………………… 361
        10.12.1　读取和预处理数据集… ……… 361
        10.12.2　含注意力机制的编码器-解码器 … …………… 363
        10.12.3　训练模型 ……………………… 365
        10.12.4　预测不定长的序列… ………… 367
        10.12.5　评价翻译结果 ………………… 367
        小结………………………………………… 369
        练习………………………………………… 369
        附录A　数学基础… …………………… 370
        附录B　使用 Jupyter 记事本… ……… 376
        附录C　使用 AWS 运行代码…………… 381
        附录D　GPU 购买指南………………… 388
        附录E　如何为本书做贡献… ………… 391
        附录F　d2lzh 包索引…………………… 395
        附录G　中英文术语对照表… ………… 397
        参考文献………………………………… 402
        索引……………………………………… 407
     · · · · · ·     (收起)"
26349607,MATLAB之父:编程实践(中译本),9.3,(20人评价),[ MEI ] Cleve Moler / 薛定宇 / 北京航空航天大学出版社 / 2014-3-1 / 39.9,《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Compu...,https://book.douban.com/subject/26349607/,https://img9.doubanio.com/view/subject/s/public/s28031915.jpg,39.9,9787512414655,"《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求...(展开全部)





《MATLAB 之父：编程实践》是克利夫（Cleve）继《MATLAB 数值分析与科学计算―― 基于MATLAB（修订版）》（Numerical Computing with MATLAB）之后所独立编写的第二本关于MATLAB 应用的书籍，主要是面向高中或大学低年级的读者，目的是想通过实验的方法将MATLAB 语言介绍给广大的初学者，为大家提供一系列在应用数学、科学计算和MATLAB 编程中有代表性的非常实用且有深刻数学意义的实验案例，从而帮助学习人员加深产品认知并有效提高工程应用能力。此书电子首稿于2008 年完成并在过去的5 年里，进行了陆陆续续的精心修订，这次是该书的首个中文版。 《MATLAB 之父：编程实践》一书的英文原版行文生动，案例新颖，处处体现数学之美，字里行间更无不反映出作者的奇思妙想，风趣易懂，每个实验案例的解答都充斥着一种探求式的好奇精神。强烈的好奇心，是克利夫给人留下的最深印象，大到人文历史风土人情，小到会议讲座礼尚往来，他都保持着一种童真般的好奇。这种强烈的好奇心也可以从这本书涉猎广泛的内容中得到体会―― 矩阵、历法、谷歌网页排名、音乐、天体运行、分形图、生命进化、数独等等包罗万象。 这些精彩的内容连同生动文笔都在薛定宇老师的译本中得到了很好的体现。薛老师自己的书在读者中享有很高声誉，我最早拜读的就是他写的自动控制领域经典的教材《控制系统计算机辅助设计―― MATLAB 语言与应用》，结构严谨，思维缜密，内容翔实。这种风格在此书中文版的翻译中与原文达到了奇妙融合，使读者在领略克利夫的独特思路时逻辑清晰，而且兴趣盎然，一定是一次非常愉快的阅读体验。 《MATLAB 之父：编程实践》是北京航空航天大学出版社与迈斯沃克公司在图书合作方面的一个杰作，是迈斯沃克公司近两年中国图书计划中最重要的一个项目。《MATLAB之父：编程实践》一书也获得国内最大的MATLAB/Simulink技术交流平台——MATLAB中文论坛的鼎力推荐,MATLAB中文论坛的“MATLAB读书频道”为本书提供了专门版块供读者交流，以期共同进步。","作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国...(展开全部)




作者简介 Cleve Moler是MathWorks公司的董事长和首席科学家。Moler先后在密歇根大学、斯坦福大学、新墨西哥大学担任数学和计算机科学教授达20余年。1989年全职加入MathWokrs公司之前，他曾在Intel Hypercube和Ardent Computer这两个计算机硬件生产公司工作了五年。Cleve先后就读于加州理工和斯坦福大学并获斯坦福大学博士学位。 作为MATLAB的创始人，Cleve同时也是LINPACK和EISPACK科学子程序库的作者之一。他与别人合作出版了三本关于数值方法的书，同时也独立编写了Numerical Computing with MATLAB 和 Experiments with MATLAB。 Cleve长期服务于美国工业与应用数学学会，并于2007-2008任主席。Cleve于1997年当选美国国家工程院院士，并获多项荣誉，包括瑞典林学平大学荣誉学位，加拿大滑铁卢大学荣誉数学博士学位，丹麦科技大学荣誉博士等。Cleve还获得IEEE计算机学会的2012年计算机先驱奖。","写在前面
        译者的话
        前言
        第1章迭代（Iteration）1
        第2章斐波那契数（FibonacciNumbers）15
        第3章日历与时钟（CalendarsandClocks）29
        第4章矩阵（Matrices）39
        第5章线性方程组（LinearEquations）53
        第6章蕨型叶分形（FractalFern）63
        第7章谷歌的网页排名值（GooglePageRank）71
        第8章指数函数（ExponentialFunction）85
        第9章T形积木（TPuzzle）99
        第10章幻方问题（MagicSquares）107
        第11章井字棋的魅力（TicTacToeMagic）123
        第12章生命游戏（GameofLife）131
        第13章曼德勃罗集（MandelbrotSet）141
        第14章数独（Sudoku）159
        第15章常微分方程（OrdinaryDifferentialEquations）173
        第16章捕食者与猎物模型（Predator-PreyModel）185
        第17章轨道（Orbits）191
        第18章浅水方程（ShallowWaterEquations）207
        第19章摩尔斯电码（MorseCode）211
        第20章音乐（Music）227
     · · · · · ·     (收起)"
35602582,现代C++语言核心特性解析,8.9,(46人评价),谢丙堃 / 人民邮电出版社 / 2021-10,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还...,https://book.douban.com/subject/35602582/,https://img3.doubanio.com/view/subject/s/public/s33999027.jpg,,9787115564177,这是一本 C++ 进阶图书，全书分为 42 章，深入探讨了从 C++11 到 C++20 引入的核心特性。本书不仅通过大量的实例代码讲解特性的概念和语法，还从编译器的角度分析特性的实现原理，让读者能够知其然也知其所以然。本书适合出于工作需要而学习 C++ 新特性的 C++ 从业者，也适合对 C++ 新特性有浓烈兴趣的 C++ 爱好者。而对 C++ 入门者来说，也有必要在有一定的 C++ 基础后阅读本书，通过本书来进一步学习 C++ 的核心特性。本书的多媒体版本已由“盛格塾”以微信小程序方式推出，包含作者的语音讲解、插图、PPT 和示例代码。读者可以在手机上学习，也可以在线提问，与老师和其他同学互动。,谢丙堃，从事 C++ 开发工作十余年，先后在数家知名互联网公司担任 C++ 高级开发工程师、技术专家和技术经理。他也是 C++ 语言的爱好者，热衷于研究 C++ 语言的新特性以及 C++ 模板元编程技术。,"第1章　新基础类型（C++11～C++20） 1
        1.1 整数类型long long 1
        1.2 新字符类型char16_t和char32_t 4
        1.2.1 字符集和编码方法 4
        1.2.2 使用新字符类型char16_t和char32_t 5
        1.2.3 wchar_t存在的问题 6
        1.2.4 新字符串连接 7
        1.2.5 库对新字符类型的支持 7
        1.3 char8_t字符类型 8
        1.4 总结 8
        第2章　内联和嵌套命名空间（C++11～C++20） 9
        2.1 内联命名空间的定义和使用 9
        2.2 嵌套命名空间的简化语法 11
        2.3 总结 13
        第3章　auto占位符（C++11～C++17） 14
        3.1 重新定义的auto关键字 14
        3.2 推导规则 16
        3.3 什么时候使用auto 18
        3.4 返回类型推导 20
        3.5 lambda表达式中使用auto类型推导 20
        3.6 非类型模板形参占位符 21
        3.7 总结 22
        第4章　decltype说明符（C++11～C++17） 23
        4.1 回顾typeof和typeid 23
        4.2 使用decltype说明符 24
        4.3 推导规则 27
        4.4 cv限定符的推导 29
        4.5 decltype(auto) 30
        4.6 decltype(auto)作为非类型模板形参占位符 31
        4.7 总结 32
        第5章　函数返回类型后置（C++11） 33
        5.1 使用函数返回类型后置声明函数 33
        5.2 推导函数模板返回类型 34
        5.3 总结 36
        第6章　右值引用（C++11 C++17 C++20） 37
        6.1 左值和右值 37
        6.2 左值引用 39
        6.3 右值引用 40
        6.4 右值的性能优化空间 42
        6.5 移动语义 43
        6.6 值类别 47
        6.7 将左值转换为右值 48
        6.8 万能引用和引用折叠 50
        6.9 完美转发 52
        6.10 针对局部变量和右值引用的隐式移动操作 55
        6.11 总结 57
        第7章　lambda表达式（C++11～C++20） 58
        7.1 lambda表达式语法 58
        7.2 捕获列表 60
        7.2.1 作用域 60
        7.2.2 捕获值和捕获引用 61
        7.2.3 特殊的捕获方法 64
        7.3 lambda表达式的实现原理 65
        7.4 无状态lambda表达式 68
        7.5 在STL中使用lambda表达式 68
        7.6 广义捕获 69
        7.7 泛型lambda表达式 72
        7.8 常量lambda表达式和捕获*this 72
        7.9 捕获[=, this] 73
        7.10 模板语法的泛型lambda表达式 74
        7.11 可构造和可赋值的无状态lambda表达式 76
        7.12 总结 77
        第8章　非静态数据成员默认初始化（C++11 C++20） 78
        8.1 使用默认初始化 78
        8.2 位域的默认初始化 79
        8.3 总结 80
        第9章　列表初始化（C++11 C++20） 81
        9.1 回顾变量初始化 81
        9.2 使用列表初始化 82
        9.3 std::initializer_list详解 84
        9.4 使用列表初始化的注意事项 86
        9.4.1 隐式缩窄转换问题 86
        9.4.2 列表初始化的优先级问题 87
        9.5 指定初始化 88
        9.6 总结 90
        第10章　默认和删除函数（C++11） 91
        10.1 类的特殊成员函数 91
        10.2 显式默认和显式删除 95
        10.3 显式删除的其他用法 98
        10.4 explicit和=delete 99
        10.5 总结 100
        第11章　非受限联合类型（C++11） 101
        11.1 联合类型在C++中的局限性 101
        11.2 使用非受限联合类型 102
        11.3 总结 106
        第12章　委托构造函数（C++11） 107
        12.1 冗余的构造函数 107
        12.2 委托构造函数 110
        12.3 委托模板构造函数 114
        12.4 捕获委托构造函数的异常 115
        12.5 委托参数较少的构造函数 116
        12.6 总结 117
        第13章　继承构造函数（C++11） 118
        13.1 继承关系中构造函数的困局 118
        13.2 使用继承构造函数 119
        13.3 总结 123
        第14章　强枚举类型（C++11 C++17 C++20） 124
        14.1 枚举类型的弊端 124
        14.2 使用强枚举类型 129
        14.3 列表初始化有底层类型枚举对象 131
        14.4 使用using打开强枚举类型 133
        14.5 总结 135
        第15章　扩展的聚合类型（C++17 C++20） 136
        15.1 聚合类型的新定义 136
        15.2 聚合类型的初始化 137
        15.3 扩展聚合类型的兼容问题 139
        15.4 禁止聚合类型使用用户声明的构造函数 140
        15.5 使用带小括号的列表初始化聚合类型对象 142
        15.6 总结 143
        第16章　override和final说明符（C++11） 144
        16.1 重写、重载和隐藏 144
        16.2 重写引发的问题 145
        16.3 使用override说明符 145
        16.4 使用final说明符 146
        16.5 override和final说明符的特别之处 148
        16.6 总结 148
        第17章　基于范围的for循环（C++11 C++17 C++20） 149
        17.1 烦琐的容器遍历 149
        17.2 基于范围的for循环语法 150
        17.3 begin和end函数不必返回相同类型 151
        17.4 临时范围表达式的陷阱 152
        17.5 实现一个支持基于范围的for循环的类 153
        17.6 总结 155
        第18章　支持初始化语句的if和switch（C++17） 156
        18.1 支持初始化语句的if 156
        18.2 支持初始化语句的switch 159
        18.3 总结 160
        第19章　static_assert声明 161
        19.1 运行时断言 161
        19.2 静态断言的需求 162
        19.3 静态断言 163
        19.4 单参数static_assert 164
        19.5 总结 165
        第20章　结构化绑定（C++17 C++20） 166
        20.1 使用结构化绑定 166
        20.2 深入理解结构化绑定 169
        20.3 结构化绑定的3种类型 171
        20.3.1 绑定到原生数组 171
        20.3.2 绑定到结构体和类对象 172
        20.3.3 绑定到元组和类元组的对象 173
        20.4 实现一个类元组类型 175
        20.5 绑定的访问权限问题 178
        20.6 总结 179
        第21章　noexcept关键字（C++11 C++17 C++20） 180
        21.1 使用noexcept代替throw 180
        21.2 用noexcept来解决移动构造问题 183
        21.3 noexcept和throw() 185
        21.4 默认使用noexcept的函数 186
        21.5 使用noexcept的时机 189
        21.6 将异常规范作为类型的一部分 190
        21.7 总结 192
        第22章　类型别名和别名模板（C++11 C++14） 193
        22.1 类型别名 193
        22.2 别名模板 194
        22.3 总结 196
        第23章　指针字面量nullptr（C++11） 197
        23.1 零值整数字面量 197
        23.2 nullptr关键字 198
        23.3 总结 201
        第24章　三向比较（C++20） 202
        24.1 “太空飞船”（spaceship）运算符 202
        24.2 三向比较的返回类型 202
        24.2.1 std::strong_ordering 203
        24.2.2 std::weak_ordering 204
        24.2.3 std::partial_ordering 205
        24.3 对基础类型的支持 206
        24.4 自动生成的比较运算符函数 207
        24.5 兼容旧代码 210
        24.6 总结 211
        第25章　线程局部存储（C++11） 212
        25.1 操作系统和编译器对线程局部存储的支持 212
        25.2 thread_local说明符 213
        25.3 总结 217
        第26章　扩展的inline说明符（C++17） 218
        26.1 定义非常量静态成员变量的问题 218
        26.2 使用inline说明符 219
        26.3 总结 220
        第27章　常量表达式（C++11～C++20） 221
        27.1 常量的不确定性 221
        27.2 constexpr值 224
        27.3 constexpr函数 225
        27.4 constexpr构造函数 228
        27.5 对浮点的支持 230
        27.6 C++14标准对常量表达式函数的增强 230
        27.7 constexpr lambdas表达式 233
        27.8 constexpr的内联属性 235
        27.9 if constexpr 236
        27.10 允许constexpr虚函数 240
        27.11 允许在constexpr函数中出现Try-catch 244
        27.12 允许在constexpr中进行平凡的默认初始化 244
        27.13 允许在constexpr中更改联合类型的有效成员 245
        27.14 使用consteval声明立即函数 246
        27.15 使用constinit检查常量初始化 247
        27.16 判断常量求值环境 248
        27.17 总结 252
        第28章　确定的表达式求值顺序（C++17） 253
        28.1 表达式求值顺序的不确定性 253
        28.2 表达式求值顺序详解 254
        28.3 总结 255
        第29章　字面量优化（C++11～C++17） 257
        29.1 十六进制浮点字面量 257
        29.2 二进制整数字面量 258
        29.3 单引号作为整数分隔符 258
        29.4 原生字符串字面量 259
        29.5 用户自定义字面量 261
        29.6 总结 267
        第30章　alignas和alignof（C++11 C++17） 268
        30.1 不可忽视的数据对齐问题 268
        30.2 C++11标准之前控制数据对齐的方法 270
        30.3 使用alignof运算符 272
        30.4 使用alignas说明符 273
        30.5 其他关于对齐字节长度的支持 276
        30.6 C++17中使用new分配指定对齐字节长度的对象 278
        30.7 总结 279
        第31章　属性说明符和标准属性（C++11～C++20） 280
        31.1 GCC的属性语法 280
        31.2 MSVC的属性语法 281
        31.3 标准属性说明符语法 282
        31.4 使用using打开属性的命名空间 283
        31.5 标准属性 283
        31.5.1 noreturn 284
        31.5.2 carries_dependency 286
        31.5.3 deprecated 286
        31.5.4 fallthrough 287
        31.5.5 nodiscard 288
        31.5.6 maybe_unused 290
        31.5.7 likely和unlikely 290
        31.5.8 no_unique_address 291
        31.6 总结 293
        第32章　新增预处理器和宏（C++17 C++20） 294
        32.1 预处理器__has_include 294
        32.2 特性测试宏 295
        32.2.1 属性特性测试宏 295
        32.2.2 语言功能特性测试宏 295
        32.2.3 标准库功能特性测试宏 297
        32.3 新增宏__VA_OPT__ 301
        32.4 总结 302
        第33章　协程（C++20） 303
        33.1 协程的使用方法 303
        33.2 协程的实现原理 308
        33.2.1 co_await运算符原理 308
        33.2.2 co_yield运算符原理 313
        33.2.3 co_return运算符原理 317
        33.2.4 promise_type的其他功能 319
        33.3 总结 320
        第34章　基础特性的其他优化（C++11～C++20） 321
        34.1 显式自定义类型转换运算符（C++11） 321
        34.2 关于std::launder()（C++17） 325
        34.3 返回值优化（C++11～C++17） 326
        34.4 允许按值进行默认比较（C++20） 333
        34.5 支持new表达式推导数组长度（C++20） 334
        34.6 允许数组转换为未知范围的数组（C++20） 335
        34.7 在delete运算符函数中析构对象（C++20） 336
        34.8 调用伪析构函数结束对象声明周期（C++20） 337
        34.9 修复const和默认复制构造函数不匹配造成无法编译的问题（C++20） 338
        34.10 不推荐使用volatile的情况（C++20） 339
        34.11 不推荐在下标表达式中使用逗号运算符（C++20） 340
        34.12 模块（C++20） 340
        34.13 总结 341
        第35章　可变参数模板（C++11 C++17 C++20） 342
        35.1 可变参数模板的概念和语法 342
        35.2 形参包展开 344
        35.3 sizeof...运算符 352
        35.4 可变参数模板的递归计算 353
        35.5 折叠表达式 354
        35.6 一元折叠表达式中空参数包的特殊处理 357
        35.7 using声明中的包展开 358
        35.8 lambda表达式初始化捕获的包展开 359
        35.9 总结 361
        第36章　typename优化（C++17 C++20） 362
        36.1 允许使用typename声明模板形参 362
        36.2 减少typename使用的必要性 363
        36.3 总结 365
        第37章　模板参数优化（C++11 C++17 C++20） 366
        37.1 允许常量求值作为所有非类型模板的实参 366
        37.2 允许局部和匿名类型作为模板实参 368
        37.3 允许函数模板的默认模板参数 369
        37.4 函数模板添加到ADL查找规则 370
        37.5 允许非类型模板形参中的字面量类类型 371
        37.6 扩展的模板参数匹配规则 373
        37.7 总结 374
        第38章　类模板的模板实参推导（C++17 C++20） 375
        38.1 通过初始化构造推导类模板的模板实参 375
        38.2 拷贝初始化优先 377
        38.3 lambda类型的用途 378
        38.4 别名模板的类模板实参推导 380
        38.5 聚合类型的类模板实参推导 380
        38.6 总结 382
        第39章　用户自定义推导指引（C++17） 383
        39.1 使用自定义推导指引推导模板实例 383
        39.2 聚合类型类模板的推导指引 386
        39.3 总结 387
        第40章　SFINAE（C++11） 388
        40.1 替换失败和编译错误 388
        40.2 SFINAE规则详解 389
        40.3 总结 394
        第41章　概念和约束（C++20） 395
        41.1 使用std::enable_if约束模板 395
        41.2 概念的背景介绍 396
        41.3 使用concept和约束表达式定义概念 397
        41.4 requires子句和约束检查顺序 398
        41.5 原子约束 401
        41.6 requires表达式 403
        41.6.1 简单要求 404
        41.6.2 类型要求 405
        41.6.3 复合要求 405
        41.6.4 嵌套要求 406
        41.7 约束可变参数模板 407
        41.8 约束类模板特化 408
        41.9 约束auto 409
        41.10 总结 410
        第42章　模板特性的其他优化（C++11 C++14） 411
        42.1 外部模板（C++11） 411
        42.2 连续右尖括号的解析优化（C++11） 413
        42.3 friend声明模板形参（C++11） 415
        42.4 变量模板（C++14） 417
        42.5 explicit(bool) 419
        42.6 总结 423
        附录   特性章节对照表 424
     · · · · · ·     (收起)"
36303408,深度学习入门2,9.7,(32人评价),[日]斋藤康毅 / 郑明智 / 人民邮电出版社 / 2023-3 / 129.80元,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。
手把手带你创建深度学习框架，直击现代深度学习框架本质！
◎ 编辑推荐
• 简明易懂，讲...",https://book.douban.com/subject/36303408/,https://img3.doubanio.com/view/subject/s/public/s34476102.jpg,129.80元,9787115607515,"“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，...(展开全部)





“鱼书”《深度学习入门：基于Python的理论与实现》作者又一力作。 手把手带你创建深度学习框架，直击现代深度学习框架本质！ ◎ 编辑推荐 • 简明易懂，讲解详细 本书延续前作的行文风格，采用通俗的语言和大量直观的示意图详细讲解，帮助读者加深对PyTorch、TensorFlow和Chainer等现代深度学习框架的理解，进一步巩固Python编程和软件开发的相关知识。 • 通过“从零创建”，剖析深度学习框架机制 本书会从零创建一个深度学习框架，让读者在运行程序的过程中了解深度学习框架中蕴藏的技术与机制。通过这样的体验，读者可了解到深度学习框架的本质。 • 增量开发 本书将繁杂的深度学习框架的创建工作分为60个步骤完成，内容循序渐进，读者可在一步步的实践过程中获得正向的反馈结果，激发学习动力。 ◎ 内容简介 深度学习框架中蕴藏着惊人的技术和有趣的机制，本书旨在揭开这些技术和机制的神秘面纱，帮助读者正确理解技术，体会它们的有趣之处。为此，本书会带领读者从零开始创建一个深度学习框架——DeZero。 DeZero 是本书原创的框架，它用最少的代码实现了现代深度学习框架的功能。本书分60 个步骤来完成这个框架，在此过程中，读者会加深对PyTorch、TensorFlow 和Chainer 等现代深度学习框架的理解，看清深度学习框架的本质。 本书沿袭《深度学习入门：基于Python 的理论与实现》的风格，语言通俗，代码简洁，讲解详细。在自制框架的过程中，读者还能进一步巩固Python 编程和软件开发相关的知识。 本书适合对深度学习框架感兴趣的读者阅读。",斋藤康毅 1984年生于日本长崎县，东京工业大学毕业，并完成东京大学研究生院课程。目前在某企业从事人工智能相关的研究和开发工作。著有《深度学习入门：基于Python的理论与实现》，同时也是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。,"前言
        第1阶段 自动微分 1
        步骤1 作为“箱子”的变量  3
        1.1 什么是变量  3
        1.2 实现Variable类  4
        1.3 （补充）NumPy的多维数组    6
        步骤2 创建变量的函数     8
        2.1 什么是函数      8
        2.2 Function类的实现   9
        2.3 使用Function类     10
        步骤3 函数的连续调用       13
        3.1 Exp函数的实现     13
        3.2 函数的连续调用     14
        步骤4 数值微分       16
        4.1 什么是导数       16
        4.2 数值微分的实现     17
        4.3 复合函数的导数     20
        4.4 数值微分存在的问题      21
        步骤5 反向传播的理论知识       22
        5.1 链式法则        22
        5.2 反向传播的推导      23
        5.3 用计算图表示       25
        步骤6 手动进行反向传播        27
        6.1 Variable类的功能扩展       27
        6.2 Function类的功能扩展       28
        6.3 Square类和Exp类的功能扩展      28
        6.4 反向传播的实现      29
        步骤7 反向传播的自动化        32
        7.1 为反向传播的自动化创造条件      33
        7.2 尝试反向传播       36
        7.3 增加backward方法       38
        步骤8 从递归到循环        40
        8.1 现在的Variable类       40
        8.2 使用循环实现       41
        8.3 代码验证        42
        步骤9 让函数更易用        43
        9.1 作为Python函数使用       43
        9.2 简化backward方法       45
        9.3 只支持ndarray       46
        步骤10 测试         50
        10.1 Python的单元测试       50
        10.2 square函数反向传播的测试      52
        10.3 通过梯度检验来自动测试      53
        10.4 测试小结       54
        第2阶段 用自然的代码表达       59
        步骤11 可变长参数（正向传播篇)       61
        11.1 修改Function类       62
        11.2 Add类的实现      64
        步骤12 可变长参数（改进篇)        65
        12.1 第1项改进：使函数更容易使用      65
        12.2 第2项改进：使函数更容易实现      67
        12.3 add函数的实现       69
        步骤13 可变长参数（反向传播篇)       70
        13.1 支持可变长参数的Add类的反向传播     70
        13.2 修改Variable类       71
        13.3 Square类的实现      73
        步骤14 重复使用同一个变量        75
        14.1 问题的原因 76
        14.2 解决方案       77
        14.3 重置导数       79
        步骤15 复杂的计算图（理论篇）81
        15.1 反向传播的正确顺序       82
        15.2 当前的DeZero        84
        15.3 函数的优先级      87
        步骤16 复杂的计算图（实现篇）88
        16.1 增加“辈分”变量      88
        16.2 按照“辈分”顺序取出元素     90
        16.3 Variable类的backward       92
        16.4 代码验证       93
        步骤17 内存管理和循环引用        97
        17.1 内存管理       97
        17.2 引用计数方式的内存管理      98
        17.3 循环引用      100
        17.4 weakref模块      102
        17.5 代码验证      104
        步骤18 减少内存使用量的模式      106
        18.1 不保留不必要的导数      106
        18.2 回顾Function类      109
        18.3 使用Confifig类进行切换      110
        18.4 模式的切换      111
        18.5 使用with语句切换    112
        步骤19 让变量更易用       116
        19.1 命名变量      116
        19.2 实例变量ndarray      117
        19.3 len函数和print函数      119
        步骤20 运算符重载（1）122
        20.1 Mul类的实现      122
        20.2 运算符重载      125
        步骤21 运算符重载（2）128
        21.1 与ndarray一起使用     128
        21.2 与flfloat和int一起使用    130
        21.3 问题1：左项为flfloat或int的情况    131
        21.4 问题2：左项为ndarray实例的情况   133
        步骤22 运算符重载（3）134
        22.1 负数       135
        22.2 减法       136
        22.3 除法       138
        22.4 幂运算       139
        步骤23 打包         141
        23.1 文件结构      142
        23.2 将代码移到核心类     142
        23.3 运算符重载      144
        23.4 实际的_ _init_ _.py文件     146
        23.5 导入dezero       147
        步骤24 复杂函数的求导        149
        24.1 Sphere函数       150
        24.2 matyas函数       151
        24.3 GoldsteinPrice函数      152
        第3阶段 实现高阶导数         161
        步骤25 计算图的可视化（1） 163
        25.1 安装Graphviz       163
        25.2 使用DOT语言描述图形     165
        25.3 指定节点属性     165
        25.4 连接节点      167
        步骤26 计算图的可视化（2）169
        26.1 可视化代码的使用示例      169
        26.2 从计算图转换为DOT语言    171
        26.3 从DOT语言转换为图像     174
        26.4 代码验证      176
        步骤27 泰勒展开的导数        178
        27.1 sin函数的实现       178
        27.2 泰勒展开的理论知识      179
        27.3 泰勒展开的实现     180
        27.4 计算图的可视化     182
        步骤28 函数优化        184
        28.1 Rosenbrock函数      184
        28.2 求导       185
        28.3 梯度下降法的实现     186
        步骤29 使用牛顿法进行优化（手动计算）190
        29.1 使用牛顿法进行优化的理论知识    191
        29.2 使用牛顿法实现优化      195
        步骤30 高阶导数（准备篇） 197
        30.1 确认工作①：Variable实例变量    197
        30.2 确认工作②：Function类     199
        30.3 确认工作③：Variable类的反向传播    201
        步骤31 高阶导数（理论篇） 204
        31.1 在反向传播时进行的计算     204
        31.2 创建反向传播的计算图的方法    206
        步骤32 高阶导数（实现篇） 209
        32.1 新的DeZero       209
        32.2 函数类的反向传播     210
        32.3 实现更有效的反向传播（增加模式控制代码）211
        32.4 修改_ _init_ _.py      213
        步骤33 使用牛顿法进行优化（自动计算） 215
        33.1 求二阶导数      215
        33.2 使用牛顿法进行优化      217
        步骤34 sin函数的高阶导数        219
        34.1 sin函数的实现       219
        34.2 cos函数的实现      220
        34.3 sin函数的高阶导数      221
        步骤35 高阶导数的计算图       225
        35.1 tanh函数的导数     226
        35.2 tanh函数的实现     226
        35.3 高阶导数的计算图可视化     227
        步骤36 DeZero的其他用途        234
        36.1 double backprop的用途     234
        36.2 深度学习研究中的应用示例     236
        第4阶段 创建神经网络         243
        步骤37 处理张量        245
        37.1 对各元素进行计算     245
        37.2 使用张量时的反向传播      247
        37.3 使用张量时的反向传播（补充内容）249
        步骤38 改变形状的函数        254
        38.1 reshape函数的实现      254
        38.2 从Variable对象调用reshape    258
        38.3 矩阵的转置      259
        38.4 实际的transpose函数（补充内容）262
        步骤39 求和的函数        264
        39.1 sum函数的反向传播      264
        39.2 sum函数的实现      266
        39.3 axis和keepdims      268
        步骤40 进行广播的函数        272
        40.1 broadcast_to函数和sum_to函数    272
        40.2 DeZero的broadcast_to函数和sum_to函数  275
        40.3 支持广播      277
        步骤41 矩阵的乘积        280
        41.1 向量的内积和矩阵的乘积     280
        41.2 检查矩阵的形状     282
        41.3 矩阵乘积的反向传播      282
        步骤42 线性回归        288
        42.1 玩具数据集      288
        42.2 线性回归的理论知识      289
        42.3 线性回归的实现     291
        42.4 DeZero的mean_squared_error函数（补充内容）  295
        步骤43 神经网络        298
        43.1 DeZero中的linear函数      298
        43.2 非线性数据集     301
        43.3 激活函数和神经网络      302
        43.4 神经网络的实现     303
        步骤44 汇总参数的层       307
        44.1 Parameter类的实现     307
        44.2 Layer类的实现      309
        44.3 Linear类的实现      312
        44.4 使用Layer实现神经网络    314
        步骤45 汇总层的层        316
        45.1 扩展Layer类      316
        45.2 Model类      319
        45.3 使用Model来解决问题      321
        45.4 MLP类      323
        步骤46 通过Optimizer更新参数      325
        46.1 Optimizer类      325
        46.2 SGD类的实现       326
        46.3 使用SGD类来解决问题     327
        46.4 SGD以外的优化方法     328
        步骤47 softmax函数和交叉熵误差      331
        47.1 用于切片操作的函数      331
        47.2 softmax函数      334
        47.3 交叉熵误差      337
        步骤48 多分类       340
        48.1 螺旋数据集      340
        48.2 用于训练的代码     341
        步骤49 Dataset类和预处理        346
        49.1 Dataset类的实现     346
        49.2 大型数据集的情况     348
        49.3 数据的连接      349
        49.4 用于训练的代码     350
        49.5 数据集的预处理     351
        步骤50 用于取出小批量数据的DataLoader     354
        50.1 什么是迭代器     354
        50.2 使用DataLoader      358
        50.3 accuracy函数的实现      359
        50.4 螺旋数据集的训练代码      360
        步骤51 MINST的训练       363
        51.1 MNIST数据集       364
        51.2 训练MNIST       366
        51.3 改进模型      368
        第5阶段 DeZero高级挑战      377
        步骤52 支持GPU        379
        52.1 CuPy的安装和使用方法     379
        52.2 cuda模块      382
        52.3 向Variable / Layer / DataLoader类添加代码   383
        52.4 函数的相应修改     386
        52.5 在GPU上训练MNIST      388
        步骤53 模型的保存和加载       391
        53.1 NumPy的save函数和load函数     391
        53.2 Layer类参数的扁平化    394
        53.3 Layer类的save函数和load函数     395
        步骤54 Dropout和测试模式       398
        54.1 什么是Dropout      398
        54.2 Inverted Dropout     401
        54.3 增加测试模式     401
        54.4 Dropout的实现      402
        步骤55 CNN的机制（1） 404
        55.1 CNN的网络结构      404
        55.2 卷积运算      405
        55.3 填充       407
        55.4 步幅       408
        55.5 输出大小的计算方法      409
        步骤56 CNN的机制（2）411
        56.1 三阶张量      411
        56.2 结合方块进行思考     412
        56.3 小批量处理      414
        56.4 池化层       415
        步骤57 conv2d函数和pooling函数     418
        57.1 使用im2col展开     418
        57.2 conv2d函数的实现      420
        57.3 Conv2d层的实现      425
        57.4 pooling函数的实现      426
        步骤58 具有代表性的CNN（VGG16）429
        58.1 VGG16的实现      429
        58.2 已训练的权重数据     431
        58.3 使用已训练的VGG16     435
        步骤59 使用RNN处理时间序列数据      438
        59.1 RNN层的实现       438
        59.2 RNN模型的实现      442
        59.3 切断连接的方法     445
        59.4 正弦波的预测     446
        步骤60 LSTM与数据加载器       451
        60.1 用于时间序列数据的数据加载器    451
        60.2 LSTM层的实现      453
        附录A inplace运算（步骤14的补充内容）463
        A.1 问题确认        463
        A.2 关于复制和覆盖        464
        A.3 DeZero的反向传播        465
        附录B 实现get_item函数（步骤47的补充内容）466
        附录C 在Google Colaboratory上运行      469
        后 记         473
        参考文献          477
     · · · · · ·     (收起)"
35863224,C++20高级编程(第5版),8.4,(195人评价),[比]马克·格雷戈勒（Marc Gregoire） / 程序喵大人、惠惠、墨梵 / 清华大学出版社 / 2022-4 / 228,"拥抱C++的深度和复杂性，挖掘更多可能
众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉...",https://book.douban.com/subject/35863224/,https://img3.doubanio.com/view/subject/s/public/s34341252.jpg,228,9787302602132,"拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函...(展开全部)





拥抱C++的深度和复杂性，挖掘更多可能 众所周知，C++难以掌握，但其广泛的功能使其成为游戏和商业软件应用程序中最常用的语言。即使是有经验的用户通常也不熟悉许多高级特性，但C++20的发布提供了探索该语言全部功能的绝佳机会。《C++20高级编程(第5版)》为C++的必要内容提供了一个代码密集型、面向解决方案的指南，包括最新版本中的最新工具和功能。本书包含面向现实世界编程的实用指导，是程序员深入研究C++的理想机会。第5版涵盖了C++20的内容。 主要内容 ● 演示如何用C++思考，以最大限度地发挥语言的深远能力，并开发有效的解决方案 ● 解释难以理解的原理，进行陷阱警告，分享提高效率和性能的提示、技巧和变通方法 ● 呈现各种具有挑战性的、真实世界的程序，其用途广泛，足以融入任何项目 ● 重点介绍C++20的新特性，包括模块、概念、三向比较、立即执行函数等 ● 深入讨论新的C++20标准库功能，例如文本格式化、范围、原子智能指针、同步原语、日期、时区等","Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Win...(展开全部)




Marc Gregoire是一名软件工程师，毕业于比利时鲁汶大学，拥有计算机科学工程硕士学位。之后，他在鲁汶大学又获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium工作。他曾在Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris上运行关键2G和3G软件的咨询服务。这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc目前担任Nikon Metrology(www.nikonmetrology.com)的软件架构师；Nikon Metrology是Nikon的一个部门，是精密光学仪器、X光机等设备和X光、CT和3D扫描解决方案的领先供应商。 Marc的主要技术专长是C/C++，特别是Microsoft VC++和MFC框架。他还擅长在Windows和Linux平台上开发24×7运行的C++程序，例如KNX/EIB家庭自动化监控软件。除了C/C++之外，Marc还喜欢C#。 2007年4月，他凭借Visual C++方面的专业技能，获得了微软年度MVP称号。 Marc还是比利时C++用户组(www.becpp.org)的创始人，是C++ Standard Library Quick Reference 第1版和第2版(Apress)的共同作者，以及多家出版社出版的多种书籍的技术编辑，是C++大会CppCon的活跃演讲者。","第I部分  专业的C++简介
        第1章  C++和标准库速成   3
        1.1  C++速成   3
        1.1.1  小程序“Hello World”   4
        1.1.2  名称空间   7
        1.1.3  字面量   9
        1.1.4  变量   9
        1.1.5  运算符   12
        1.1.6  枚举类型   14
        1.1.7  结构体   16
        1.1.8  条件语句   17
        1.1.9  条件运算符   19
        1.1.10  逻辑比较运算符   20
        1.1.11  三向比较运算符   21
        1.1.12  函数   22
        1.1.13  属性   23
        1.1.14  C风格的数组   26
        1.1.15  std::array   27
        1.1.16  std::vector   28
        1.1.17  std::pair   28
        1.1.18  std::optional   29
        1.1.19  结构化绑定   30
        1.1.20  循环   30
        1.1.21  初始化列表   31
        1.1.22  C++中的字符串   32
        1.1.23  作为面向对象语言的C++   32
        1.1.24  作用域解析   35
        1.1.25  统一初始化   36
        1.1.26  指针和动态内存   39
        1.1.27  const的用法   43
        1.1.28  constexpr关键字   45
        1.1.29  consteval关键字   46
        1.1.30  引用   47
        1.1.31  const_cast()   55
        1.1.32  异常   56
        1.1.33  类型别名   56
        1.1.34  类型定义   57
        1.1.35  类型推断   58
        1.1.36  标准库   60
        1.2  第一个大型的C++程序   61
        1.2.1  雇员记录系统   61
        1.2.2  Employee类   61
        1.2.3  Database类   64
        1.2.4  用户界面   67
        1.2.5  评估程序   69
        1.3  本章小结   69
        1.4  练习   69
        第2章  使用string和string_view   71
        2.1  动态字符串   71
        2.1.1  C风格字符串   71
        2.1.2  字符串字面量   73
        2.1.3  C++ std::string类   75
        2.1.4  数值转换   78
        2.1.5  std::string_view类   81
        2.1.6  非标准字符串   84
        2.2  字符串格式化   84
        2.2.1  格式说明符   85
        2.2.2  格式说明符错误   87
        2.2.3  支持自定义类型   87
        2.3  本章小结   90
        2.4  练习   90
        第3章  编码风格   91
        3.1  良好外观的重要性   91
        3.1.1  事先考虑   91
        3.1.2  良好风格的元素   92
        3.2  为代码编写文档   92
        3.2.1  使用注释的原因   92
        3.2.2  注释的风格   96
        3.3  分解   99
        3.3.1  通过重构分解   100
        3.3.2  通过设计分解   101
        3.3.3  本书中的分解   101
        3.4  命名   101
        3.4.1  选择恰当的名称   101
        3.4.2  命名约定   102
        3.5  使用具有风格的语言特性   103
        3.5.1  使用常量   104
        3.5.2  使用引用代替指针   104
        3.5.3  使用自定义异常   104
        3.6  格式   105
        3.6.1  关于大括号对齐的争论   105
        3.6.2  关于空格和圆括号的争论   106
        3.6.3  空格、制表符、换行符   106
        3.7  风格的挑战   107
        3.8  本章小结   107
        3.9  练习   107
        第II部分  专业的C++软件设计
        第4章  设计专业的C++程序   113
        4.1  程序设计概述   113
        4.2  程序设计的重要性   114
        4.3  C++设计   116
        4.4  C++设计的两个原则   116
        4.4.1  抽象   116
        4.4.2  重用   118
        4.5  重用现有代码   119
        4.5.1  关于术语的说明   119
        4.5.2  决定是否重用代码   120
        4.5.3  重用代码的指导原则   121
        4.6  设计一个国际象棋程序   127
        4.6.1  需求   127
        4.6.2  设计步骤   127
        4.7  本章小结   132
        4.8  练习   133
        第5章  面向对象设计   135
        5.1  过程化的思考方式   135
        5.2  面向对象思想   136
        5.2.1  类   136
        5.2.2  组件   136
        5.2.3  属性   136
        5.2.4  行为   137
        5.2.5  综合考虑   137
        5.3  生活在类的世界里   138
        5.3.1  过度使用类   138
        5.3.2  过于通用的类   139
        5.4  类之间的关系   139
        5.4.1  “有一个”关系   139
        5.4.2  “是一个”关系(继承)   140
        5.4.3  “有一个”与“是一个”的
        区别   142
        5.4.4  not-a关系   144
        5.4.5  层次结构   145
        5.4.6  多重继承   146
        5.4.7  混入类   147
        5.5  本章小结   147
        5.6  练习   148
        第6章  设计可重用代码   149
        6.1  重用哲学   149
        6.2  如何设计可重用代码   150
        6.2.1  使用抽象   150
        6.2.2  构建理想的重用代码   151
        6.2.3  设计有用的接口   157
        6.2.4  设计成功的抽象   162
        6.2.5  SOLID原则   162
        6.3  本章小结   163
        6.4  练习   163
        第III部分  C++编码方法
        第7章  内存管理   167
        7.1  使用动态内存   167
        7.1.1  如何描绘内存   168
        7.1.2  分配和释放   169
        7.1.3  数组   170
        7.1.4  使用指针   177
        7.2  数组-指针的对偶性   178
        7.2.1  数组就是指针   178
        7.2.2  并非所有指针都是数组   180
        7.3  底层内存操作   180
        7.3.1  指针运算   180
        7.3.2  自定义内存管理   181
        7.3.3  垃圾回收   181
        7.3.4  对象池   182
        7.4  常见的内存陷阱   182
        7.4.1  数据缓冲区分配不足以及
        内存访问越界   182
        7.4.2  内存泄漏   183
        7.4.3  双重释放和无效指针   186
        7.5  智能指针   186
        7.5.1  unique_ptr   187
        7.5.2  shared_ptr   190
        7.5.3  weak_ptr   193
        7.5.4  向函数传递参数   193
        7.5.5  从函数中返回   194
        7.5.6  enable_shared_from_this   194
        7.5.7  过时的、移除的auto_ptr   195
        7.6  本章小结   195
        7.7  练习   195
        第8章  类和对象   197
        8.1  电子表格示例介绍   197
        8.2  编写类   198
        8.2.1  类定义   198
        8.2.2  定义方法   200
        8.2.3  使用对象   203
        8.3  对象的生命周期   205
        8.3.1  创建对象   205
        8.3.2  销毁对象   219
        8.3.3  对象赋值   220
        8.3.4  编译器生成的拷贝构造函数和
        拷贝赋值运算符   223
        8.3.5  复制和赋值的区别   223
        8.4  本章小结   224
        8.5  练习   225
        第9章  精通类和对象   227
        9.1  友元   227
        9.2  对象中的动态内存分配   228
        9.2.1  Spreadsheet类   228
        9.2.2  使用析构函数释放内存   231
        9.2.3  处理复制和赋值   231
        9.2.4  使用移动语义处理移动   237
        9.2.5  零规则   246
        9.3  与方法有关的更多内容   246
        9.3.1  static方法   246
        9.3.2  const方法   247
        9.3.3  方法重载   248
        9.3.4  内联方法   251
        9.3.5  默认参数   252
        9.4  不同的数据成员类型   252
        9.4.1  静态数据成员   253
        9.4.2  const static数据成员   254
        9.4.3  引用数据成员   255
        9.5  嵌套类   256
        9.6  类内的枚举类型   257
        9.7  运算符重载   258
        9.7.1  示例：为SpreadsheetCell
        实现加法   258
        9.7.2  重载算术运算符   261
        9.7.3  重载比较运算符   262
        9.7.4  创建具有运算符重载的类型   266
        9.8  创建稳定的接口   266
        9.9  本章小结   270
        9.10  练习   270
        第10章  揭秘继承技术   271
        10.1  使用继承构建类   271
        10.1.1  扩展类   272
        10.1.2  重写方法   275
        10.2  使用继承重用代码   282
        10.2.1  WeatherPrediction类   282
        10.2.2  在派生类中添加功能   283
        10.2.3  在派生类中替换功能   284
        10.3  利用父类   285
        10.3.1  父类构造函数   285
        10.3.2  父类的析构函数   286
        10.3.3  使用父类方法   287
        10.3.4  向上转型和向下转型   289
        10.4  继承与多态性   290
        10.4.1  回到电子表格   290
        10.4.2  设计多态性的电子表格
        单元格   291
        10.4.3  SpreadsheetCell基类   291
        10.4.4  独立的派生类   293
        10.4.5  利用多态性   294
        10.4.6  考虑将来   295
        10.5  多重继承   296
        10.5.1  从多个类继承   296
        10.5.2  名称冲突和歧义基类   297
        10.6  有趣而晦涩的继承问题   300
        10.6.1  修改重写方法的返回类型   300
        10.6.2  派生类中添加虚基类方法的
        重载   301
        10.6.3  继承的构造函数   302
        10.6.4  重写方法时的特殊情况   306
        10.6.5  派生类中的复制构造函数和
        赋值运算符   312
        10.6.6  运行期类型工具   313
        10.6.7  非public继承   314
        10.6.8  虚基类   315
        10.7  类型转换   316
        10.7.1  static_cast()   316
        10.7.2  reinterpret_cast()   317
        10.7.3  std::bit_cast()   318
        10.7.4  dynamic_cast()   318
        10.7.5  类型转换小结   319
        10.8  本章小结   319
        10.9  练习   320
        第11章  零碎的工作   321
        11.1  模块   321
        11.1.1  模块接口文件   322
        11.1.2  模块实现文件   324
        11.1.3  从实现中分离接口   325
        11.1.4  可见性和可访问性   326
        11.1.5  子模块   326
        11.1.6  模块划分   327
        11.1.7  头文件单元   329
        11.2  头文件   330
        11.2.1  重复定义   330
        11.2.2  循环依赖   330
        11.2.3  查询头文件是否存在   331
        11.3  核心语言特性的特性测试宏   331
        11.4  STATIC关键字   332
        11.4.1  静态数据成员和方法   332
        11.4.2  静态链接   332
        11.4.3  函数中的静态变量   334
        11.4.4  非局部变量的初始化顺序   335
        11.4.5  非局部变量的销毁顺序   335
        11.5  C的实用工具   335
        11.5.1  变长参数列表   336
        11.5.2  预处理器宏   337
        11.6  本章小结   338
        11.7  练习   338
        第12章  利用模板编写泛型代码   341
        12.1  模板概述   341
        12.2  类模板   342
        12.2.1  编写类模板   342
        12.2.2  编译器处理模板的原理   349
        12.2.3  将模板代码分布到多个
        文件中   350
        12.2.4  模板参数   351
        12.2.5  方法模板   355
        12.2.6  类模板的特化   359
        12.2.7  从类模板派生   361
        12.2.8  继承还是特化   362
        12.2.9  模板别名   362
        12.3  函数模板   363
        12.3.1  函数模板的重载   364
        12.3.2  类模板的友元函数模板   365
        12.3.3  对模板参数推导的更多介绍   366
        12.3.4  函数模板的返回类型   367
        12.4  简化函数模板的语法   368
        12.5  变量模板   369
        12.6  概念   369
        12.6.1  语法   369
        12.6.2  约束表达式   370
        12.6.3  预定义的标准概念   372
        12.6.4  类型约束的auto   372
        12.6.5  类型约束和函数模板   373
        12.6.6  类型约束和类模板   375
        12.6.7  类型约束和类方法   375
        12.6.8  类型约束和模板特化   376
        12.7  本章小结   376
        12.8  练习   377
        第13章  C++ I/O揭秘   379
        13.1  使用流   379
        13.1.1  流的含义   380
        13.1.2  流的来源和目的地   381
        13.1.3  流式输出   381
        13.1.4  流式输入   386
        13.1.5  对象的输入输出   392
        13.1.6  自定义的操作算子   393
        13.2  字符串流   393
        13.3  文件流   394
        13.3.1  文本模式与二进制模式   395
        13.3.2  通过seek()和tell()在文件中
        转移   395
        13.3.3  将流链接在一起   397
        13.4  双向I/O   398
        13.5  文件系统支持库   399
        13.5.1  路径   399
        13.5.2  目录条目   401
        13.5.3  辅助函数   401
        13.5.4  目录遍历   401
        13.6  本章小结   402
        13.7  练习   403
        第14章  错误处理   405
        14.1  错误与异常   405
        14.1.1  异常的含义   405
        14.1.2  C++中异常的优点   406
        14.1.3  建议   407
        14.2  异常机制   407
        14.2.1  抛出和捕获异常   408
        14.2.2  异常类型   410
        14.2.3  按const引用捕获异常对象   411
        14.2.4  抛出并捕获多个异常   411
        14.2.5  未捕获的异常   414
        14.2.6  noexcept说明符   415
        14.2.7  noexcept(expression)说明符   415
        14.2.8  noexcept(expression)运算符   415
        14.2.9  抛出列表   416
        14.3  异常与多态性   416
        14.3.1  标准异常层次结构   416
        14.3.2  在类层次结构中捕获异常   418
        14.3.3  编写自己的异常类   419
        14.3.4  源码位置   421
        14.3.5  日志记录的源码位置   422
        14.3.6  异常的源码位置   422
        14.3.7  嵌套异常   423
        14.4 重新抛出异常   425
        14.5  堆栈的释放与清理   426
        14.5.1  使用智能指针   427
        14.5.2  捕获、清理并重新抛出   428
        14.6  常见的错误处理问题   428
        14.6.1  内存分配错误   428
        14.6.2  构造函数中的错误   430
        14.6.3  构造函数的function-try-blocks   432
        14.6.4  析构函数中的错误   435
        14.7  本章小结   435
        14.8  练习   435
        第15章  C++运算符重载   437
        15.1  运算符重载概述   437
        15.1.1  重载运算符的原因   438
        15.1.2  运算符重载的限制   438
        15.1.3  运算符重载的选择   438
        15.1.4  不应重载的运算符   440
        15.1.5  可重载运算符小结   440
        15.1.6  右值引用   443
        15.1.7  优先级和结合性   444
        15.1.8  关系运算符   444
        15.2  重载算术运算符   445
        15.2.1  重载一元负号和一元正号
        运算符   445
        15.2.2  重载递增和递减运算符   446
        15.3  重载按位运算符和二元逻辑
        运算符   446
        15.4  重载插入运算符和提取运算符   447
        15.5  重载下标运算符   448
        15.5.1  通过operator[]提供只读访问   451
        15.5.2  非整数数组索引   452
        15.6  重载函数调用运算符   452
        15.7  重载解除引用运算符   453
        15.7.1  实现operator*   454
        15.7.2  实现operator->   455
        15.7.3  operator.*和operator ->*的
        含义   455
        15.8  编写转换运算符   456
        15.8.1  auto运算符   456
        15.8.2  使用显式转换运算符解决
        多义性问题   457
        15.8.3  用于布尔表达式的转换   457
        15.9  重载内存分配和内存释放
        运算符   459
        15.9.1  new和delete的工作原理   459
        15.9.2  重载operator new和
        operator delete   461
        15.9.3  显式地删除/默认化operator new
        和operator delete   463
        15.9.4  重载带有额外参数的operator new
        和operator delete   463
        15.9.5  重载带有内存大小参数的
        operator delete   464
        15.9.6  重载用户定义的字面量
        运算符   464
        15.9.7  cooked模式字面量运算符   465
        15.9.8  raw模式字面量运算符   465
        15.9.9  标准用户定义的字面量   466
        15.10  本章小结   466
        15.11  练习   466
        第16章  C++标准库概述   469
        16.1  编码原则   470
        16.1.1  使用模板   470
        16.1.2  使用运算符重载   470
        16.2  C++标准库概述   470
        16.2.1  字符串   470
        16.2.2  正则表达式   471
        16.2.3  I/O流   471
        16.2.4  智能指针   471
        16.2.5  异常   471
        16.2.6  数学工具   472
        16.2.7  时间和日期工具   473
        16.2.8  随机数   473
        16.2.9  初始化列表   474
        16.2.10  Pair和Tuple   474
        16.2.11  词汇类型   474
        16.2.12  函数对象   474
        16.2.13  文件系统   474
        16.2.14  多线程   475
        16.2.15  类型萃取   475
        16.2.16  标准整数类型   475
        16.2.17  标准库特性测试宏   475
        16.2.18  <version>   476
        16.2.19  源位置   476
        16.2.20  容器   476
        16.2.21  算法   482
        16.2.22  范围库   488
        16.2.23  标准库中还缺什么   488
        16.3  本章小结   489
        16.4  练习   489
        第17章  理解迭代器与范围库   491
        17.1  迭代器   491
        17.1.1  获取容器的迭代器   494
        17.1.2  迭代器萃取   495
        17.1.3  示例   495
        17.2  流迭代器   496
        17.2.1  输出流迭代器   497
        17.2.2  输入流迭代器   497
        17.3  迭代器适配器   498
        17.3.1  插入迭代器   498
        17.3.2  逆向迭代器   499
        17.3.3  移动迭代器   500
        17.4  范围   502
        17.4.1  基于范围的算法   502
        17.4.2  视图   504
        17.4.3  范围工厂   508
        17.5  本章小结   509
        17.6  练习   509
        第18章  标准库容器   511
        18.1  容器概述   511
        18.1.1  对元素的要求   512
        18.1.2  异常和错误检查   513
        18.2  顺序容器   514
        18.2.1  vector   514
        18.2.2  vector<bool>特化   531
        18.2.3  deque   532
        18.2.4  list   532
        18.2.5  forward_list   535
        18.2.6  array   537
        18.2.7  span   538
        18.3  容器适配器   540
        18.3.1  queue   540
        18.3.2  priority_queue   542
        18.3.3  stack   545
        18.4  有序关联容器   545
        18.4.1  pair工具类   545
        18.4.2  map   546
        18.4.3  multimap   554
        18.4.4  set   556
        18.4.5  multiset   558
        18.5  无序关联容器/哈希表   558
        18.5.1  哈希函数   559
        18.5.2  unordered_map   560
        18.5.3  unordered_multimap   563
        18.5.4  unordered_set/
        unordered_multiset   564
        18.6  其他容器   564
        18.6.1  标准C风格数组   564
        18.6.2  string   565
        18.6.3  流   566
        18.6.4  bitset   566
        18.7  本章小结   570
        18.8  练习   570
        第19章  函数指针，函数对象，lambda
        表达式   571
        19.1  函数指针   571
        19.2  指向方法(和数据成员)的指针   573
        19.3  函数对象   576
        19.3.1  编写第一个函数对象   576
        19.3.2  标准库中的函数对象   576
        19.4  lambda表达式   582
        19.4.1  语法   583
        19.4.2  lambda表达式作为参数   587
        19.4.3  泛型lambda表达式   587
        19.4.4  lambda捕获表达式   587
        19.4.5  模板化lambda表达式   588
        19.4.6  lambda表达式作为返回类型   589
        19.4.7  未计算上下文中的lambda
        表达式   589
        19.4.8  默认构造、拷贝和赋值   589
        19.5  调用   590
        19.6  本章小结   590
        19.7  练习   590
        第20章  掌握标准库算法   593
        20.1  算法概述   593
        20.1.1  find()和find_if()算法   594
        20.1.2  accumulate()算法   596
        20.1.3  在算法中使用移动语义   597
        20.1.4  算法回调   597
        20.2  算法详解   598
        20.2.1  非修改序列算法   598
        20.2.2  修改序列算法   603
        20.2.3  操作算法   611
        20.2.4  分区算法   613
        20.2.5  排序算法   614
        20.2.6  二分查找算法   615
        20.2.7  集合算法   616
        20.2.8  最小/最大算法   618
        20.2.9  并行算法   619
        20.2.10  约束算法   620
        20.2.11  数值处理算法   621
        20.3  本章小结   622
        20.4  练习   622
        第21章  字符串的本地化与正则表达式   625
        21.1  本地化   625
        21.1.1  宽字符   625
        21.1.2  本地化字符串字面量   626
        21.1.3  非西方字符集   626
        21.1.4  locale和facet   628
        21.1.5  转换   631
        21.2  正则表达式   632
        21.2.1  ECMAScript语法   632
        21.2.2  regex库   637
        21.2.3  regex_match()   638
        21.2.4  regex_search()   640
        21.2.5  regex_iterator   641
        21.2.6  regex_token_iterator   642
        21.2.7  regex_replace()   644
        21.3  本章小结   646
        21.4  练习   646
        第22章  日期和时间工具   647
        22.1  编译期有理数   647
        22.2  持续时间   649
        22.3  时钟   653
        22.4  时间点   655
        22.5  日期   656
        22.6  时区   658
        22.7  本章小结   659
        22.8  练习   659
        第23章  随机数工具   661
        23.1  C风格随机数生成器   661
        23.1.1  随机数引擎   662
        23.1.2  随机数引擎适配器   663
        23.1.3  预定义的随机数引擎和
        引擎适配器   664
        23.1.4  生成随机数   664
        23.1.5  随机数分布   666
        23.2  本章小结   668
        23.3  练习   669
        第24章  其他库工具   671
        24.1  variant   671
        24.2  any   673
        24.3  元组   674
        24.3.1  分解元组   676
        24.3.2  串联   677
        24.3.3  比较   677
        24.3.4  make_from_tuple()   678
        24.3.5  apply()   678
        24.4  本章小结   678
        24.5  练习   678
        第IV部分  掌握C++的高级特性
        第25章  自定义和扩展标准库   683
        25.1  分配器   683
        25.2  扩展标准库   684
        25.2.1  扩展标准库的原因   685
        25.2.2  编写标准库算法   685
        25.2.3  编写标准库容器   686
        25.2.4  将directed_graph实现为
        标准库容器   696
        25.2.5  添加分配器支持   712
        25.2.6  改善graph_node   716
        25.2.7  附加的标准库类似功能   717
        25.2.8  进一步改善   719
        25.2.9  其他容器类型   719
        25.3  本章小结   720
        25.4  练习   720
        第26章  高级模板   721
        26.1  深入了解模板参数   721
        26.1.1  深入了解模板类型参数   721
        26.1.2  template template参数介绍   724
        26.1.3  深入了解非类型模板参数   725
        26.2  类模板部分特例化   727
        26.3  通过重载模拟函数部分特例化   730
        26.4  模板递归   731
        26.4.1  N维网格：初次尝试   731
        26.4.2  真正的N维网格   732
        26.5  可变参数模板   734
        26.5.1  类型安全的变长参数列表   734
        26.5.2  可变数目的混入类   736
        26.5.3  折叠表达式   737
        26.6  模板元编程   739
        26.6.1  编译时阶乘   739
        26.6.2  循环展开   740
        26.6.3  打印元组   741
        26.6.4  类型trait   744
        26.6.5  模板元编程结论   752
        26.7  本章小结   752
        26.8  练习   752
        第27章  C++多线程编程   753
        27.1  多线程编程概述   754
        27.1.1  争用条件   755
        27.1.2  撕裂   756
        27.1.3  死锁   756
        27.1.4  伪共享   757
        27.2  线程   757
        27.2.1  通过函数指针创建线程   758
        27.2.2  通过函数对象创建线程   759
        27.2.3  通过lambda创建线程   760
        27.2.4  通过成员函数创建线程   760
        27.2.5  线程本地存储   761
        27.2.6  取消线程   761
        27.2.7  自动join线程   761
        27.2.8  从线程获得结果   762
        27.2.9  复制和重新抛出异常   762
        27.3  原子操作库   764
        27.3.1  原子操作   766
        27.3.2  原子智能指针   767
        27.3.3  原子引用   767
        27.3.4  使用原子类型   767
        27.3.5  等待原子变量   769
        27.4  互斥   770
        27.4.1  互斥体类   770
        27.4.2  锁   772
        27.4.3  std::call_once   774
        27.4.4  互斥体对象的用法示例   776
        27.5  条件变量   779
        27.5.1  虚假唤醒   780
        27.5.2  使用条件变量   780
        27.6  latch   781
        27.7  barrier   782
        27.8  semaphore   782
        27.9  future   783
        27.9.1  std::promise和std::future   784
        27.9.2  std::packaged_task   784
        27.9.3  std::async   785
        27.9.4  异常处理   786
        27.9.5  std::shared_future   786
        27.10  示例：多线程的Logger类   787
        27.11  线程池   791
        27.12  协程   792
        27.13  线程设计和最佳实践   793
        27.14  本章小结   794
        27.15  练习   794
        第V部分  C++软件工程
        第28章  充分利用软件工程方法   799
        28.1  过程的必要性   799
        28.2  软件生命周期模型   800
        28.2.1  瀑布模型   800
        28.2.2  生鱼片模型   802
        28.2.3  螺旋类模型   802
        28.2.4  敏捷   804
        28.3  软件工程方法论   805
        28.3.1  UP   805
        28.3.2  RUP   806
        28.3.3  Scrum   806
        28.3.4  极限编程   808
        28.3.5  软件分流   812
        28.4  构建自己的过程和方法   812
        28.4.1  对新思想采取开放态度   812
        28.4.2  提出新想法   812
        28.4.3  知道什么行得通、什么行不通   812
        28.4.4  不要逃避   813
        28.5  源代码控制   813
        28.6  本章小结   814
        28.7  练习   814
        第29章  编写高效的C++程序   817
        29.1  性能和效率概述   817
        29.1.1  提升效率的两种方式   818
        29.1.2  两种程序   818
        29.1.3  C++是不是低效的语言   818
        29.2  语言层次的效率   818
        29.2.1  高效地操纵对象   819
        29.2.2  预分配内存   823
        29.2.3  使用内联方法和函数   823
        29.3  设计层次的效率   823
        29.3.1  尽可能多地缓存   823
        29.3.2  使用对象池   824
        29.4  剖析   829
        29.4.1  使用gprof的剖析示例   829
        29.4.2  使用Visual C++ 2019的剖析示例   836
        29.5  本章小结   838
        29.6  练习   838
        第30章  熟练掌握测试技术   841
        30.1  质量控制   841
        30.1.1  谁负责测试   842
        30.1.2  bug的生命周期   842
        30.1.3  bug跟踪工具   843
        30.2  单元测试   844
        30.2.1  单元测试方法   844
        30.2.2  单元测试过程   845
        30.2.3  实际中的单元测试   848
        30.3  模糊测试   855
        30.4  高级测试   855
        30.4.1  集成测试   855
        30.4.2  系统测试   856
        30.4.3  回归测试   857
        30.5  用于成功测试的建议   857
        30.6  本章小结   858
        30.7  练习   858
        第31章  熟练掌握调试技术   859
        31.1  调试的基本定律   859
        31.2  bug分类学   860
        31.3  避免bug   860
        31.4  为bug做好规划   861
        31.4.1  错误日志   861
        31.4.2  调试跟踪   862
        31.4.3  断言   869
        31.4.4  崩溃转储   870
        31.5  调试技术   870
        31.5.1  重现bug   870
        31.5.2  调试可重复的bug   871
        31.5.3  调试不可重现的bug   871
        31.5.4  调试退化   872
        31.5.5  调试内存问题   872
        31.5.6  调试多线程程序   876
        31.5.7  调试示例：文章引用   876
        31.5.8  从ArticleCitations示例中总结出的教训   887
        31.6  本章小结   887
        31.7  练习   887
        第32章  使用设计技术和框架   889
        32.1  容易忘记的语法   890
        32.1.1  编写类   890
        32.1.2  派生类   891
        32.1.3  编写lambda表达式   892
        32.1.4  使用“复制和交换”惯用语法   892
        32.1.5  抛出和捕捉异常   893
        32.1.6  写入文件   894
        32.1.7  读取文件   894
        32.1.8  写入类模板   895
        32.1.9  约束模板参数   895
        32.2  始终存在更好的方法   896
        32.2.1  RAII   896
        32.2.2  双分派   898
        32.2.3  混入类   902
        32.3  面向对象的框架   904
        32.3.1  使用框架   904
        32.3.2  MVC范型   905
        32.4  本章小结   906
        32.5  练习   906
        第33章  应用设计模式   907
        33.1  依赖注入   908
        33.1.1  示例：日志机制   908
        33.1.2  依赖注入logger的实现   908
        33.1.3  使用依赖注入   909
        33.2  抽象工厂模式   910
        33.2.1  示例：模拟汽车工厂   910
        33.2.2  实现抽象工厂   911
        33.2.3  使用抽象工厂   912
        33.3  工厂方法模式   913
        33.3.1  示例：模拟第二个汽车工厂   913
        33.3.2  实现工厂   914
        33.3.3  使用工厂   915
        33.3.4  工厂的其他类型   917
        33.3.5  工厂的其他用法   917
        33.4  适配器模式   918
        33.4.1  示例：适配Logger类   918
        33.4.2  实现适配器   919
        33.4.3  使用适配器   920
        33.5  代理模式   920
        33.5.1  示例：隐藏网络连接问题   920
        33.5.2  实现代理   921
        33.5.3  使用代理   922
        33.6  迭代器模式   922
        33.7  观察者模式   923
        33.7.1  示例：从主题中暴露事件   923
        33.7.2  实现观察者   923
        33.7.3  使用观察者   924
        33.8  装饰器模式   925
        33.8.1  示例：在网页中定义样式   926
        33.8.2  装饰器的实现   926
        33.8.3  使用装饰器   927
        33.9  责任链模式   928
        33.9.1  示例：事件处理   928
        33.9.2  实现责任链   928
        33.9.3  使用责任链   929
        33.10  单例模式   930
        33.10.1  日志记录机制   931
        33.10.2  实现单例   931
        33.10.3  使用单例   933
        33.11  本章小结   933
        33.12  练习   933
        第34章  开发跨平台和跨语言的应用程序   935
        34.1  跨平台开发   935
        34.1.1  架构问题   935
        34.1.2  实现问题   938
        34.1.3  平台专用功能   940
        34.2  跨语言开发   940
        34.2.1  混用C和C++   941
        34.2.2  改变范型   941
        34.2.3  链接C代码   944
        34.2.4  从C#调用C++代码   946
        34.2.5  C++/CLI在C++中使用C#代码和在C#中使用C++代码   947
        34.2.6  在Java中使用JNI调用C++代码   948
        34.2.7  从C++代码调用脚本   950
        34.2.8  从脚本调用C++代码   950
        34.2.9  从C++调用汇编代码   952
        34.3  本章小结   953
        34.4  练习   953
        第VI部分  附录
        附录A  C++面试   957
        在线资源(扫描封底二维码下载)
        附录B  标准库头文件   977
        附录C  UML简介   983
        附录D  带注解的参考文献   989
     · · · · · ·     (收起)"
30329536,数据密集型应用系统设计,9.7,(1709人评价),Martin Kleppmann / 赵军平、李三平、吕云松、耿煜 / 中国电力出版社 / 2018-9-1 / 128,"全书分为三大部分：
第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以...",https://book.douban.com/subject/30329536/,https://img1.doubanio.com/view/subject/s/public/s34186559.jpg,128,9787519821968,"全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方...(展开全部)





全书分为三大部分： 第一部分，主要讨论有关增强数据密集型应用系统所需的若干基本原则。首先开篇第1章即瞄准目标：可靠性、可扩展性与可维护性，如何认识这些问题以及如何达成目标。第2章我们比较了多种不同的数据模型和查询语言，讨论各自的适用场景。接下来第3章主要针对存储引擎，即数据库是如何安排磁盘结构从而提高检索效率。第4章转向数据编码（序列化）方面，包括常见模式的演化历程。 第二部分，我们将从单机的数据存储转向跨机器的分布式系统，这是扩展性的重要一步，但随之而来的是各种挑战。所以将依次讨论数据远程复制（第5章）、数据分区（第6章）以及事务（第7章）。接下来的第8章包括分布式系统的更多细节，以及分布式环境如何达成一致性与共识（第9章）。 第三部分，主要针对产生派生数据的系统，所谓派生数据主要指在异构系统中，如果无法用一个数据源来解决所有问题，那么一种自然的方式就是集成多个不同的数据库、缓存模块以及索引模块等。首先第10章以批处理开始来处理派生数据，紧接着第11章采用流式处理。第12章总结之前介绍的多种技术，并分析讨论未来构建可靠、可扩展和可维护应用系统可能的新方向或方法。","作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, ...(展开全部)




作者简介 Martin Kleppmann是英国剑桥大学分布式系统方向的研究员。此前，他曾是LinkedIn和Rapportive等互联网公司的软件工程师，负责大规模数据基础设施建设。在此过程中他遇到过一些困难，因此他希望这本书能够帮助读者避免重蹈覆辙。Martin还是一位活跃的会议演讲者、博主和开源贡献者。他认为，每个人都应该学习深刻的技术理念，对技术的深入理解能帮助我们开发出更好的软件。 译者简介 赵军平, 大数据存储与分析资深开发者与推广者（EMC 10余年），GPU异构计算的亲历者。中国计算机协会专家委员，DELL EMC资深架构师。12年系统研发、创新与团队管理经验，擅长数据存储与保护, 云计算与大数据实时分析，GPU异构加速优化等。相关领域已申请中、美技术专利100余项，并多次在SNIA，LinuxConf，Hadoop Summit, Nvidia GPU Tech Conf等做技术分享，持续关注数据密集和计算密集相关技术的演进、融合与赋能推广。 吕云松，北京大学计算机硕士，硕士及DELL EMC中国研究院实习期间专注于大数据实时流式处理相关的研究。现就职于华为2012中软院黎曼实验室，主要从事深度学习的研发。 耿煜，DELL EMC架构师兼GTM负责人，致力于推广企业级数字化转型方案。深耕分布式架构以及云计算12年，先后任职于ChinaCache，Sun Microsystems以及EMC等公司。 李三平，美国麻省大学计算机工程专业博士，DELL EMC中国研究院首席科学家，研究方向为机器学习、深度学习、智能运维、遥感影像等。已在IEEE Transactions期刊和会议上发表论文数十篇，申请美国专利20余项。推崇简约，热衷机器学习。","前言 .....................................................1
        第一部分 数据系统基础
        第1章 可靠、可扩展与可维护的应用系统 ................... 11
        认识数据系统 ...........................................12
        可靠性 ..................................................14
        可扩展性 ................................................18
        可维护性 ................................................25
        小结 .....................................................28
        第2章 数据模型与查询语言 ............................... 33
        关系模型与文档模型 .......................................34
        数据查询语言 ...........................................46
        图状数据模型 ......................................52
        小结 ...................................................65
        第3章 数据存储与检索 .................................. 71
        数据库核心：数据结构 ...................................72
        事务处理与分析处理 ...................................89
        列式存储 .........................................94
        小结 ..............................................101
        第4章 数据编码与演化 .............................. 109
        数据编码格式 .................................... 110
        数据流模式 ......................................124
        小结 .............................................134
        第二部分 分布式数据系统
        第5章 数据复制 ................................. 145
        主节点与从节点 ..................................146
        复制滞后问题 ......................................154
        多主节点复制 .......................................160
        无主节点复制 .....................................168
        小结 ..............................................181
        第6章 数据分区 ............................... 189
        数据分区与数据复制 .................................190
        键-值数据的分区 ...................................190
        分区与二级索引 ...................................195
        分区再平衡 ....................................198
        请求路由 ..................................202
        小结 .................................204
        第7章 事务 .............................. 211
        深入理解事务 ......................................212
        弱隔离级别 .................................221
        串行化 ...........................................237
        小结 ...........................................250
        第8章 分布式系统的挑战 ...................... 259
        故障与部分失效 ...............................260
        不可靠的网络 ..................................262
        不可靠的时钟 ..................................271
        知识，真相与谎言 ...............................282
        小结 ..........................................292
        第9章 一致性与共识 ..................... 303
        一致性保证 ....................................304
        可线性化 ........................................305
        顺序保证 ........................................319
        分布式事务与共识 .................................330
        小结 ...............................................349
        第三部分 派生数据
        第10章 批处理系统 ................................ 367
        使用UNIX工具进行批处理 .............................368
        MapReduce与分布式文件系统 .........................375
        超越MapReduce ....................................394
        小结 ............................................403
        第11章 流处理系统 .............................. 413
        发送事件流 .......................................414
        数据库与流 .......................................424
        流处理 .........................................435
        小结 ............................................449
        第12章 数据系统的未来 ............................ 461
        数据集成 .........................................461
        分拆数据库 .......................................469
        端到端的正确性 ....................................484
        做正确的事情 .......................................500
        小结 ..............................................509
        术语表 ............................................ 521
     · · · · · ·     (收起)"
35144587,Go专家编程,9.1,(128人评价),任洪彩 / 电子工业出版社 / 2020-7 / 108.00元,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松...,https://book.douban.com/subject/35144587/,https://img3.doubanio.com/view/subject/s/public/s33699643.jpg,108.00元,9787121365577,《Go专家编程》深入地讲解了Go语言常见特性的内部机制和实现方式，大部分内容源自对Go语言源码的分析，并从中提炼出实现原理。通过阅读本书，读者可以快速、轻松地了解Go语言的内部运作机制。 本书首先介绍Go语言常见的数据结构及控制结构的实现原理，包括管道、切片、Hash表、select和for-range等，这部分内容大都以几个精心准备的测验题目开头，每个测验题目均对应一个知识点，读者可以借此测验自身对该知识点的掌握程度。接着介绍了Go语言最基础的概念，包括协程的概念、协程调度模型、协程调度策略，以及内存分配和垃圾回收相关的内容。本书还介绍了一些标准库、异常处理和依赖管理等非语法相关但非常重要的内容。最后结合作者的见闻，整理了一些发生在真实项目中的编程陷阱。,任洪彩，华为云原生团队核心成员，开源爱好者，深度参与CNCF（云原生计算基金会）旗下Kubernetes、Prometheus等项目贡献，Kubernetes资深成员，担任Kubernetes SIG-Instrumentation Approver，敏捷软件思想深度实践者，在Nokia、华为等公司参与过多个大型项目的研发与重构，对Go、C/C++、Python、Swift等语言均有深入的研究与实践。,"第1章　常见数据结构的实现原理
        1.1　管道
        1.1.1　热身测验
        1.1.2　特性速览
        1.1.3　实现原理
        1.2　slice
        1.2.1　热身测验
        1.2.2　特性速览
        1.2.3　实现原理
        1.2.4　切片表达式
        1.3　map
        1.3.1　热身测验
        1.3.2　特性速览
        1.3.3　实现原理
        1.4　struct
        1.4.1　热身测验
        1.4.2　内嵌字段
        1.4.3　方法受体
        1.4.4　字段标签
        1.5　iota
        1.5.1　热身测验
        1.5.2　特性速览
        1.5.3　实现原理
        1.6　string
        1.6.1　热身测验
        1.6.2　特性速览
        1.6.3　实现原理
        第2章　控制结构
        2.1　select
        2.1.1　热身测验
        2.1.2　特性速览
        2.1.3　实现原理
        2.2　for-range
        2.2.1　热身测验
        2.2.2　特性速览
        2.2.3　实现原理
        第3章　协程
        3.1　协程的概念
        3.2　调度模型
        3.3　调度策略
        第4章　内存管理
        4.1　内存分配
        4.2　垃圾回收
        4.3　逃逸分析
        第5章　并发控制
        5.1　channel
        5.2　WaitGroup
        5.3　context
        5.4　Mutex
        5.5　RWMutex
        5.5.1　读写锁的数据结构
        5.5.2　场景分析
        第6章　反射
        6.1　热身测验
        6.2　接口
        6.3　反射定律
        第7章　测试
        7.1　快速开始
        7.1.1　单元测试
        7.1.2　基准测试
        7.1.3　示例测试
        7.2　进阶测试
        7.2.1　子测试
        7.2.2　Main测试
        7.3　实现原理
        7.3.1　testing.common
        7.3.2　testing.TB接口
        7.3.3　单元测试的实现原理
        7.3.4　性能测试的实现原理
        7.3.5　示例测试的实现原理
        7.3.6　Main测试的实现原理
        7.3.7　go test的工作机制
        7.4　扩展阅读
        7.4.1　测试参数
        7.4.2　benchstat
        第8章　异常处理
        8.1　error
        8.1.1　热身测验
        8.1.2　基础error
        8.1.3　链式error
        8.1.4　工程迁移
        8.2　defer
        8.2.1　热身测验
        8.2.2　约法三章
        8.2.3　实现原理
        8.2.4　性能优化
        8.3　panic
        8.3.1　热身测验
        8.3.2　工作机制
        8.3.3　源码剖析
        8.4　recover
        8.4.1　热身测验
        8.4.2　工作机制
        8.4.3　源码剖析
        第9章　定时器
        9.1　一次性定时器（Timer）
        9.1.1　快速开始
        9.1.2　实现原理
        9.2　周期性定时器（Ticker）
        9.2.1　快速开始
        9.2.2　实现原理
        9.3　runtimeTimer
        9.3.1　实现原理
        9.3.2　性能优化
        9.4　案例分享
        第10章　语法糖
        10.1　简短变量声明符
        10.1.1　热身测验
        10.1.2　规则
        10.2　可变参函数
        第11章　版本管理
        11.1　安装Go
        11.2　删除Go
        11.3　升级Go
        11.4　Go版本管理器
        11.4.1　快速开始
        11.4.2　工作机制
        11.4.3　小结
        11.5　源码编译
        11.5.1　源码下载
        11.5.2　源码编译过程
        第12章　Go语言依赖管理
        12.1　GOPATH
        12.1.1　GOROOT是什么
        12.1.2　GOPATH是什么
        12.1.3　依赖查找
        12.1.4　GOPATH的缺点
        12.2　vendor
        12.2.1　vendor目录位置
        12.2.2　搜索顺序
        12.2.3　vendor的不足
        12.3　Go Module
        12.3.1　Go Module基础
        12.3.2　快速实践
        12.3.3　replace指令
        12.3.4　exclude指令
        12.3.5　indirect指令
        12.3.6　版本选择机制
        12.3.7　incompatible
        12.3.8　伪版本
        12.3.9　依赖包存储
        12.3.10　go.sum
        12.3.11　模块代理
        12.3.12　GOSUMDB的工作机制
        12.3.13　GOSUMDB的实现原理
        12.3.14　第三方代理
        12.3.15　私有模块
        12.3.16　Go Module的演进
        第13章　编程陷阱
        13.1　切片扩容
        13.2　空切片
        13.3　append的本质
        13.4　循环变量引用
        13.5　协程引用循环变量
        13.6　recover失效
     · · · · · ·     (收起)"
25844633,实现领域驱动设计,8.4,(416人评价),Vaughn Vernon / 滕云 / 电子工业出版社 / 2014-3 / 99.00元,领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如...,https://book.douban.com/subject/25844633/,https://img1.doubanio.com/view/subject/s/public/s29544670.jpg,99.00元,9787121224485,"领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为...(展开全部)





领域驱动设计（DDD）是教我们如何做好软件的，同时也是教我们如何更好地使用面向对象技术的。它为我们提供了设计软件的全新视角，同时也给开发者留下了一大难题：如何将领域驱动设计付诸实践？Vaughn Vernon 的这本《实现领域驱动设计》为我们给出了全面的解答。 《实现领域驱动设计》分别从战略和战术层面详尽地讨论了如何实现DDD，其中包含了大量的最佳实践、设计准则和对一些问题的折中性讨论。《实现领域驱动设计》共分为14 章，在DDD 战略部分，《实现领域驱动设计》向我们讲解了领域、限界上下文、上下文映射图和架构等内容，战术部分包括实体、值对象、领域服务、领域事件、聚合和资源库等内容。一个虚构的案例研究贯穿全书，这对于实例讲解DDD 实现来说非常有用。 《实现领域驱动设计》在DDD 的思想和实现之间建立起了一座桥梁，架构师和程序员均可阅读，同时也可以作为一本DDD 参考书。",作者：Vaughn Vernon是一个经验丰富的软件工匠，在软件设计、开发和架构方面拥有超过25年的从业经验。他提倡通过创新来简化软件的设计和实现。从20世纪80年代开始，他便开始使用面向对象语言进行编程；在 20世纪 90年代早期，他便在领域建模中应用了领域驱动设计，那时他使用的是Smalltalk语言。他在很多业务领域都有从业经验，包括航空、环境、地理、保险、医学和电信等领域。同时，Vaughn在技术上也取得了很大的成功，包括开发可重用的框架和类库等。他在全球范围之内提供软件咨询和演讲，此外，他还在许多国家教授《实现领域驱动设计》的课程。你可以通过www.VaughnVernon.co访问到他的最新研究成果。他的Twitter：@VaughnVernon。,"序............... xix
        前言............. xxi
        致谢............ xxxi
        关于作者................... xxxv
        如何使用本书.........xxxvii
        第1章 DDD入门...............1
        我能DDD吗？..................2
        为什么我们需要DDD.............5
        如何DDD...................... 17
        使用DDD的业务价值..............22
        1.你获得了一个非常有用的领域模型................22
        2.你的业务得到了更准确的定义和理解............23
        3.领域专家可以为软件设计做出贡献...........23
        4.更好的用户体验....................23
        5.清晰的模型边界.....................24
        6.更好的企业架构..............24
        7.敏捷、迭代式和持续建模....................24
        8.使用战略和战术新工具........................24
        实施DDD所面临的挑战.....................25
        虚构的案例，真实的实践................... 33
        本章小结.........................36
        第2章 领域、子域和限界上下文.....................37
        总览....................... 37
        工作中的子域和限界上下文............................. 38
        将关注点放在核心域上............................. 42
        战略设计为什么重要.................... 45
        现实世界中领域和子域...................48
        理解限界上下文..................... 53
        限界上下文不仅仅只包含模型..................... 57
        限界上下文的大小...................... 59
        与技术组件保持一致................... 61
        示例上下文........................ 62
        协作上下文..................63
        身份与访问上下文..................69
        敏捷项目管理上下文................. 71
        本章小结....................................73
        第3章 上下文映射图............................75
        上下文映射图为什么重要........................ 75
        绘制上下文映射图......................77
        产品和组织关系........................79
        映射3个示例限界上下文........................82
        本章小结............................97
        第4章 架构.......................99
        采访一个成功的CIO.................... 100
        分层................................. 104
        依赖倒置原则.................... 107
        六边形架构（端口与适配器）..................... 110
        面向服务架构.......................114
        REST................................117
        REST作为一种架构风格...........................117
        RESTful HTTP服务器的关键方面 ........................................ 118
        RESTful HTTP客户端的关键方面 ........................................ 119
        REST和DDD..................... 120
        为什么是REST？......................... 121
        命令和查询职责分离——CQRS................. 121
        CQRS的各个方面........................ 123
        处理具有最终一致性的查询模型.................. 128
        事件驱动架构................... 129
        管道和过滤器..................... 131
        长时处理过程（也叫Saga）................... 134
        事件源...................... 140
        数据网织和基于网格的分布式计算....................... 143
        数据复制..................... 144
        事件驱动网织和领域事件.................. 145
        持续查询................... 145
        分布式处理...................... 146
        本章小结............................ 148
        第5章 实体......................... 149
        为什么使用实体......................... 149
        唯一标识............................ 151
        用户提供唯一标识......................... 152
        应用程序生成唯一标识........................... 153
        持久化机制生成唯一标识............................ 156
        另一个限界上下文提供唯一标识..................... 160
        标识生成时间..................... 161
        委派标识......................... 163
        标识稳定性.......................... 165
        发现实体及其本质特征............................. 167
        揭开实体及其本质特征的神秘面纱................. 168
        挖掘实体的关键行为.......................... 172
        角色和职责......................... 176
        创建实体......................... 181
        验证................................... 183
        跟踪变化............................ 192
        本章小结................................ 192
        第6章 值对象..................... 193
        值对象的特征.......................... 194
        度量或描述.......................... 195
        不变性........................... 195
        概念整体................................ 196
        可替换性.......................... 199
        值对象相等性..........................200
        无副作用行为............................. 201
        最小化集成..................204
        用值对象表示标准类型........................206
        测试值对象........................ 210
        实现.............................. 214
        持久化值对象................. 219
        拒绝由数据建模泄漏带来的不利影响..................220
        ORM与单个值对象................................ 221
        多个值对象序列化到单个列中.....................224
        使用数据库实体保存多个值对象....................225
        使用联合表保存多个值对象..........................229
        ORM与枚举状态对象........................................230
        本章小结....................... 233
        第7章 领域服务.................................235
        什么是领域服务（首先，什么不是领域服务）.................. 237
        请确定你是否需要一个领域服务................................ 238
        建模领域服务.................. 241
        独立接口有必要吗.............................244
        一个计算过程..........................246
        转换服务........................249
        为领域服务创建一个迷你层.........................250
        测试领域服务............................250
        本章小结.................. 253
        第8章 领域事件...............................255
        何时/为什么使用领域事件.......................... 255
        建模领域事件.................... 258
        创建具有聚合特征的领域事件................... 263
        身份标识............................264
        从领域模型中发布领域事件.............................. 265
        发送方................... 265
        订阅方.....................269
        向远程限界上下文发布领域事件............................. 271
        消息设施的一致性........................... 271
        自治服务和系统............................. 272
        容许时延.................. 273
        事件存储.................. 274
        转发存储事件的架构风格........................... 279
        以REST资源的方式发布事件通知....................... 279
        通过消息中间件发布事件通知.................. 283
        实现............................284
        发布NotificationLog............... 285
        发布基于消息的事件通知..............................290
        本章小结........................297
        第9章 模块................................299
        通过模块完成设计..................................299
        模块的基本命名规范..........................302
        领域模型的命名规范...........................302
        敏捷项目管理上下文中的模块..............................305
        其他层中的模块..................308
        先考虑模块，再是限界上下文...............................309
        本章小结......................... 310
        第10章 聚合...................... 311
        在Scrum核心领域中使用聚合........................ 312
        第一次尝试：臃肿的聚合....................... 313
        第二次尝试：多个聚合........................... 314
        原则：在一致性边界之内建模真正的不变条件................317
        原则：设计小聚合............................. 319
        不要相信每一个用例............................ 321
        原则：通过唯一标识引用其他聚合......................... 322
        通过标识引用使多个聚合协同工作 ...................................... 324
        建模对象导航性............................ 325
        可伸缩性和分布式............................. 326
        原则：在边界之外使用最终一致性............................. 327
        谁的任务？............................ 328
        打破原则的理由......................... 329
        理由之一：方便用户界面................................. 329
        理由之二：缺乏技术机制............................. 330
        理由之三：全局事务.......................................... 331
        理由之四：查询性能.................................. 331
        遵循原则.................... 332
        通过发现，深入理解............................... 332
        重新思考设计............................... 332
        估算聚合成本............................. 334
        常见用例场景........................ 335
        内存消耗............................ 336
        探索另外的设计................................... 337
        实现最终一致性.............................. 338
        这是Scrum团队成员的任务吗？......................... 339
        决定的时候到了.............................. 341
        实现........................................ 341
        创建具有唯一标识的根实体........................ 342
        优先使用值对象...................... 343
        使用迪米特法则和“告诉而非询问”原则 ...............344
        乐观并发...............346
        避免依赖注入................348
        本章小结................................ 349
        第11章 工厂................. 351
        领域模型中的工厂................. 351
        聚合根中的工厂方法............................. 352
        创建CalendarEntry实例................... 353
        创建Discussion实例............................ 357
        领域服务中的工厂.......................... 358
        本章小结.......................... 361
        第12章 资源库...........................363
        面向集合资源库...........................364
        Hibernate实现...................... 369
        TopLink实现.................... 377
        面向持久化资源库........................ 379
        Coherence实现............................ 381
        MongoDB实现......................... 386
        额外的行为...................................... 391
        管理事务................................. 393
        警告................................. 397
        类型层级............................... 397
        资源库 vs 数据访问对象（DAO）..............................400
        测试资源库.......................................... 401
        以内存实现进行测试...................404
        本章小结................................407
        第13章 集成限界上下文...............................409
        集成基础知识....................................409
        分布式系统之间存在根本性区别.......................411
        跨系统边界交换信息...............................411
        通过REST资源集成限界上下文......................... 417
        实现REST资源.......................... 418
        使用防腐层实现REST客户端........... 421
        通过消息集成限界上下文................ 428
        从Scrum的产品负责人和团队成员处得到持续通知 .................... 428
        你能处理这样的职责吗？..................... 434
        长时处理过程，以及避免职责............. 439
        长时处理过程的状态机和超时跟踪器 .................................. 450
        设计一个更复杂的长时处理过程 ..........................................460
        当消息机制或你的系统不可用时 ...........................................464
        本章小结.................................465
        第14章 应用程序..................467
        用户界面...................................469
        渲染领域对象............. 470
        渲染数据传输对象................... 471
        使用调停者发布聚合的内部状态 .......................................... 471
        通过领域负载对象渲染聚合实例 .......................................... 472
        聚合实例的状态展现............................. 473
        用例优化资源库查询...................... 474
        处理不同类型的客户端................... 474
        渲染适配器以及处理用户编辑............. 475
        应用服务 ............................................ 478
        示例应用服务 ................................ 478
        解耦服务输出 .....................485
        组合多个限界上下文 .....................487
        基础设施 ...............................489
        企业组件容器 ....................490
        本章小结 ....................494
        附录A 聚合与事件源：A+ES ..........................495
        应用服务内部 ....................... 496
        命令处理器 .....................505
        Lambda语法...................508
        并发控制 ....................... 510
        A+ES所带来的结构自由性 .............. 513
        性能 ............................ 513
        实现事件存储 ..................... 516
        关系型持久化 .................. 520
        BLOB持久化 ...................... 522
        专注的聚合 ............................ 523
        读模型投射 ........................... 524
        与聚合设计一道使用 ................ 527
        增强事件 ........................... 527
        工具和模式 ................... 529
        事件序列器 .......... 530
        事件不变性 ................ 531
        值对象 ..................... 531
        协议生成 .................... 534
        单元测试和需求规范 .............. 535
        事件源和函数式语言 .......... 536
        参考文献 ..................539
     · · · · · ·     (收起)"
30333919,架构整洁之道,8.7,(858人评价),【美】Robert C. Martin（罗伯特 C. 马丁） / 电子工业出版社 / 2018-9 / 99.00元,《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过...,https://book.douban.com/subject/30333919/,https://img9.doubanio.com/view/subject/s/public/s29943454.jpg,99.00元,9787121347962,"《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构...(展开全部)





《架构整洁之道》是创造“Clean神话”的Bob大叔在架构领域的登峰之作，围绕“架构整洁”这一重要导向，系统地剖析其缘起、内涵及应用场景，涵盖软件研发完整过程及所有核心架构模式。《架构整洁之道》分为6部分，第1部分纲领性地提出软件架构设计的终极目标，描述软件架构设计的重点与模式；第2~4部分从软件开发中三个基础编程范式的定义和特征出发，进一步描述函数、组件、服务设计与实现的定律，以及它们是如何有效构建软件系统的整体架构的；第5部分从整洁架构的定义开始，详细阐述软件架构设计过程中涉及的方方面面，包括划分内部组件边界、应用常见设计模式、避开错误、降低成本、处理特殊情况等，并以实战案例将内容有机整合起来；第6部分讲述具体实现细节；附录则透过作者数十年的软件从业经历再次印证《架构整洁之道》的观点。 对于每一位软件研发从业人员——无论从事的是具体编码实现、架构设计，还是软件研发管理，《架构整洁之道》都是不可或缺的。","Robert C·Martin
作者","第1部分  概述
        第1章  设计与架构究竟是什么  3
        目标是什么  4
        案例分析  5
        本章小结  11
        第2章  两个价值维度  12
        行为价值  13
        架构价值  13
        哪个价值维度更重要  14
        艾森豪威尔矩阵  15
        为好的软件架构而持续斗争  16
        第2部分  从基础构件开始：编程范式
        第3章  编程范式总览  21
        结构化编程  22
        面向对象编程  22
        函数式编程  23
        仅供思考  23
        本章小结  24
        第4章  结构化编程  25
        可推导性  26
        goto是有害的  28
        功能性降解拆分  29
        形式化证明没有发生  29
        科学来救场  29
        测试  30
        本章小结  31
        第5章  面向对象编程  32
        封装  33
        继承  36
        多态  38
        本章小结  44
        第6章  函数式编程  45
        整数平方  46
        不可变性与软件架构  47
        可变性的隔离  48
        事件溯源  49
        本章小结  51
        第3部分  设计原则
        第7章  SRP：单一职责原则  56
        反面案例2：代码合并  59
        解决方案  60
        本章小结  61
        第8章  OCP：开闭原则  62
        思想实验  63
        依赖方向的控制  67
        信息隐藏  67
        本章小结  67
        第9章  LSP：里氏替换原则  68
        继承的使用指导  69
        正方形/长方形问题  70
        LSP与软件架构  70
        违反LSP的案例  71
        本章小结  73
        第10章 ISP：接口隔离原则  74
        ISP与编程语言  76
        ISP与软件架构  76
        本章小结  77
        第11章 DIP：依赖反转原则  78
        稳定的抽象层  79
        工厂模式  80
        具体实现组件  82
        本章小结  82
        第4部分  组件构建原则
        第12章 组件  84
        组件发展史  85
        重定位技术  88
        链接器  88
        本章小结  90
        第13章 组件聚合  91
        复用/发布等同原则  92
        共同闭包原则  93
        共同复用原则  94
        组件聚合张力图  95
        本章小结  97
        第14章 组件耦合  98
        无依赖环原则  99
        自上而下的设计  105
        稳定依赖原则  106
        稳定抽象原则  112
        本章小结  117
        第5部分  软件架构
        第15章 什么是软件架构  120
        开发（Development）  122
        部署（Deployment）  123
        运行（Operation）  123
        维护（Maintenance）  124
        保持可选项  124
        设备无关性  126
        垃圾邮件  128
        物理地址寻址  129
        本章小结  130
        第16章 独立性  131
        用例  132
        运行  133
        开发  133
        部署  134
        保留可选项  134
        按层解耦  135
        用例的解耦  136
        解耦的模式  136
        开发的独立性  137
        部署的独立性  137
        重复  138
        再谈解耦模式  139
        本章小结  141
        第17章 划分边界  142
        几个悲伤的故事  143
        FitNesse  146
        应在何时、何处画这些线  148
        输入和输出怎么办  151
        插件式架构  152
        插件式架构的好处  153
        本章小结  154
        第18章 边界剖析  155
        跨边界调用  156
        令人生畏的单体结构  156
        部署层次的组件  158
        线程  159
        本地进程  159
        服务  160
        本章小结  161
        第19章 策略与层次  162
        层次（Level）  163
        本章小结  166
        第20章 业务逻辑  167
        业务实体  168
        用例  169
        请求和响应模型  171
        本章小结  172
        第21章 尖叫的软件架构  173
        架构设计的主题  174
        架构设计的核心目标  175
        那Web呢  175
        框架是工具而不是生活信条  175
        可测试的架构设计  176
        本章小结  176
        第22章 整洁架构  177
        依赖关系规则  179
        一个常见的应用场景  183
        本章小结  184
        第23章 展示器和谦卑对象  185
        谦卑对象模式  186
        展示器与视图  186
        测试与架构  187
        数据库网关  188
        数据映射器  188
        服务监听器  189
        本章小结  189
        第24章 不完全边界  190
        省掉最后一步  191
        单向边界  192
        门户模式  193
        本章小结  193
        第25章 层次与边界  194
        基于文本的冒险游戏：Hunt The Wumpus  195
        可否采用整洁架构  196
        交汇数据流  199
        数据流的分割  199
        本章小结  201
        第26章 Main组件  203
        最细节化的部分  204
        本章小结  208
        第27章 服务：宏观与微观  209
        面向服务的架构  210
        服务所带来的好处  210
        运送猫咪的难题  212
        对象化是救星  213
        基于组件的服务  215
        横跨型变更  216
        本章小结  216
        第28章 测试边界  217
        测试也是一种系统组件  218
        可测试性设计  219
        测试专用API  220
        本章小结  221
        第29章 整洁的嵌入式架构  222
        “程序适用测试”测试  225
        目标硬件瓶颈  228
        本章小结  238
        第6部分  实现细节
        第30章 数据库只是实现细节  240
        关系型数据库  241
        为什么数据库系统如此流行  242
        假设磁盘不存在会怎样  243
        实现细节  243
        但性能怎么办呢  244
        一段轶事  244
        本章小结  246
        第31章 Web是实现细节  247
        无尽的钟摆  248
        总结一下  250
        本章小结  251
        第32章 应用程序框架是实现细节  252
        框架作者  253
        单向婚姻  253
        风险  254
        解决方案  255
        不得不接受的依赖  255
        本章小结  256
        第33章 案例分析：视频销售网站  257
        产品  258
        用例分析  258
        组件架构  260
        依赖关系管理  261
        本章小结  262
        第34章 拾遗  263
        按层封装  264
        按功能封装  266
        端口和适配器  268
        按组件封装  270
        具体实现细节中的陷阱  274
        组织形式与封装的区别  275
        其他的解耦合模式  277
        本章小结：本书拾遗  279
        后序  280
        附录A  架构设计考古  283
     · · · · · ·     (收起)"
5387403,Effective C++,9.5,(1104人评价),[美] Scott Meyers / 侯捷 / 电子工业出版社 / 2011-1-1 / 65.00元,"在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。
作者高超的技术把握力、独特...",https://book.douban.com/subject/5387403/,https://img2.doubanio.com/view/subject/s/public/s4647091.jpg,65.00元,9787121123320,在国际上，本书所引起的反响，波及整个计算机技术的出版领域，余音至今未绝。几乎在所有C++书籍的推荐名单上，这本书都会位于前三名。 作者高超的技术把握力、独特的视角、诙谐轻松的写作风格、独具匠心的内容组织，都受到极大的推崇和仿效。 这本书不是读完一遍就可以束之高阁的快餐读物，也不是用以解决手边问题的参考手册，而是需要你去反复阅读体会的，C++是真正程序员的语言，背后有着精深的思想与无以伦比的表达能力，这使得它具有类似宗教般的魅力。,"侯捷
译者","译序
        中英简繁术语对照
        目录
        序言
        致谢
        导读
        1. 让自己习惯c++
        2. 构造/析构/赋值运算
        3. 资源管理
        4. 设计与声明
        5. 实现
        6. 继承与面向对象设计
        7. 模板与泛型编程
        8. 定制new和delete
        9. 杂项讨论
        a 本书之外
        b 新旧版条款对照
        索引
     · · · · · ·     (收起)"
36654266,高级算法和数据结构,9.7,(28人评价),马塞洛·拉·罗卡（Marcello La Rocca） / 肖鉴明 / 人民邮电出版社 / 2023-12 / 149.80元,这是一本关于“高级/进阶”算法和数据结构的图书，主要介绍了用于Web应用程序、系统编程和数据处理领域的各种算法，旨在让读者了解如何用这些算法应对各种棘手的编...,https://book.douban.com/subject/36654266/,https://img9.doubanio.com/view/subject/s/public/s34704215.jpg,149.80元,9787115614575,这是一本关于“高级/进阶”算法和数据结构的图书，主要介绍了用于Web应用程序、系统编程和数据处理领域的各种算法，旨在让读者了解如何用这些算法应对各种棘手的编码挑战，以及如何将其应用于具体问题，以应对新技术浪潮下的“棘手”问题。 本书对一些广为人知的基本算法进行了扩展，还介绍了用于改善优先队列、有效缓存、对数据进行集群等的技术，以期读者能针对不同编程问题选出更好的解决方案。书中示例大多辅以图解，并以不囿于特定语言的伪代码以及多种语言的代码样本加以闸释。 学完本书，读者可以了解高级算法和数据结构的相关内容，并能运用这些知识让代码具备更优性能，甚至能够独立设计数据结构，应对需要自定义解决方案的情况。 本书可作为高等院校计算机相关专业本科高年级学生以及研究生的学习用书，也可供从事与算法相关工作的开发者参考。,Marcello La Rocca现为一家电商公司的高级软件工程师，曾参与开发Twitter、微软和苹果等公司的大型Web应用程序和数据基础设施，并发明了NeatSort这一自适应排序算法。他的主要研究领域为图、算法优化、机器学习和量子计算。,"第1章　初识数据结构　1
        1.1　数据结构　2
        1.1.1　定义数据结构　2
        1.1.2　描述数据结构　3
        1.1.3　算法与数据结构有区别吗　4
        1.2　设定目标：阅读本书后的期望　4
        1.3　打包背包：数据结构与现实世界的结合　5
        1.3.1　抽象化问题　5
        1.3.2　寻找解决方案　6
        1.3.3　拯救大家的算法　7
        1.3.4　打破常规来思考问题　8
        1.3.5　完美的结局　9
        1.4　小结　9
        第一部分　改进基本数据结构
        第2章　改进优先队列：d叉堆　12
        2.1　本章结构　13
        2.2　问题：处理优先级　13
        2.3　已知解决方案：让列表保持有序　15
        2.4　描述数据结构API：优先队列　15
        2.4.1　使用优先队列　16
        2.4.2　优先级为何非常重要　17
        2.5　具体数据结构　17
        2.5.1　性能比较　18
        2.5.2　正确的具体数据结构是什么　18
        2.5.3　堆　18
        2.5.4　优先级、最小堆和最大堆　20
        2.5.5　高级变体：d叉堆　21
        2.6　如何实现堆　22
        2.6.1　向上冒泡　22
        2.6.2　向下推动　25
        2.6.3　插入　27
        2.6.4　移除顶部元素　28
        2.6.5　修改　30
        2.6.6　处理重复优先级　31
        2.6.7　堆化　32
        2.6.8　API之外的方法：包含　34
        2.6.9　性能回顾　34
        2.6.10　从伪代码到实现　35
        2.7　用例：找到最大的k个元素　35
        2.7.1　选择正确的数据结构　36
        2.7.2　正确地使用数据结构　36
        2.7.3　代码写起来　36
        2.8　更多的用例　37
        2.8.1　图中的最小距离：Dijkstra算法　37
        2.8.2　更多的图算法：Prim算法　37
        2.8.3　数据压缩：霍夫曼编码　38
        2.9　对分支因子进行分析　41
        2.9.1　是否需要d叉堆　41
        2.9.2　运行时间　42
        2.9.3　寻找最佳分支因子　42
        2.9.4　分支因子与内存的关系　43
        2.10　性能分析：寻找最佳分支因子　43
        2.10.1　剖析　44
        2.10.2　解释结果　45
        2.10.3　堆化的谜团　49
        2.10.4　选择最佳分支因子　49
        2.11　小结　50
        第3章　树堆：使用随机化来平衡二叉搜索树　52
        3.1　问题：多索引　53
        3.2　解决方案：描述与API　53
        3.3　树堆　54
        3.3.1　旋转　57
        3.3.2　一些设计问题　60
        3.3.3　实现搜索方法　61
        3.3.4　插入　61
        3.3.5　删除　64
        3.3.6　去顶、看顶以及修改　66
        3.3.7　返回最小键和最大键　67
        3.3.8　性能回顾　67
        3.4　应用：随机树堆　68
        3.4.1　平衡树　68
        3.4.2　引入随机化　70
        3.4.3　随机树堆的应用　71
        3.5　性能分析和剖析　72
        3.5.1　理论：期望高度　72
        3.5.2　剖析高度　74
        3.5.3　剖析运行时间　76
        3.5.4　剖析内存使用情况　78
        3.5.5　结论　78
        3.6　小结　80
        第4章　布隆过滤器：减少跟踪内容所需的内存　81
        4.1　字典问题：跟踪事物　82
        4.2　实现字典的其他方法　83
        4.3　描述数据结构API：关联数组　83
        4.4　具体数据结构　84
        4.4.1　无序数组：快速插入，慢速搜索　84
        4.4.2　有序数组和二分查找：慢插入，稍微快一些的搜索　85
        4.4.3　哈希表：在不需要有序的情况下，具有平均常数时间的性能　86
        4.4.4　二叉搜索树：所有操作都是对数阶的　86
        4.4.5　布隆过滤器：与哈希表一样快，但（由于一个缺陷而）更节省内存　88
        4.5　表面之下：布隆过滤器是如何工作的　88
        4.6　实现　89
        4.6.1　使用布隆过滤器　90
        4.6.2　位的读取和写入　91
        4.6.3　找到键存储的位置　92
        4.6.4　生成哈希函数　93
        4.6.5　构造函数　93
        4.6.6　查找键　94
        4.6.7　存储键　95
        4.6.8　估计准确率　96
        4.7　应用场景　97
        4.7.1　缓存　97
        4.7.2　路由　98
        4.7.3　爬虫　98
        4.7.4　I/O提取器　98
        4.7.5　拼写检查器　98
        4.7.6　分布式数据库和文件系统　99
        4.8　为什么布隆过滤器是可行的　99
        4.8.1　为什么没有假阴性　100
        4.8.2　为什么有假阳性　100
        4.8.3　作为随机算法的布隆过滤器　101
        4.9　性能分析　101
        4.9.1　运行时间　101
        4.9.2　构造函数　102
        4.9.3　存储元素　102
        4.9.4　查找元素　102
        4.10　估计布隆过滤器的精确度　102
        4.11　改进的变体　106
        4.11.1　布隆表过滤器　106
        4.11.2　组合布隆过滤器　106
        4.11.3　分层布隆过滤器　106
        4.11.4　压缩布隆过滤器　107
        4.11.5　可扩展布隆过滤器　107
        4.12　小结　108
        第5章　不交集：次线性时间的处理过程　109
        5.1　不同子集问题　110
        5.2　解决方案的论证　111
        5.3　描述数据结构API：不交集　112
        5.4　简单解决方案　113
        5.5　使用树状结构　117
        5.5.1　从链表转移到树　117
        5.5.2　实现使用树的版本　118
        5.6　改进运行时间的启发式算法　120
        5.6.1　路径压缩　121
        5.6.2　实现平衡性与路径压缩　122
        5.7　应用程序　124
        5.7.1　图：连通分量　124
        5.7.2　图：最小生成树的Kruskal算法　124
        5.7.3　聚类　125
        5.7.4　合一　126
        5.8　小结　126
        第6章　trie与基数树：高效的字符串搜索　127
        6.1　拼写检查　128
        6.1.1　拼写检查器的设计　128
        6.1.2　压缩是关键　129
        6.1.3　描述与API　129
        6.2　trie　130
        6.2.1　为什么trie更好　132
        6.2.2　搜索　134
        6.2.3　插入　137
        6.2.4　删除　139
        6.2.5　搜索最长前缀词　140
        6.2.6　返回匹配特定前缀的所有键　141
        6.2.7　什么时候应该使用trie　143
        6.3　基数树　144
        6.3.1　节点和边　146
        6.3.2　搜索　148
        6.3.3　插入　149
        6.3.4　删除　151
        6.3.5　搜索最长前缀词　153
        6.3.6　返回匹配特定前缀的所有键　153
        6.4　应用程序　154
        6.4.1　拼写检查器　154
        6.4.2　字符串相似度　156
        6.4.3　字符串排序　157
        6.4.4　T9　157
        6.4.5　自动完成　158
        6.5　小结　158
        第7章　用例：LRU缓存　160
        7.1　不要重复计算　160
        7.2　第一次尝试：记住数据　163
        7.2.1　描述与API　164
        7.2.2　请保存新数据　164
        7.2.3　处理异步调用　165
        7.2.4　将缓存的值标记为“正在加载”　166
        7.3　内存（真的）不够　167
        7.4　清除陈旧数据：LRU缓存　168
        7.4.1　有时必须要重复解决问题　169
        7.4.2　时间排序　170
        7.4.3　性能　174
        7.5　当新数据更有价值时：LFU　175
        7.5.1　如何选择缓存的清除策略　176
        7.5.2　LFU缓存有什么不同　176
        7.5.3　性能　178
        7.5.4　LFU缓存的不足　178
        7.6　如何使用缓存也同样重要　179
        7.7　同步简介　180
        7.7.1　（在Java中）解决并发问题　182
        7.7.2　锁简介　183
        7.7.3　获取锁　183
        7.7.4　重入锁　184
        7.7.5　读锁　185
        7.7.6　解决并发的其他方法　186
        7.8　缓存应用程序　186
        7.9　小结　187
        第二部分　多维查询
        第8章　最近邻搜索　190
        8.1　最近邻搜索问题　190
        8.2　解决方案　191
        8.2.1　第一次尝试　191
        8.2.2　有时缓存并不是答案　191
        8.2.3　简化事情以获得灵感　192
        8.2.4　谨慎选择数据结构　193
        8.3　描述与API　194
        8.4　迁移到k维空间　195
        8.4.1　一维二分查找　196
        8.4.2　迁移到更高维度　196
        8.4.3　用数据结构对二维空间进行建模　197
        8.5　小结　198
        第9章　k-d树：索引多维数据　199
        9.1　从结束的地方继续　199
        9.2　迁移到k维空间：循环遍历
        维度　199
        9.2.1　构造BST　201
        9.2.2　不变量　204
        9.2.3　保持平衡的重要性　204
        9.3　方法　205
        9.3.1　搜索　206
        9.3.2　插入　208
        9.3.3　平衡树　209
        9.3.4　删除　212
        9.3.5　最近邻搜索　218
        9.3.6　区域搜索　224
        9.3.7　所有方法的回顾　227
        9.4　限制与可能的改进　228
        9.5　小结　229
        第10章　相似性搜索树：图像检索的近似
        最近邻搜索　230
        10.1　从结束的地方继续　230
        10.1.1　一个新的（更复杂的）例子　231
        10.1.2　克服k-d树的缺陷　232
        10.2　R树　232
        10.2.1　先退一步：B树简介　232
        10.2.2　由B树到R树　233
        10.2.3　在R树中插入点　236
        10.2.4　搜索　237
        10.3　SS树　238
        10.3.1　搜索　241
        10.3.2　插入　244
        10.3.3　插入：方差、均值与投影　249
        10.3.4　插入：分裂节点　252
        10.3.5　删除　255
        10.4　相似性搜索　259
        10.4.1　最近邻搜索　260
        10.4.2　区域搜索　262
        10.4.3　近似相似性搜索　263
        10.5　SS+树　265
        10.5.1　SS树会更好吗　266
        10.5.2　缓解超球体的限制　267
        10.5.3　改进拆分启发式算法　267
        10.5.4　减少重叠　268
        10.6　小结　270
        第11章　最近邻搜索的应用　271
        11.1　应用程序：查找最近的枢纽　271
        11.1.1　解决方案的初稿　272
        11.1.2　天堂里的麻烦　273
        11.2　中心化应用程序　274
        11.2.1　过滤点　274
        11.2.2　复杂的决定　276
        11.3　迁移到分布式应用程序　278
        11.3.1　处理HTTP通信的问题　279
        11.3.2　保持库存同步　281
        11.3.3　经验教训　281
        11.4　其他应用程序　282
        11.4.1　色彩还原　282
        11.4.2　粒子的相互作用　283
        11.4.3　多维数据库查询的优化　285
        11.4.4　聚类　287
        11.5　小结　287
        第12章　聚类　288
        12.1　聚类简介　289
        12.1.1　机器学习的类型　289
        12.1.2　聚类的类型　290
        12.2　k均值算法　291
        12.2.1　k均值算法的问题　295
        12.2.2　维度诅咒再次来袭　296
        12.2.3　k均值算法的性能分析　297
        12.2.4　用k-d树来加快k均值算法　297
        12.2.5　关于k均值算法的最后一些提示　300
        12.3　DBSCAN算法　300
        12.3.1　直接可达与密度可达　301
        12.3.2　从定义到算法　302
        12.3.3　实现　304
        12.3.4　DBSCAN算法的优缺点　305
        12.4　OPTICS算法　307
        12.4.1　定义　308
        12.4.2　OPTICS算法的核心思想　308
        12.4.3　从可达距离到聚类　311
        12.4.4　分层聚类　314
        12.4.5　性能分析和最终的考虑　318
        12.5　评估聚类结果：评估指标　318
        12.6　小结　322
        第13章　并行聚类：MapReduce与树冠聚类　323
        13.1　并行化　323
        13.1.1　并行计算与分布式计算　324
        13.1.2　并行化k均值算法　325
        13.1.3　树冠聚类　325
        13.1.4　应用树冠聚类　327
        13.2　MapReduce　328
        13.2.1　MapReduce是如何工作的　328
        13.2.2　先映射，后归约　331
        13.2.3　表面之下，还有更多　334
        13.3　MapReduce版本的k均值算法　334
        13.3.1　并行化树冠聚类　337
        13.3.2　使用树冠聚类来进行质心的初始化　339
        13.3.3　MapReduce版本的树冠聚类　340
        13.4　MapReduce版本的DBSCAN 算法　343
        13.5　小结　348
        第三部分　平面图与最小交叉数
        第14章　图简介：寻找距离最短的
        路径　350
        14.1　定义　351
        14.1.1　图的实现　351
        14.1.2　作为代数类型的图　353
        14.1.3　伪代码　354
        14.2　图的属性　354
        14.2.1　无向　355
        14.2.2　连通　355
        14.2.3　无环　356
        14.3　图的遍历：BFS与DFS　357
        14.3.1　优化配送路线　357
        14.3.2　广度优先搜索　359
        14.3.3　重建到目标的路径　361
        14.3.4　深度优先搜索　362
        14.3.5　再次比较队列与堆栈　364
        14.3.6　投递包裹的最佳路线　365
        14.4　加权图中的最短路径：迪杰斯特拉 算法　365
        14.4.1　与BFS算法的区别　366
        14.4.2　实现　367
        14.4.3　分析　368
        14.4.4　投递包裹的最佳路线　369
        14.5　超越迪杰斯特拉算法：A*
        算法　370
        14.5.1　A*算法到底有多好　372
        14.5.2　将启发式函数作为平衡实时数据的一种方式　375
        14.6　小结　376
        第15章　图嵌入与平面性：绘制具有最少相交边的图　377
        15.1　图嵌入　378
        15.1.1　一些基础定义　379
        15.1.2　完全图与完全二分图　380
        15.2　平面图　381
        15.2.1　在实践中使用库拉托夫斯基定理　381
        15.2.2　平面性测试　382
        15.2.3　用于平面性测试的朴素算法　383
        15.2.4　提高性能　386
        15.2.5　高效的算法　388
        15.3　非平面图　389
        15.3.1　找到交叉数　391
        15.3.2　直线交叉数　392
        15.4　边的交叉点　393
        15.4.1　直线线段　394
        15.4.2　折线　397
        15.4.3　贝塞尔曲线　397
        15.4.4　二次贝塞尔曲线之间的交点　398
        15.4.5　顶点与顶点相交以及边与顶点相交　401
        15.5　小结　402
        第16章　梯度下降：（不仅是）图的优化问题　403
        16.1　用于交叉数的启发式算法　404
        16.1.1　刚才提到启发式了吗　404
        16.1.2　扩展到曲线边　408
        16.2　优化的工作原理　409
        16.2.1　成本函数　410
        16.2.2　阶跃函数与局部最小值　412
        16.2.3　优化随机抽样算法　412
        16.3　梯度下降　414
        16.3.1　梯度下降中的数学描述　415
        16.3.2　几何解释　416
        16.3.3　什么时候可以应用梯度下降　418
        16.3.4　梯度下降的问题　418
        16.4　梯度下降的应用　419
        16.5　使用梯度下降进行图嵌入　422
        16.5.1　另一种标准　423
        16.5.2　实现　425
        16.6　小结　426
        第17章　模拟退火：超越局部最小值的优化　427
        17.1　模拟退火　428
        17.1.1　有时候需要先向上爬才能到达底部　429
        17.1.2　实现　431
        17.1.3　为什么模拟退火是有效的　432
        17.1.4　短程与长程的转换　434
        17.1.5　变体　435
        17.1.6　模拟退火与梯度下降：应该选择哪一个呢　436
        17.2　模拟退火与旅行推销员　436
        17.2.1　精确解与近似解　438
        17.2.2　可视化成本　438
        17.2.3　修剪域　440
        17.2.4　状态转换　440
        17.2.5　相邻交换与随机交换　443
        17.2.6　TSP近似算法的应用　444
        17.3　模拟退火与图嵌入　444
        17.3.1　最小边交叉　445
        17.3.2　力导向绘制　446
        17.4　小结　450
        第18章　遗传算法：受生物学启发的快速收敛优化　451
        18.1　遗传算法简介　451
        18.1.1　来自大自然的灵感　453
        18.1.2　染色体　456
        18.1.3　种群　457
        18.1.4　适应度　458
        18.1.5　自然选择　459
        18.1.6　选择交配的个体　461
        18.1.7　交叉操作　466
        18.1.8　突变操作　468
        18.1.9　遗传算法模板　469
        18.1.10　遗传算法在什么时候效果最好　470
        18.2　TSP　471
        18.2.1　适应度、染色体与初始化　471
        18.2.2　突变操作　472
        18.2.3　交叉操作　472
        18.2.4　结果与参数调整　473
        18.2.5　超越TSP：优化整个车队的路线　476
        18.3　最小顶点覆盖　477
        18.3.1　顶点覆盖的应用　478
        18.3.2　实现遗传算法　478
        18.4　遗传算法的其他应用　480
        18.4.1　最大流问题　480
        18.4.2　蛋白质折叠　481
        18.4.3　超越遗传算法　482
        18.4.4　算法，超越本书　483
        18.5　小结　483
        附录A　伪代码快速指南　485
        附录B　大O符号　494
        附录C　核心数据结构　500
        附录D　类似于优先队列的容器　511
        附录E　递归　514
        附录F　分类问题与随机算法的度量指标　520
     · · · · · ·     (收起)"
30270959,深度学习入门,9.5,(1381人评价),[日］斋藤康毅 / 陆宇杰 / 人民邮电出版社 / 2018-7 / 59.00元,本书是深度学习真正意义上的入门书，深入浅出地剖析了深度学习的原理和相关技术。书中使用Python3，尽量不依赖外部库或工具，从基本的数学知识出发，带领读者从...,https://book.douban.com/subject/30270959/,https://img9.doubanio.com/view/subject/s/public/s29815955.jpg,59.00元,9787115485588,本书是深度学习真正意义上的入门书，深入浅出地剖析了深度学习的原理和相关技术。书中使用Python3，尽量不依赖外部库或工具，从基本的数学知识出发，带领读者从零创建一个经典的深度学习网络，使读者在此过程中逐步理解深度学习。书中不仅介绍了深度学习和神经网络的概念、特征等基础知识，对误差反向传播法、卷积神经网络等也有深入讲解，此外还介绍了深度学习相关的实用技巧，自动驾驶、图像生成、强化学习等方面的应用，以及为什么加深层可以提高识别精度等“为什么”的问题。,作者简介： 斋藤康毅 东京工业大学毕业，并完成东京大学研究生院课程。现从事计算机视觉与机器学习相关的研究和开发工作。是Introducing Python、Python in Practice、The Elements of Computing Systems、Building Machine Learning Systems with Python的日文版译者。 译者简介： 陆宇杰 众安科技NLP算法工程师。主要研究方向为自然语言处理及其应用，对图像识别、机器学习、深度学习等领域有密切关注。Python爱好者。,"译者序　　xiii
        前言　　xv
        第1章　Python入门　　1
        1.1 Python是什么　　1
        1.2 Python的安装　　2
        1.2.1　Python版本　　2
        1.2.2　使用的外部库　　2
        1.2.3　Anaconda发行版　　3
        1.3 Python解释器　　4
        1.3.1　算术计算　　4
        1.3.2　数据类型　　5
        1.3.3　变量　　5
        1.3.4　列表　　6
        1.3.5　字典　　7
        1.3.6　布尔型　　7
        1.3.7　if 语句　　8
        1.3.8　for 语句　　8
        1.3.9　函数　　9
        1.4 Python脚本文件　　9
        1.4.1　保存为文件　　9
        1.4.2　类　　10
        1.5 NumPy　　11
        1.5.1　导入NumPy　　11
        1.5.2　生成NumPy数组　　12
        1.5.3　NumPy 的算术运算　　12
        1.5.4　NumPy的N维数组　　13
        1.5.5　广播　　14
        1.5.6　访问元素　　15
        1.6 Matplotlib　　16
        1.6.1　绘制简单图形　　16
        1.6.2　pyplot 的功能　　17
        1.6.3　显示图像　　18
        1.7 小结　　19
        第2章　感知机　　21
        2.1 感知机是什么　　21
        2.2 简单逻辑电路　　23
        2.2.1　与门　　23
        2.2.2　与非门和或门　　23
        2.3 感知机的实现　　25
        2.3.1　简单的实现　　25
        2.3.2　导入权重和偏置　　26
        2.3.3　使用权重和偏置的实现　　26
        2.4 感知机的局限性　　28
        2.4.1　异或门　　28
        2.4.2　线性和非线性　　30
        2.5 多层感知机　　31
        2.5.1　已有门电路的组合　　31
        2.5.2　异或门的实现　　33
        2.6 从与非门到计算机　　35
        2.7 小结　　36
        第3章　神经网络　　37
        3.1 从感知机到神经网络　　37
        3.1.1　神经网络的例子　　37
        3.1.2　复习感知机　　38
        3.1.3　激活函数登场　　40
        3.2 激活函数　　42
        3.2.1　sigmoid 函数　　42
        3.2.2　阶跃函数的实现　　43
        3.2.3　阶跃函数的图形　　44
        3.2.4　sigmoid 函数的实现　　45
        3.2.5　sigmoid 函数和阶跃函数的比较　　46
        3.2.6　非线性函数　　48
        3.2.7　ReLU函数　　49
        3.3 多维数组的运算　　50
        3.3.1　多维数组　　50
        3.3.2　矩阵乘法　　51
        3.3.3　神经网络的内积　　55
        3.4　　3 层神经网络的实现　　56
        3.4.1　符号确认　　57
        3.4.2　各层间信号传递的实现　　58
        3.4.3　代码实现小结　　62
        3.5 输出层的设计　　63
        3.5.1　恒等函数和softmax 函数　　64
        3.5.2　实现softmax 函数时的注意事项　　66
        3.5.3　softmax 函数的特征　　67
        3.5.4　输出层的神经元数量　　68
        3.6 手写数字识别　　69
        3.6.1　MNIST数据集　　70
        3.6.2　神经网络的推理处理　　73
        3.6.3　批处理　　75
        3.7 小结　　79
        第4章　神经网络的学习　　81
        4.1 从数据中学习　　81
        4.1.1　数据驱动　　82
        4.1.2　训练数据和测试数据　　84
        4.2 损失函数　　85
        4.2.1　均方误差　　85
        4.2.2　交叉熵误差　　87
        4.2.3　mini-batch 学习　　88
        4.2.4　mini-batch 版交叉熵误差的实现　　91
        4.2.5　为何要设定损失函数　　92
        4.3 数值微分　　94
        4.3.1　导数　　94
        4.3.2　数值微分的例子　　96
        4.3.3　偏导数　　98
        4.4 梯度　　100
        4.4.1　梯度法　　102
        4.4.2　神经网络的梯度　　106
        4.5 学习算法的实现　　109
        4.5.1　2 层神经网络的类　　110
        4.5.2　mini-batch 的实现　　114
        4.5.3　基于测试数据的评价　　116
        4.6 小结　　118
        第5章　误差反向传播法　　121
        5.1 计算图　　121
        5.1.1　用计算图求解　　122
        5.1.2　局部计算　　124
        5.1.3　为何用计算图解题　　125
        5.2 链式法则　　126
        5.2.1　计算图的反向传播　　127
        5.2.2　什么是链式法则　　127
        5.2.3　链式法则和计算图　　129
        5.3 反向传播　　130
        5.3.1　加法节点的反向传播　　130
        5.3.2　乘法节点的反向传播　　132
        5.3.3　苹果的例子　　133
        5.4 简单层的实现　　135
        5.4.1　乘法层的实现　　135
        5.4.2　加法层的实现　　137
        5.5 激活函数层的实现　　139
        5.5.1　ReLU层　　139
        5.5.2　Sigmoid 层　　141
        5.6 AffineSoftmax层的实现　　144
        5.6.1　Affine层　　144
        5.6.2　批版本的Affine层　　148
        5.6.3　Softmax-with-Loss 层　　150
        5.7 误差反向传播法的实现　　154
        5.7.1　神经网络学习的全貌图　　154
        5.7.2　对应误差反向传播法的神经网络的实现　　155
        5.7.3　误差反向传播法的梯度确认　　158
        5.7.4　使用误差反向传播法的学习　　159
        5.8 小结　　161
        第6章　与学习相关的技巧　　163
        6.1 参数的更新　　163
        6.1.1　探险家的故事　　164
        6.1.2　SGD　　164
        6.1.3　SGD的缺点　　166
        6.1.4　Momentum　　168
        6.1.5　AdaGrad　　170
        6.1.6　Adam　　172
        6.1.7　使用哪种更新方法呢　　174
        6.1.8　基于MNIST数据集的更新方法的比较　　175
        6.2 权重的初始值　　176
        6.2.1　可以将权重初始值设为0 吗　　176
        6.2.2　隐藏层的激活值的分布　　177
        6.2.3　ReLU的权重初始值　　181
        6.2.4　基于MNIST数据集的权重初始值的比较　　183
        6.3 Batch Normalization　　184
        6.3.1　Batch Normalization 的算法　　184
        6.3.2　Batch Normalization 的评估　　186
        6.4 正则化　　188
        6.4.1　过拟合　　189
        6.4.2　权值衰减　　191
        6.4.3　Dropout　　192
        6.5 超参数的验证　　195
        6.5.1　验证数据　　195
        6.5.2　超参数的最优化　　196
        6.5.3　超参数最优化的实现　　198
        6.6 小结　　200
        第7章　卷积神经网络　　201
        7.1 整体结构　　201
        7.2 卷积层　　202
        7.2.1　全连接层存在的问题　　203
        7.2.2　卷积运算　　203
        7.2.3　填充　　206
        7.2.4　步幅　　207
        7.2.5　3 维数据的卷积运算　　209
        7.2.6　结合方块思考　　211
        7.2.7　批处理　　213
        7.3 池化层　　214
        7.4 卷积层和池化层的实现　　216
        7.4.1　4 维数组　　216
        7.4.2　基于im2col 的展开　　217
        7.4.3　卷积层的实现　　219
        7.4.4　池化层的实现　　222
        7.5 CNN的实现　　224
        7.6 CNN的可视化　　228
        7.6.1　第1 层权重的可视化　　228
        7.6.2　基于分层结构的信息提取　　230
        7.7 具有代表性的CNN　　231
        7.7.1　LeNet　　231
        7.7.2　AlexNet　　232
        7.8 小结　　233
        第8章　深度学习　　235
        8.1 加深网络　　235
        8.1.1　向更深的网络出发　　235
        8.1.2　进一步提高识别精度　　238
        8.1.3　加深层的动机　　240
        8.2 深度学习的小历史　　242
        8.2.1　ImageNet　　243
        8.2.2　VGG　　244
        8.2.3　GoogLeNet　　245
        8.2.4　ResNet　　246
        8.3 深度学习的高速化　　248
        8.3.1　需要努力解决的问题　　248
        8.3.2　基于GPU的高速化　　249
        8.3.3　分布式学习　　250
        8.3.4　运算精度的位数缩减　　252
        8.4 深度学习的应用案例　　253
        8.4.1　物体检测　　253
        8.4.2　图像分割　　255
        8.4.3　图像标题的生成　　256
        8.5 深度学习的未来　　258
        8.5.1　图像风格变换　　258
        8.5.2　图像的生成　　259
        8.5.3　自动驾驶　　261
        8.5.4　Deep Q-Network（强化学习）　　262
        8.6 小结　　264
        附录A　Softmax-with-Loss 层的计算图　　267
        A.1 正向传播　　268
        A.2 反向传播　　270
        A.3 小结　　277
        参考文献　　279
     · · · · · ·     (收起)"
25708312,C++ Primer 中文版（第 5 版）,9.4,(2781人评价),[美] Stanley B. Lippman、[美] Josée Lajoie、[美] Barbara E. Moo / 王刚、杨巨峰 / 电子工业出版社 / 2013-9-1 / 128.00元,这本久负盛名的 C++ 经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++ 大师 Stanley B. ...,https://book.douban.com/subject/25708312/,https://img1.doubanio.com/view/subject/s/public/s33903490.jpg,128.00元,9787121155352,这本久负盛名的 C++ 经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——C++ 大师 Stanley B. Lippman 的丰富实践经验，C++标准委员会原负责人 Josée Lajoie 对C++标准的深入理解，以及C+ + 先驱 Barbara E. Moo 在 C++教学方面的真知灼见外，更是基于全新的 C++11标准进行了全面而彻底的内容更新。非常难能可贵的是，本书所有示例均全部采用 C++11 标准改写，这在经典升级版中极其罕见——充分体现了 C++ 语言的重大进展及其全面实践。书中丰富的教学辅助内容、醒目的知识点提示，以及精心组织的编程示范，让这本书在 C++ 领域的权威地位更加不可动摇。无论是初学者入门，或是中、高级程序员提升，本书均为不容置疑的首选。,"Stanley B·Lippman
作者","第1章  开始	1
        1.1  编写一个简单的C++程序	2
        1.1.1  编译、运行程序	3
        1.2  初识输入输出	5
        1.3  注释简介	8
        1.4  控制流	10
        1.4.1  while语句	10
        1.4.2  for语句	11
        1.4.3  读取数量不定的输入数据	13
        1.4.4  if语句	15
        1.5  类简介	17
        1.5.1  Sales_item类	17
        1.5.2  初识成员函数	20
        1.6  书店程序	21
        小结	23
        术语表	23
        第Ⅰ部分  C++基础	27
        第2章  变量和基本类型	29
        2.1  基本内置类型	30
        2.1.1  算术类型	30
        2.1.2  类型转换	32
        2.1.3  字面值常量	35
        2.2  变量	38
        2.2.1  变量定义	38
        2.2.2  变量声明和定义的关系	41
        2.2.3  标识符	42
        2.2.4  名字的作用域	43
        2.3  复合类型	45
        2.3.1  引用	45
        2.3.2  指针	47
        2.3.3  理解复合类型的声明	51
        2.4  const限定符	53
        2.4.1  const的引用	54
        2.4.2  指针和const	56
        2.4.3  顶层const	57
        2.4.4  constexpr和常量表达式	58
        2.5  处理类型	60
        2.5.1  类型别名	60
        2.5.2  auto类型说明符	61
        2.5.3  decltype类型指示符	62
        2.6  自定义数据结构	64
        2.6.1  定义Sales_data类型	64
        2.6.2  使用Sales_data类	66
        2.6.3  编写自己的头文件	67
        小结	69
        术语表	69
        第3章  字符串、向量和数组	73
        3.1  命名空间的using声明	74
        3.2  标准库类型string	75
        3.2.1  定义和初始化string对象	76
        3.2.2  string对象上的操作	77
        3.2.3  处理string对象中的字符	81
        3.3  标准库类型vector	86
        3.3.1  定义和初始化vector对象	87
        3.3.2  向vector对象中添加元素	90
        3.3.3  其他vector操作	91
        3.4  迭代器介绍	95
        3.4.1  使用迭代器	95
        3.4.2  迭代器运算	99
        3.5  数组	101
        3.5.1  定义和初始化内置数组	101
        3.5.2  访问数组元素	103
        3.5.3  指针和数组	105
        3.5.4  C风格字符串	109
        3.5.5  与旧代码的接口	111
        3.6  多维数组	112
        小结	117
        术语表	117
        第4章  表达式	119
        4.1  基础	120
        4.1.1  基本概念	120
        4.1.2  优先级与结合律	121
        4.1.3  求值顺序	123
        4.2  算术运算符	124
        4.3  逻辑和关系运算符	126
        4.4  赋值运算符	129
        4.5  递增和递减运算符	131
        4.6  成员访问运算符	133
        4.7  条件运算符	134
        4.8  位运算符	135
        4.9  sizeof运算符	139
        4.10  逗号运算符	140
        4.11  类型转换	141
        4.11.1  算术转换	142
        4.11.2  其他隐式类型转换	143
        4.11.3  显式转换	144
        4.12  运算符优先级表	147
        小结	149
        术语表	149
        第5章  语句	153
        5.1  简单语句	154
        5.2  语句作用域	155
        5.3  条件语句	156
        5.3.1  if语句	156
        5.3.2  switch语句	159
        5.4  迭代语句	165
        5.4.1  while语句	165
        5.4.2  传统的for语句	166
        5.4.3  范围for语句	168
        5.4.4  do while语句	169
        5.5  跳转语句	170
        5.5.1  break语句	170
        5.5.2  continue语句	171
        5.5.3  goto语句	172
        5.6  TRY语句块和异常处理	172
        5.6.1  throw表达式	173
        5.6.2  try语句块	174
        5.6.3  标准异常	176
        小结	178
        术语表	178
        第6章  函数	181
        6.1  函数基础	182
        6.1.1  局部对象	184
        6.1.2  函数声明	186
        6.1.3  分离式编译	186
        6.2  参数传递	187
        6.2.1  传值参数	187
        6.2.2  传引用参数	188
        6.2.3  const形参和实参	190
        6.2.4  数组形参	193
        6.2.5  main：处理命令行选项	196
        6.2.6  含有可变形参的函数	197
        6.3  返回类型和return语句	199
        6.3.1  无返回值函数	200
        6.3.2  有返回值函数	200
        6.3.3  返回数组指针	205
        6.4  函数重载	206
        6.4.1  重载与作用域	210
        6.5  特殊用途语言特性	211
        6.5.1  默认实参	211
        6.5.2  内联函数和constexpr函数	213
        6.5.3  调试帮助	215
        6.6  函数匹配	217
        6.6.1  实参类型转换	219
        6.7  函数指针	221
        小结	225
        术语表	225
        第7章  类	227
        7.1  定义抽象数据类型	228
        7.1.1  设计Sales_data类	228
        7.1.2  定义改进的Sales_data类	230
        7.1.3  定义类相关的非成员函数	234
        7.1.4  构造函数	235
        7.1.5  拷贝、赋值和析构	239
        7.2  访问控制与封装	240
        7.2.1  友元	241
        7.3  类的其他特性	243
        7.3.1  类成员再探	243
        7.3.2  返回*this的成员函数	246
        7.3.3  类类型	249
        7.3.4  友元再探	250
        7.4  类的作用域	253
        7.4.1  名字查找与类的作用域	254
        7.5  构造函数再探	257
        7.5.1  构造函数初始值列表	258
        7.5.2  委托构造函数	261
        7.5.3  默认构造函数的作用	262
        7.5.4  隐式的类类型转换	263
        7.5.5  聚合类	266
        7.5.6  字面值常量类	267
        7.6  类的静态成员	268
        小结	273
        术语表	273
        第Ⅱ部  C++标准库	275
        第8章  IO库	277
        8.1  IO类	278
        8.1.1  IO对象无拷贝或赋值	279
        8.1.2  条件状态	279
        8.1.3  管理输出缓冲	281
        8.2  文件输入输出	283
        8.2.1  使用文件流对象	284
        8.2.2  文件模式	286
        8.3  string流	287
        8.3.1  使用istringstream	287
        8.3.2  使用ostringstream	289
        小结	290
        术语表	290
        第9章  顺序容器	291
        9.1  顺序容器概述	292
        9.2  容器库概览	294
        9.2.1  迭代器	296
        9.2.2  容器类型成员	297
        9.2.3  begin和end成员	298
        9.2.4  容器定义和初始化	299
        9.2.5  赋值和swap	302
        9.2.6  容器大小操作	304
        9.2.7  关系运算符	304
        9.3  顺序容器操作	305
        9.3.1  向顺序容器添加元素	305
        9.3.2  访问元素	309
        9.3.3  删除元素	311
        9.3.4  特殊的forward_list操作	312
        9.3.5  改变容器大小	314
        9.3.6  容器操作可能使迭代器失效	315
        9.4  vector对象是如何增长的	317
        9.5  额外的string操作	320
        9.5.1  构造string的其他方法	321
        9.5.2  改变string的其他方法	322
        9.5.3  string搜索操作	325
        9.5.4  compare函数	327
        9.5.5  数值转换	327
        9.6  容器适配器	329
        小结	332
        术语表	332
        第10章  泛型算法	335
        10.1  概述	336
        10.2  初识泛型算法	338
        10.2.1  只读算法	338
        10.2.2  写容器元素的算法	339
        10.2.3  重排容器元素的算法	342
        10.3  定制操作	344
        10.3.1  向算法传递函数	344
        10.3.2  lambda表达式	345
        10.3.3  lambda捕获和返回	349
        10.3.4  参数绑定	354
        10.4  再探迭代器	357
        10.4.1  插入迭代器	358
        10.4.2  iostream迭代器	359
        10.4.3  反向迭代器	363
        10.5  泛型算法结构	365
        10.5.1  5类迭代器	365
        10.5.2  算法形参模式	367
        10.5.3  算法命名规范	368
        10.6  特定容器算法	369
        小结	371
        术语表	371
        第11章  关联容器	373
        11.1  使用关联容器	374
        11.2  关联容器概述	376
        11.2.1  定义关联容器	376
        11.2.2  关键字类型的要求	378
        11.2.3  pair类型	379
        11.3  关联容器操作	381
        11.3.1  关联容器迭代器	382
        11.3.2  添加元素	383
        11.3.3  删除元素	386
        11.3.4  map的下标操作	387
        11.3.5  访问元素	388
        11.3.6  一个单词转换的map	391
        11.4  无序容器	394
        小结	397
        术语表	397
        第12章  动态内存	399
        12.1  动态内存与智能指针	400
        12.1.1  shared_ptr类	400
        12.1.2  直接管理内存	407
        12.1.3  shared_ptr和new结合使用	412
        12.1.4  智能指针和异常	415
        12.1.5  unique_ptr	417
        12.1.6  weak_ptr	420
        12.2  动态数组	423
        12.2.1  new和数组	423
        12.2.2  allocator类	427
        12.3  使用标准库：文本查询程序	430
        12.3.1  文本查询程序设计	430
        12.3.2  文本查询程序类的定义	432
        小结	436
        术语表	436
        第Ⅲ部分  类设计者的工具	437
        第13章  拷贝控制	439
        13.1  拷贝、赋值与销毁	440
        13.1.1  拷贝构造函数	440
        13.1.2  拷贝赋值运算符	443
        13.1.3  析构函数	444
        13.1.4  三/五法则	447
        13.1.5  使用=default	449
        13.1.6  阻止拷贝	449
        13.2  拷贝控制和资源管理	452
        13.2.1  行为像值的类	453
        13.2.2  定义行为像指针的类	455
        13.3  交换操作	457
        13.4  拷贝控制示例	460
        13.5  动态内存管理类	464
        13.6  对象移动	470
        13.6.1  右值引用	471
        13.6.2  移动构造函数和移动赋值运算符	473
        13.6.3  右值引用和成员函数	481
        小结	486
        术语表	486
        第14章  操作重载与类型转换	489
        14.1  基本概念	490
        14.2  输入和输出运算符	494
        14.2.1  重载输出运算符<<	494
        14.2.2  重载输入运算符>>	495
        14.3  算术和关系运算符	497
        14.3.1  相等运算符	497
        14.3.2  关系运算符	498
        14.4  赋值运算符	499
        14.5  下标运算符	501
        14.6  递增和递减运算符	502
        14.7  成员访问运算符	504
        14.8  函数调用运算符	506
        14.8.1  lambda是函数对象	507
        14.8.2  标准库定义的函数对象	509
        14.8.3  可调用对象与function	511
        14.9  重载、类型转换与运算符	514
        14.9.1  类型转换运算符	514
        14.9.2  避免有二义性的类型转换	517
        14.9.3  函数匹配与重载运算符	521
        小结	523
        术语表	523
        第15章  面向对象程序设计	525
        15.1  OOP：概述	526
        15.2  定义基类和派生类	527
        15.2.1  定义基类	528
        15.2.2  定义派生类	529
        15.2.3  类型转换与继承	534
        15.3  虚函数	536
        15.4  抽象基类	540
        15.5  访问控制与继承	542
        15.6  继承中的类作用域	547
        15.7  构造函数与拷贝控制	551
        15.7.1  虚析构函数	552
        15.7.2  合成拷贝控制与继承	552
        15.7.3  派生类的拷贝控制成员	554
        15.7.4  继承的构造函数	557
        15.8  容器与继承	558
        15.8.1  编写Basket类	559
        15.9  文本查询程序再探	562
        15.9.1  面向对象的解决方案	563
        15.9.2  Query_base类和Query类	567
        15.9.3  派生类	568
        15.9.4  eval函数	571
        小结	575
        术语表	575
        第16章  模板与泛型编程	577
        16.1  定义模板	578
        16.1.1  函数模板	578
        16.1.2  类模板	583
        16.1.3  模板参数	592
        16.1.4  成员模板	595
        16.1.5  控制实例化	597
        16.1.6  效率与灵活性	599
        16.2  模板实参推断	600
        16.2.1  类型转换与模板类型参数	601
        16.2.2  函数模板显式实参	603
        16.2.3  尾置返回类型与类型转换	604
        16.2.4  函数指针和实参推断	607
        16.2.5  模板实参推断和引用	608
        16.2.6  理解std::move	610
        16.2.7  转发	612
        16.3  重载与模板	614
        16.4  可变参数模板	618
        16.4.1  编写可变参数函数模板	620
        16.4.2  包扩展	621
        16.4.3  转发参数包	622
        16.5  模板特例化	624
        小结	630
        术语表	630
        第Ⅳ部分  高级主题	633
        第17章  标准库特殊设施	635
        17.1  tuple类型	636
        17.1.1  定义和初始化tuple	637
        17.1.2  使用tuple返回多个值	638
        17.2  BITSET类型	640
        17.2.1  定义和初始化bitset	641
        17.2.2  bitset操作	643
        17.3  正则表达式	645
        17.3.1  使用正则表达式库	646
        17.3.2  匹配与Regex迭代器类型	650
        17.3.3  使用子表达式	653
        17.3.4  使用regex_replace	657
        17.4  随机数	659
        17.4.2  其他随机数分布	663
        bernoulli_distribution类	665
        17.5  IO库再探	666
        17.5.1  格式化输入与输出	666
        17.5.2  未格式化的输入/输出操作	673
        17.5.3  流随机访问	676
        小结	680
        术语表	680
        第18章  用于大型程序的工具	683
        18.1  异常处理	684
        18.1.1  抛出异常	684
        18.1.2  捕获异常	687
        18.1.3  函数try语句块与构造函数	689
        18.1.4  noexcept异常说明	690
        18.1.5  异常类层次	693
        18.2  命名空间	695
        18.2.1  命名空间定义	695
        18.2.2  使用命名空间成员	701
        18.2.3  类、命名空间与作用域	705
        18.2.4  重载与命名空间	708
        18.3  多重继承与虚继承	710
        18.3.1  多重继承	711
        18.3.2  类型转换与多个基类	713
        18.3.3  多重继承下的类作用域	715
        18.3.4  虚继承	717
        18.3.5  构造函数与虚继承	720
        小结	722
        术语表	722
        第19章  特殊工具与技术	725
        19.1  控制内存分配	726
        19.1.1  重载new和delete	726
        19.1.2  定位new表达式	729
        19.2  运行时类型识别	730
        19.2.1  dynamic_cast运算符	730
        19.2.2  typeid运算符	732
        19.2.3  使用RTTI	733
        19.2.4  type_info类	735
        19.3  枚举类型	736
        19.4  类成员指针	739
        19.4.1  数据成员指针	740
        19.4.2  成员函数指针	741
        19.4.3  将成员函数用作可调用对象	744
        19.5  嵌套类	746
        19.6  union：一种节省空间的类	749
        19.7  局部类	754
        19.8  固有的不可移植的特性	755
        19.8.1  位域	756
        19.8.2  volatile限定符	757
        19.8.3  链接指示：extern ""C""	758
        小结	762
        术语表	762
        附录A  标准库	765
        A.1  标准库名字和头文件	766
        A.2  算法概览	770
        A.2.1  查找对象的算法	771
        A.2.2  其他只读算法	772
        A.2.3  二分搜索算法	772
        A.2.4  写容器元素的算法	773
        A.2.5  划分与排序算法	775
        A.2.6  通用重排操作	776
        A.2.7  排列算法	778
        A.2.8  有序序列的集合算法	778
        A.2.9  最小值和最大值	779
        A.2.10  数值算法	780
        A.3  随机数	781
        A.3.1  随机数分布	781
        A.3.2  随机数引擎	783
        C++11的新特性
        2.1.1  long long类型	31
        2.2.1  列表初始化	39
        2.3.2  nullptr常量	48
        2.4.4  constexpr变量	59
        2.5.1  类型别名声明	60
        2.5.2  auto类型指示符	61
        2.5.3  decltype类型指示符	62
        2.6.1  类内初始化	65
        3.2.2  使用auto或decltype缩写类型	79
        3.2.3  范围for语句	82
        3.3   定义vector对象的vector（向量的向量）	87
        3.3.1  vector对象的列表初始化	88
        3.4.1  容器的cbegin和cend函数	98
        3.5.3  标准库begin和end函数	106
        3.6   使用auto和decltype简化声明	115
        4.2   除法的舍入规则	125
        4.4   用大括号包围的值列表赋值	129
        4.9   将sizeof用于类成员	139
        5.4.3 范围for语句	168
        6.2.6  标准库initializer_list类	197
        6.3.2  列表初始化返回值	203
        6.3.3  定义尾置返回类型	206
        6.3.3  使用decltype简化返回类型定义
        6.5.2  constexpr函数	214
        7.1.4  使用=default生成默认构造函数	237
        7.3.1  类对象成员的类内初始化	246
        7.5.2  委托构造函数	261
        7.5.6  constexpr构造函数	268
        8.2.1  用string对象处理文件名	284
        9.1   array和forward_list容器	293
        9.2.3 容器的cbegin和cend函数	298
        9.2.4  容器的列表初始化	300
        9.2.5  容器的非成员函数swap	303
        9.3.1  容器insert成员的返回类型	308
        9.3.1  容器的emplace成员的返回类型	308
        9.4   shrink_to_fit	318
        9.5.5  string的数值转换函数	327
        10.3.2  Lambda表达式	346
        10.3.3  Lambda表达式中的尾置返回类型	353
        10.3.4  标准库bind函数	354
        11.2.1  关联容器的列表初始化	377
        11.2.3  列表初始化pair的返回类型	380
        11.3.2  pair的列表初始化	384
        11.4   无序容器	394
        12.1   智能指针	400
        12.1.1  shared_ptr类
        12.1.2  动态分配对象的列表初始化	407
        12.1.2  auto和动态分配	408
        12.1.5  unique_ptr类	417
        12.1.6  weak_ptr类	420
        12.2.1  范围for语句不能应用于动态分配数组	424
        12.2.1  动态分配数组的列表初始化	424
        12.2.1  auto不能用于分配数组	424
        12.2.2  allocator::construct可使用任意构造函数	428
        13.1.5  将=default用于拷贝控制成员	449
        13.1.6  使用=default阻止拷贝类对象	449
        13.5   用移动类对象代替拷贝类对象	469
        13.6.1  右值引用	471
        13.6.1  标准库move函数	472
        13.6.2  移动构造函数和移动赋值	473
        13.6.2  移动构造函数通常应该是noexcept	473
        13.6.2  移动迭代器	480
        13.6.3  引用限定成员函数	483
        14.8.3  function类模板	512
        14.9.1  explicit类型转换运算符	516
        15.2.2  虚函数的override指示符	530
        15.2.2  通过定义类为final来阻止继承	533
        15.3   虚函数的override和final指示符	538
        15.7.2  删除的拷贝控制和继承	553
        15.7.4  继承的构造函数	557
        16.1.2  声明模板类型形参为友元	590
        16.1.2  模板类型别名	590
        16.1.3  模板函数的默认模板参数	594
        16.1.5  实例化的显式控制	597
        16.2.3  模板函数与尾置返回类型	605
        16.2.5  引用折叠规则	609
        16.2.6  用static_cast将左值转换为右值	612
        16.2.7  标准库forward函数	614
        16.4   可变参数模板	618
        16.4   sizeof...运算符	619
        16.4.3  可变参数模板与转发	622
        17.1   标准库Tuple类模板	636
        17.2.2  新的bitset运算	643
        17.3   正则表达式库	645
        17.4   随机数库	659
        17.5.1  浮点数格式控制	670
        18.1.4  noexcept异常指示符	690
        18.1.4  noexcept运算符	691
        18.2.1  内联名字空间	699
        18.3.1  继承的构造函数和多重继承	712
        19.3   有作用域的enum	736
        19.3   说明类型用于保存enum对象	738
        19.3   enum的提前声明	738
        19.4.3  标准库mem_fn类模板	746
        19.6   类类型的联合成员	751
     · · · · · ·     (收起)"
35141774,面向对象是怎样工作的（第2版）,8.2,(129人评价),[日]平泽章 / 侯振龙 / 人民邮电出版社 / 2020-7-13 / 69,本书以图配文的形式，直观易懂地详细介绍了面向对象的全貌及其中包含的各项技术，包括面向对象编程、框架、设计模式、UML、建模、面向对象设计和敏捷开发等。对于各...,https://book.douban.com/subject/35141774/,https://img3.doubanio.com/view/subject/s/public/s33687793.jpg,69,9787115541239,本书以图配文的形式，直观易懂地详细介绍了面向对象的全貌及其中包含的各项技术，包括面向对象编程、框架、设计模式、UML、建模、面向对象设计和敏捷开发等。对于各项技术是如何使用的（How），书中只进行最小限度的说明，而重点介绍这些技术究竟是什么样的（What）以及为什么需要这些技术（Why）。另外，书中设有“编程往事”专栏，介绍了作者年轻时的一些经历；还设有“对象的另一面”专栏，以与正文不同的视角讲解面向对象这一概念普及的背景和原因，通俗有趣。,平泽章 就职于UL System株式会社，多次参与面向大型金融机构的第三次在线系统的开发等系统开发工作，后负责技术咨询业务，2001年转为现在的职务。著有《UML建模教程》，是Working Effectively With Legacy Code、Refactoring: Improving the Design of Existing Code日文版译者之一。,"第1章 面向对象：让软件开发变轻松的技术	1
        1.1　面向对象是软件开发的综合技术　3
        1.2　以对象为中心编写软件的开发方法　4
        1.3　从编程语言演化为综合技术　4
        1.4　在混乱的状态下去理解，就会觉得很难　5
        1.5　混乱之一：术语洪流　6
        1.6　混乱之二：比喻滥用　7
        1.7　混乱之三：“一切都是对象”综合征　8
        1.8　三种混乱增大了理解的难度　9
        1.9　因为不理解，所以才感觉神秘　10
        1.10　消除这三种混乱，就能看到面向对象的真面目　10
        1.11　本书的构成　11
        第2章 似是而非：面向对象与现实世界　13
        2.1　如果只理解概念，就容易混乱　15
        2.2　对照现实世界介绍面向对象　15
        2.3　类指类型，实例指具体的物　16
        2.4　多态让消息的发送方法通用　18
        2.5　继承对共同点和不同点进行系统的分类和整理　20
        2.6　面向对象和现实世界是似是而非的　22
        2.7　现实世界的人和物不是由类创建的　23
        2.8　现实世界的人和物并不只是根据消息来行动　24
        2.9　明确定义为编程结构　25
        2.10　软件并不会直接表示现实世界　25
        2.11　与现实世界的相似扩大了可能性　26
        专栏　对象的另一面
        成为潮词的面向对象　27
        第3章　理解OOP：编程语言的历史　29
        3.1　OOP的出现具有必然性　31
        3.2　最初使用机器语言编写程序　31
        3.3　编程语言的第 一步是汇编语言　32
        3.4　高级语言的发明使程序更加接近人类　33
        3.5　重视易懂性的结构化编程　34
        3.6　提高子程序的独立性，强化可维护性　35
        3.7　实现无GOTO编程的结构化语言　38
        3.8　进化方向演变为重视可维护性和可重用性　39
        3.9　没有解决全局变量问题和可重用性差的问题　41
        专栏　编程往事
        COBOL编译器的鸡和蛋的问题　45
        第4章　面向对象编程技术：去除冗余、进行整理　47
        4.1　OOP具有结构化语言所没有的三种结构　49
        4.2　OOP的结构会根据编程语言的不同而略有差异　51
        4.3　三大要素之一：类具有的三种功能　51
        4.4　类的功能之一：汇总　52
        4.5　类的功能之二：隐藏　55
        4.6　类的功能之三：创建很多个　58
        4.7　实例变量是限定访问范围的全局变量　61
        4.8　三大要素之二：实现调用端公用化的多态　63
        4.9　三大要素之三：去除类的重复定义的继承　67
        4.10　对三大要素的总结　70
        4.11　通过嵌入类型使程序员的工作变轻松　71
        4.12　将类作为类型使用　72
        4.13　编程语言“退化”了吗　74
        4.14　更先进的OOP结构　74
        4.15　进化的OOP结构之一：包　75
        4.16　进化的OOP结构之二：异常　76
        4.17　进化的OOP结构之三：垃圾回收　78
        4.18　对OOP进化的总结　80
        4.19　决心决定OOP的生死　81
        第5章　理解内存结构：程序员的基本素养　83
        5.1　理解OOP程序的运行机制　85
        5.2　两种运行方式：编译器与解释器　85
        5.3　解释、运行中间代码的虚拟机　88
        5.4　CPU同时运行多个线程　89
        5.5　使用静态区、堆区和栈区进行管理　91
        5.6　OOP的特征在于内存的用法　94
        5.7　每个类只加载一个类信息　95
        5.8　每次创建实例都会使用堆区　96
        5.9　在变量中存储实例的指针　97
        5.10　复制存储实例的变量时要多加注意　99
        5.11　多态让不同的类看起来一样　103
        5.12　根据继承的信息类型的不同，内存配置也不同　105
        5.13　孤立的实例由垃圾回收处理　107
        专栏　编程往事
        OOP中dump看起来很费劲？　113
        第6章　重用：OOP带来的软件重用和思想重用　115
        6.1　OOP的优秀结构能够促进重用　117
        6.2　类库是OOP的软件构件群　119
        6.3　标准类库是语言规范的一部分　120
        6.4　将Object类作为祖先类的继承结构　121
        6.5　框架存在各种含义　122
        6.6　框架是应用程序的半成品　123
        6.7　世界上可重用的软件构件群　124
        6.8　独立性较高的构件：组件　125
        6.9　设计模式是优秀的设计思想集　125
        6.10　设计模式是类库探险的路标　128
        6.11　扩展到各个领域的思想的重用　129
        6.12　通过类库和模式发现的重用的好处　130
        第7章　化为通用的归纳整理法的面向对象　133
        7.1　软件不会直接表示现实世界　135
        7.2　应用于集合论和职责分配　137
        7.3　在上流工程中化为通用的归纳整理法　139
        7.4　两种含义引起混乱　140
        7.5　分为OOP的扩展和归纳整理法进行思考　141
        7.6　为何化为了通用的归纳整理法　142
        专栏　对象的另一面
        语言在先，还是概念在先　143
        第8章　UML：查看无形软件的工具　145
        8.1　UML是表示软件功能和结构的图形的绘制方法　147
        8.2　UML有13种图形　148
        8.3　UML的使用方法大致分为三种　150
        8.4　UML的使用方法之一：表示程序结构和动作　151
        8.5　类图表示OOP程序的结构　151
        8.6　使用时序图和通信图表示动作　154
        8.7　UML的使用方法之二：表示归纳整理法的成果　156
        8.8　使用类图表示根据集合论进行整理的结果　157
        8.9　表示职责分配的时序图和通信图　160
        8.10　UML的使用方法之三：表示非面向对象　163
        8.11　使用用例图表示交给计算机的工作　163
        8.12　使用活动图表示工作流程　164
        8.13　使用状态机图表示状态的变化　165
        8.14　弥补自然语言和计算机语言缺点的“语言”　166
        第9章　建模：填补现实世界和软件之间的沟壑　171
        9.1　现实世界和软件之间存在沟壑　173
        9.2　计算机擅长固定工作和记忆工作　174
        9.3　通过业务分析、需求定义和设计来填补沟壑　175
        9.4　建模是顺利推进这3个阶段的工作的技术　176
        9.5　应用程序不同，建模的内容也不一样　177
        9.6　业务应用程序记录现实中的事情　178
        9.7　对图书馆的借阅业务进行建模　179
        9.8　使用用例图来表示图书馆业务　181
        9.9　用概念模型表示图书馆系统的信息　183
        9.10　业务应用程序中只有数据是无缝的　184
        9.11　嵌入式软件替换现实世界的工作　186
        9.12　嵌入式软件中设备的研究开发很重要　187
        9.13　使用状态机图来表示全自动工作的情形　189
        9.14　嵌入式软件一直执行单调的工作　190
        9.15　建模蕴含着软件开发的乐趣　191
        第10章 面向对象设计：拟人化和职责分配　195
        10.1　设计的目标范围很广　197
        10.2　相比运行效率，现在更重视可维护性和可重用性　198
        10.3　设计目标之一：去除重复　199
        10.4　设计目标之二：提高构件的独立性　200
        10.5　提高构件独立性的诀窍　202
        10.6　设计目标之三：避免依赖关系发生循环　203
        10.7　面向对象设计的“感觉”是拟人化和职责分配　205
        10.8　进行了职责分配的软件创建的奇妙世界　206
        第11章 衍生：敏捷开发和TDD　211
        11.1　仅靠技术和技术窍门，软件开发并不会成功　213
        11.2　系统地汇总了作业步骤和成果的开发流程　214
        11.3　限制修改的瀑布式开发流程　214
        11.4　瀑布式开发流程的极限　215
        11.5　灵活响应变化的迭代式开发流程　216
        11.6　RUP按时间分解和管理开发　217
        11.7　打破诸多限制的XP　219
        11.8　快速编写优秀软件的敏捷宣言　221
        11.9　支持敏捷开发的实践　222
        11.10　先编写测试代码，一边运行一边开发的测试驱动开发　222
        11.11　在程序完成后改善运行代码的重构　224
        11.12　经常进行系统整合的持续集成　225
        11.13　敏捷开发和TDD源于面向对象　226
        11.14　不存在最好的开发流程　227
        专栏　编程往事
        过去不被允许的XP　231
        第12章 熟练掌握面向对象　233
        12.1　面向对象这一强大概念是原动力　235
        12.2　时代追上了面向对象　236
        12.3　面向对象的热潮不会结束　237
        12.4　将面向对象作为工具熟练掌握　238
        12.5　享受需要动脑的软件开发　239
        第13章 函数式语言是怎样工作的　241
        13.1　面向对象的“下一代”开发技术　243
        13.2　函数式语言的7个特征　244
        13.3　特征1：使用函数编写程序　244
        13.4　特征2：所有表达式都返回值　246
        13.5　特征3：将函数作为值进行处理　250
        13.6　特征4：可以灵活组合函数和参数　252
        13.7　特征5：没有副作用　256
        13.8　特征6：使用分类和递归来编写循环处理　261
        13.9　特征7：编译器自动进行类型推断　266
        13.10　对7个特征的总结　270
        13.11　函数式语言的分类　271
        13.12　函数式语言的优势　271
        13.13　函数式语言的课题　272
        13.14　函数式语言和面向对象的关系　273
        13.15　函数式语言会普及吗　275
        后记　279
        致谢　280
     · · · · · ·     (收起)"
